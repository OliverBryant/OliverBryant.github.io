<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oliver&#39;s blog</title>
  
  
  <link href="https://www.oliverbryant.cn/atom.xml" rel="self"/>
  
  <link href="https://www.oliverbryant.cn/"/>
  <updated>2023-03-19T02:10:09.000Z</updated>
  <id>https://www.oliverbryant.cn/</id>
  
  <author>
    <name>Oliver Bryant</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Postgraduate_interview</title>
    <link href="https://www.oliverbryant.cn/2023/03/19/Postgraduate-interview/"/>
    <id>https://www.oliverbryant.cn/2023/03/19/Postgraduate-interview/</id>
    <published>2023-03-19T02:10:09.000Z</published>
    <updated>2023-03-19T02:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h1><h3 id="1-如何理解数据库系统的三层模式结构？"><a href="#1-如何理解数据库系统的三层模式结构？" class="headerlink" title="1.如何理解数据库系统的三层模式结构？"></a>1.如何理解数据库系统的三层模式结构？</h3><p>三层模式结构分别为外模式、模式和内模式</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/1654684980985_333333333333.jpg" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/1654684980985_333333333333.jpg" srcset="data:image/png;base64,666" alt="image"></p><ul><li><p>模式：又称逻辑模式，是对数据库中全部数据的逻辑结构和特性的描述，是数据库所有用户的公共数据视图。它处于三级结构的中间层，是整个数据库实际存储的抽象表示。DBMS提供模式描述语言（模式DDL）来严格定义模式</p></li><li><p>外模式：又称用户模式或子模式，通常是模式的子集，是数据库系统每个用户看到和使用的数据视图，即与某一应用有关的数据的逻辑表示。DBMS提供子模式描述语言（子模式DDL）来定义子模式</p></li><li><p>内模式：又称存储模式，是数据库所有数据的内部表示或者说是底层的描述，用来定义数据的存储方式和物理结构。DBMS提供内模式描述语言（内模式DDL）来定义内模式</p><p>  三层模式结构的优点：</p></li><li><p>保证数据的独立性</p></li><li><p>有利于数据共享</p></li><li><p>简化了用户接口</p></li><li><p>利于数据的安全保密</p></li></ul><h3 id="2-什么是数据E-R图"><a href="#2-什么是数据E-R图" class="headerlink" title="2.什么是数据E-R图"></a>2.什么是数据E-R图</h3><pre><code>E-R图是实体-联系模型，用以描述现实世界的概念模型，应用于数据库设计的概念模型设计</code></pre><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/images%20%281%29.jpg" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/images%20%281%29.jpg" srcset="data:image/png;base64,666" alt="image"></p><pre><code>E-R模型主要的元素是：实体集、属性、联系集</code></pre><ul><li>实体集：方框表示，内部标注实体的命名。</li><li>属性：椭圆框或圆角矩阵表示，内部表明属性名，通过实线与实体集相连（某些联系也有属性）</li><li>联系集：用菱形框表示，内部标明联系的命名，并用实线分别与有关的实体集相连，同时在实线旁标注联系的类型（1对1、1对n、m对n）</li></ul><h3 id="3-数据库基本逻辑运算"><a href="#3-数据库基本逻辑运算" class="headerlink" title="3.数据库基本逻辑运算"></a>3.数据库基本逻辑运算</h3><pre><code>关系代数用到的运算符包括四类：集合运算符、专门的关系运算符、算术比较运算符和逻辑运算符</code></pre><ul><li>集合运算符：<ul><li>交</li><li>并</li><li>差</li><li>笛卡尔积</li></ul></li><li>专门的关系运算符：<ul><li>选择</li><li>投影</li><li>链接</li><li>除</li></ul></li><li>比较运算符：<ul><li>大于</li><li>大于等于</li><li>小于</li><li>小于等于</li><li>等于</li><li>不等于</li></ul></li><li>逻辑运算符：<ul><li>非</li><li>与</li><li>或</li></ul></li></ul><h3 id="4-数据库管理系统（DBMS）的定义及其功能功能"><a href="#4-数据库管理系统（DBMS）的定义及其功能功能" class="headerlink" title="4.数据库管理系统（DBMS）的定义及其功能功能"></a>4.数据库管理系统（DBMS）的定义及其功能功能</h3><ul><li><p>定义：是位于用户与操作系统之间的一层数据管理软件，是数据库系统（DBS）的核心，有一组程序构成，主要功能如下：</p><ul><li>数据定义功能</li><li>数据操纵功能</li><li>数据库的运行管理功能</li><li>数据库的建立和维护功能</li></ul></li></ul><h3 id="5-数据库系统是什么？"><a href="#5-数据库系统是什么？" class="headerlink" title="5.数据库系统是什么？"></a>5.数据库系统是什么？</h3><pre><code>数据库系统就是基于数据库的计算机应用系统，由4部分组成：</code></pre><ul><li>数据库：数据的汇集，以一定的组织形式保存在存储介质上</li><li>数据库管理系统：管理数据库的系统软件，可以实现数据库系统的各种功能</li><li>应用程序：以数据库管理系统和数据库中的数据为基础的程序</li><li>用户：<ul><li>应用程序开发人员</li><li>系统管理员</li><li>最终用户</li></ul></li></ul><h3 id="6-什么是数据库定义语言和数据操作语言？"><a href="#6-什么是数据库定义语言和数据操作语言？" class="headerlink" title="6.什么是数据库定义语言和数据操作语言？"></a>6.什么是数据库定义语言和数据操作语言？</h3><ul><li>数据库定义语言DDL：用于描述或定义实体，例如CREATE、ALTER、DROP等</li><li>数据操作语言DML：用于增删改查的操作，例如SELECT、UPDATE、DELETE等</li></ul><h3 id="7-数据库设计步骤"><a href="#7-数据库设计步骤" class="headerlink" title="7.数据库设计步骤"></a>7.数据库设计步骤</h3><ol><li>需求分析<ul><li>调查分析用户的活动</li><li>收集和分析需求数据并确定系统边界</li><li>编写需求分析说明书</li></ul></li><li>概念结构设计：E-R模型</li><li>逻辑结构设计：先将E-R图转换为关系模型，然后根据具体DBMS的特点和限制转换为特定的DBMS支持的数据模型，最后进行优化</li><li>数据库物理设计<ul><li>确定数据库的物理结构，在关系数据库中主要指存取方法（索引方法（B+树）、聚簇方法、Hash方法）和存取结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ul></li><li>数据库实施<ul><li>用DDL定义数据库结构</li><li>组织数据入库（数据装载）</li><li>编制与调试应用程序</li><li>数据库试运行</li></ul></li><li>数据库运行和维护<ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析、改造</li><li>数据库的重组与重构造</li></ul></li></ol><h3 id="8-数据库事务的四个特性"><a href="#8-数据库事务的四个特性" class="headerlink" title="8.数据库事务的四个特性"></a>8.数据库事务的四个特性</h3><ul><li>原子性：若把一个事务看作一个程序，它要么完整地被执行，要么完全不执行</li><li>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>隔离性：当多个事务<B>并发</b>执行时，系统应保证一个事务的执行结果不受其他事务的干扰，事务并发执行结果与这些事务串行执行是的结果是一样的</li><li>持久性：一个事务一旦成功完成全部操作，则它对数据库的所有更新就永远地反映在数据库中，即使以后系统发生了故障</li></ul><h3 id="9-数据库日志文件及其作用"><a href="#9-数据库日志文件及其作用" class="headerlink" title="9. 数据库日志文件及其作用"></a>9. 数据库日志文件及其作用</h3><p>日志文件是用来记录事务对数据库的更新操作的文件，主要有两种格式：以记录为单位的日志文件和以数据块为单位的日志文件</p><p>作用：事务故障恢复和系统故障恢复并协助后备副本进行介质故障恢复</p><h3 id="10-数据库故障及其修复"><a href="#10-数据库故障及其修复" class="headerlink" title="10.数据库故障及其修复"></a>10.数据库故障及其修复</h3><ul><li>事务故障<ul><li>定义：违反某些完整性规则、出现运算溢出、应用程序发生错误等</li><li>措施：反向阅读日志文件，找出该事务的所有更新操作，对每个操作进行逆操作</li></ul></li><li>系统故障<ul><li>定义：由于某些原因，造成系统停止运行，丢失了系统缓冲区的数据</li><li>措施：<ul><li>根据日志文件建立重做队列和撤销队列</li><li>对各自队列中的事务进行处理</li></ul></li></ul></li><li>介质故障<ul><li>定义：系统运行过程中，存储在外存上的数据部分损失或完全损失</li><li>措施：<ul><li>重装存储的数据库副本，是数据库恢复到转储时的一致状态</li><li>从第一个让日志文件开始装入，找到需要重做的事务，逐一REDO</li></ul></li></ul></li></ul><h3 id="11-并发控制"><a href="#11-并发控制" class="headerlink" title="11.并发控制"></a>11.并发控制</h3><ul><li>并发带来的问题：<ul><li>丢失修改</li><li>不可重复读（包括幻影）</li><li>读脏数据</li></ul></li><li>解决方法：<ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li></ul></li></ul><h3 id="12-封锁"><a href="#12-封锁" class="headerlink" title="12.封锁"></a>12.封锁</h3><ol><li>封锁类型：<ul><li>排它锁（X锁）：又称写锁，事务T对数据对象A加了X锁，T可以对A进行读和更新，期间其他事务不能对A加任何锁</li><li>共享锁（S锁）：又称读锁，事务T对数据对象A加了S锁，T可以对A进行读取操作，但不能进行更新，期间其他事务能对A加S锁，但不能加X锁</li></ul></li><li>封锁协议：<ul><li>三级封锁协议：<ul><li>一级：事务T在修改数据R之前必须对其加X锁，直到事务结束释放（解决丢失修改）</li><li>二级：一级封锁协议加上事务T在读取数据R之前必须对其加S锁，读完即可释放S锁（解决读脏数据）</li><li>三级：一级封锁协议加上事务T在读取数据R之前必须对其加S锁，直到事务结束释放（解决不可重复读）</li></ul></li><li>两段封锁协议<ul><li>将每个事务的执行分为两个阶段：加锁阶段和解锁阶段</li><li>事务开始后就处于加锁阶段，一直执行到ROLLBACK和COMMIT之前都是，而ROLLBACK和COMMIT使事务进入解锁阶段</li></ul></li></ul></li><li>封锁粒度：封锁对象的大小，可以是数据库、表、元组、属性</li></ol><h3 id="13-数据库存储的过程"><a href="#13-数据库存储的过程" class="headerlink" title="13.数据库存储的过程"></a>13.数据库存储的过程</h3><p>​    在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程中的名字并给出参数来执行</p><h3 id="14-数据的预处理"><a href="#14-数据的预处理" class="headerlink" title="14.数据的预处理"></a>14.数据的预处理</h3><p>​    在主要的处理以前对数据进行一些处理，以利于计算机的运算</p><ul><li>数据清理</li><li>数据集成</li><li>数据变换</li><li>数据归约</li></ul><h3 id="15-数据库的连接方式"><a href="#15-数据库的连接方式" class="headerlink" title="15.数据库的连接方式"></a>15.数据库的连接方式</h3><ul><li>等值连接与非等值连接：=</li><li>自身链接：将一个表与其自身链接</li><li>外连接：A中某个元组t，由于在B中没有任何一个元组满足与t的连接条件，因此t不会出现在A和B的连接结果中<ul><li>左外连接：先按照连接条件对表做条件连接，若A的某个元组t没有出现在结果中，则将t和B中的一个万能元组做链接，这个元组在所有列上取空值</li><li>右外连接：先按照连接条件对表做条件连接，若B的某个元组t没有出现在结果中，则将t和A中的一个万能元组做链接，这个元组在所有列上取空值</li><li>全外连接：上述两者的并</li></ul></li></ul><h3 id="16-数据定义"><a href="#16-数据定义" class="headerlink" title="16.数据定义"></a>16.数据定义</h3><ul><li><p>表：可以由一个或多个属性（列）组成，建表同时可以定义与该表有关的完整性约束条件。</p></li><li><p>索引：一个独立的、物理的数据库结构，基于表的一列或多列建立，按列值从小到大排序，索引往往被组织成一棵B+树</p><ul><li>分类：<ul><li>唯一索引与非唯一索引：相当于加了一个UNIQUE约束</li><li>聚簇索引和非聚簇索引：前者要求表中的元组的存放次序和索引中索引项的存放次序完全相同，也可以理解为表中的元组的也是有序的</li></ul></li></ul><p>索引是否越多越好：否。建立索引也需要空间，维护索引耗费性能</p></li><li><p>视图：从一个或多个表中导出的表，可以像对表一样进行查询。视图是一个虚表，数据库中只存储视图的定义，不存储视图的数据。</p><p>作用：</p><ul><li>简化用户操作</li><li>减少冗余数据</li><li>对重构数据库提供了一定程度的逻辑独立性</li><li>对机密数据提供安全保护</li></ul></li></ul><h3 id="17-候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结"><a href="#17-候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结" class="headerlink" title="17.候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结"></a>17.候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结</h3><p>（引用自<a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446%EF%BC%89">https://blog.csdn.net/sumaliqinghua/article/details/85872446）</a></p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/20190625173457198.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/20190625173457198.png" srcset="data:image/png;base64,666" alt="码的关系"></p><h1 id="软件工程篇"><a href="#软件工程篇" class="headerlink" title="软件工程篇"></a>软件工程篇</h1><h3 id="1-什么是软件工程"><a href="#1-什么是软件工程" class="headerlink" title="1. 什么是软件工程"></a>1. 什么是软件工程</h3><p>​    将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中</p><h3 id="2-软件的生命周期"><a href="#2-软件的生命周期" class="headerlink" title="2.软件的生命周期"></a>2.软件的生命周期</h3><p>​    是软件的产生直到报废的生命周期</p><ul><li>问题定义：确定系统要解决什么问题</li><li>可行性研究：对系统目标进行全面分析，把待开发系统的目标以明确的语言描述出来</li><li>需求分析：弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册</li><li>软件设计：把确定了的各项需求转换成一个相应的体系结构</li><li>编码和单元测试：按选定语言把软件设计转换为计算机能接受的代码并进行测试</li><li>综合测试：在设计测试用例的基础上检验软件的各个组成部分</li><li>运行/维护</li></ul><h3 id="3-软件过程"><a href="#3-软件过程" class="headerlink" title="3.软件过程"></a>3.软件过程</h3><ol><li>定义：将一组有序的任务称为过程</li><li>软件过程模型：<ul><li>瀑布模型：将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段</li><li>快速原型模型：快速建立起来可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成功能的一个子集</li><li>增量模型：假设可以将需求分段为一系列增量产品，每一增量分别开发，第一个增量往往是核心产品，然后不断增加新的功能</li><li>螺旋模型：将瀑布模型和快速原型模型结合起来，加入了风险分析</li><li>喷泉模型：以用户需求为动力，以对象作为驱动的模型，适合面向对象开发 </li></ul></li></ol><h3 id="4-软件开发的过程"><a href="#4-软件开发的过程" class="headerlink" title="4.软件开发的过程"></a>4.软件开发的过程</h3><ol><li>需求分析阶段</li><li>软件设计阶段</li><li>程序编码阶段</li><li>软件测试阶段</li></ol><h3 id="5-软件需求分析"><a href="#5-软件需求分析" class="headerlink" title="5. 软件需求分析"></a>5. 软件需求分析</h3><ul><li>确定对系统的综合要求</li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ul><p>​    </p><h3 id="6-软件测试"><a href="#6-软件测试" class="headerlink" title="6. 软件测试"></a>6. 软件测试</h3><ul><li>发现程序中的错误而执行程序的过程</li><li>好的测试方案是极可能发现迄今为止尚未发现错误的测试</li><li>成功的测试是发现了至今为止尚未发现的错误的测试</li><li>方法：<ul><li>静态分析与动态测试</li><li>黑盒测试和白盒测试</li></ul></li><li>三个测试阶段<ul><li>开发测试：在开发过程中对系统进行测试以发现bug和缺陷</li><li>发布测试：在系统发布给用户之前，单独的测试团队测试系统的完整版本</li><li>用户测试：其中系统的用户或潜在用户在自己的环境中测试</li></ul></li></ul><h3 id="7-黑盒测试与白盒测试"><a href="#7-黑盒测试与白盒测试" class="headerlink" title="7.黑盒测试与白盒测试"></a>7.黑盒测试与白盒测试</h3><ul><li>黑盒测试：<ul><li>把被测软件看成一个黑盒子，只考虑系统的输入和输出，完全不考虑程序内部的逻辑结构和处理过程</li><li>依据是开发各阶段的需求规格说明</li><li>主要检测软件的每一个功能是否能正常使用</li></ul></li><li>白盒测试：<ul><li>将黑盒子打开，研究源代码和程序内部的逻辑结构</li><li>主要检测软件编码过程中的错误</li></ul></li></ul><h3 id="8-软件维护"><a href="#8-软件维护" class="headerlink" title="8.软件维护"></a>8.软件维护</h3><ul><li>目标：纠正使用过程中暴露出来的错误，改进原有的软件而进行的维护</li><li>分类：<ul><li>纠错性维护：诊断和改正用户在使用软件时遇到的错误</li><li>适应性维护：为了使软件能适应新的硬件等环境而引起的程序修改和扩充活动</li><li>完善性维护：为了满足用户新的需求而增加软件功能的活动</li></ul></li></ul><h3 id="9-面向对象和面向过程"><a href="#9-面向对象和面向过程" class="headerlink" title="9.面向对象和面向过程"></a>9.面向对象和面向过程</h3><ul><li>面向对象：<ul><li>把事情看成是一个个小的对象组成的，或者说一个个小部分组成的</li><li>特点：<ul><li>封装：将一个数据及与这个数据有关的操作集合在一起，形成一个能动的实体即对象。用户不必知道对象行为的实现细节，只需要根据对象提供的外部特性接口访问对象即可</li><li>继承：能够直接获得已有事务的性质和特征，而不必重复定义</li><li>多态：同一个消息可以根据发送消息对象的不同表现出多种不同的行为方式</li></ul></li><li>优点：易维护、易复用、易扩展</li><li>缺点：性能比面向过程低</li></ul></li><li>面向过程：<ul><li>把一件事一项工程分解成一个个小的功能，用一个个函数来实现</li><li>优点：性能比面向对象高</li><li>缺点：不易维护、不易复用、不易扩展</li></ul></li></ul><h3 id="10-面向对象的一些概念"><a href="#10-面向对象的一些概念" class="headerlink" title="10.面向对象的一些概念"></a>10.面向对象的一些概念</h3><ul><li>对象：人们要进行研究的任何事物</li><li>类：具有相同或相似性质的对象的抽象，具有属性，即对象的状态的抽象；具有操作，即对象的行为的抽象</li><li>消息：对象之间进行通信的结构</li><li>方法：类中操作的实现过程</li></ul><h3 id="11-面向对象分析设计的三个模型"><a href="#11-面向对象分析设计的三个模型" class="headerlink" title="11.面向对象分析设计的三个模型"></a>11.面向对象分析设计的三个模型</h3><ul><li>对象模型：描述了现实世界中“类与对象”以及它们之间的关系，表达了目标系统的静态数据结构</li><li>动态模型：每个类的动态行为可用一张状态图描述，一组状态图通过共享事件相互关联集合起来，构成系统的动态模型</li><li>功能模型：描述系统的数据处理功能，反应用户对系统的需求，由一组数据流图和一组用例图组成</li></ul><h3 id="12-UML图"><a href="#12-UML图" class="headerlink" title="12.UML图"></a>12.UML图</h3><ul><li>案例图</li><li>类图</li><li>对象图</li><li>构件图</li><li>部署图</li><li>活动图</li><li>协作图</li><li>状态图</li><li>序列图</li></ul><h2 id="操作系统篇"><a href="#操作系统篇" class="headerlink" title="操作系统篇"></a>操作系统篇</h2><h3 id="1-操作系统的目标和功能"><a href="#1-操作系统的目标和功能" class="headerlink" title="1.操作系统的目标和功能"></a>1.操作系统的目标和功能</h3><ul><li>计算机资源的管理者<ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li>为用户提供使用计算机硬件系统的接口<ul><li>命令接口</li><li>程序接口</li><li>图形接口</li></ul></li><li>用作扩展机器</li></ul><h3 id="2-操作系统的运行机制"><a href="#2-操作系统的运行机制" class="headerlink" title="2.操作系统的运行机制"></a>2.操作系统的运行机制</h3><ol><li>内核程序和应用程序：<ul><li>内核（kernel）：内核是操作系统最重要最核心的部分，也是最接近硬件的部分。由许多内核程序组成。可以运行特权指令。<font color="orange">（I/O指令、置中断指令等等）</font></li><li>应用程序：运行于操作系统之上的程序。只能运行非特权指令。</li></ul></li><li>内核态与用户态：<ul><li>内核态：<ul><li>定义：处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令。</li><li>别名：核心态、管态</li></ul></li><li>用户态：<ul><li>定义：处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令。</li><li>别名：目态</li></ul></li><li>内核态与用户态的切换：CPU中有一个寄存器叫<font color="red">程序状态字寄存器（PSW）</font>，其中有个二进制位，1表示“内核态”，0表示“用户态”。<ul><li>内核态—&gt;用户态：执行一条<font color="red">特权指令——修改PSW</font>的标志位为“用户态”</li><li>用户态—&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。</li></ul></li></ul></li><li>内核内容：<ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ul></li></ol><h3 id="3-中断和异常"><a href="#3-中断和异常" class="headerlink" title="3.中断和异常"></a>3.中断和异常</h3><ol><li>中断的概念：在CPU上会运行两种程序，一种是<font color="red">应用程序</font>，一种是<font color="red">操作系统内核程序</font>。在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。而“中断”是让操作系统内核夺回CPU使用权的唯一途径。</li><li>中断的分类：<ul><li>内中断（异常）：<ul><li>定义：与当前执行的指令有关，中断信号来源于CPU内部</li><li>类型：<ul><li>陷阱、陷入（trap）：由陷入指令引发，是应用程序故意引发的</li><li>故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让他继续执行下去。<font color="orange">（缺页故障）</font></li><li>终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。<font color="orange">（整数除0、非法使用特权指令）</font></li></ul></li></ul></li><li>外中断（中断）：<ul><li>定义：与当前执行的指令无关，中断信号来自CPU外部</li><li>类型：<ul><li>时钟中断</li><li>I/O中断请求</li></ul></li></ul></li></ul></li><li>中断处理的过程：<ul><li>关中断：CPU响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU不应响应更高级中断源的中断请求。否则，若现场保存不完整，中断服务程序结束后，不能正确地恢复并继续执行现行程序。</li><li>保存断点：为保证中断服务程序执行完毕后能正确地回到原来的程序，必须将原来的程序的断点（程序计数器PC）保存起来。</li><li>中断服务程序寻址：取出中断服务程序的入口地址送入程序计数器PC。</li><li>保存现场和屏蔽字：进入中断服务程序后，首先要保存现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容。</li><li>开中断：允许更高级中断请求得到响应。</li><li>执行中断服务程序：中断请求的目的。</li><li>关中断：保证在恢复现场和屏蔽字时不被中断。</li><li>恢复现场和屏蔽字：将现场和屏蔽字恢复到原来的状态。</li><li>开中断，中断返回：中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</li></ul></li></ol><h3 id="4-操作系统的体系结构"><a href="#4-操作系统的体系结构" class="headerlink" title="4.操作系统的体系结构"></a>4.操作系统的体系结构</h3><ol><li>大内核：<ul><li>定义：将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而应用提高性能的系统服务。</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li><li>典型系统：Linux、Unix</li></ul></li><li>微内核：<ul><li>定义：将内核中最基本的功能保留在内核，将那些不需要在核心态执行的功能移到用户态执行。</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li><li>典型系统：Windows NT</li></ul></li></ol><h3 id="5-进程和线程"><a href="#5-进程和线程" class="headerlink" title="5.进程和线程"></a>5.进程和线程</h3><ol><li>进程的概念：进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li><li>线程的概念：操作系统能够进行运算调度的最小单位，包含在进程中，是进程中的实际运作单位</li><li>两者的区别：</li></ol><table><thead><tr><th align="center">变化</th><th align="center">进程</th><th align="center">线程</th></tr></thead><tbody><tr><td align="center">调度</td><td align="center">进程时用由资源和独立调度的基本单位</td><td align="center">线程是独立调度的基本单位，进程是资源分配的基本单位</td></tr><tr><td align="center">并发性</td><td align="center">只能进程间并发</td><td align="center">既能进程间并发，也可线程间并发</td></tr><tr><td align="center">系统开销</td><td align="center">进程间并发，需要切换进程的运行环境，系统开销大</td><td align="center">线程间并发，若为统一进程内线程切换，则不需切换进程环境，系统开销小</td></tr></tbody></table><h3 id="6-进程通信"><a href="#6-进程通信" class="headerlink" title="6.进程通信"></a>6.进程通信</h3><ol><li>进程通信的概念：进程之间的信息交换。</li><li>共享存储：在通信的进程之间存在一块可以直接访问的共享空间<font color="orange">（由操作系统提供）</font>，<font color="red">两个进程对共享空间的访问必须互斥<font color="orange">（互斥访问通过操作系统提供的工具实现）</font></font></li><li>管道通信：管道（pipe）是指用于连接读写进程的一个共享文件，其实就是在内存中开辟的一个大小固定的缓冲区，采用<font color="red">半双工通信</font>，各进程要互斥地访问管道，数据以<font color="red">字符流</font>的形式写入管道，如果没写满，就不允许读；如果没读空，就不允许写。</li><li>消息传递：进程见的数据交换以<font color="red">格式化的消息（Message）</font>为单位，通过操作系统提供的”发送消息/接受消息“两个原语进行数据交换</li></ol><h3 id="7-进程的状态与转换"><a href="#7-进程的状态与转换" class="headerlink" title="7.进程的状态与转换"></a>7.进程的状态与转换</h3><ol><li><p>五种状态：</p><ul><li>创建态（New）：<ul><li>定义：进程正在被创建</li><li>步骤：<ul><li>申请一个空白的PCB</li><li>向PCB中填写一些控制和管理进程的信息</li><li>由系统为该进程分配运行时所必须的资源</li><li>把该进程转入就绪态</li></ul></li></ul></li><li><font color=green>就绪态</font>（Ready）：<ul><li>定义：进程获得了除处理机外的一切所需资源。一旦得到处理机，便可立即运行。</li><li>注：系统中处于就绪态的进程可以有多个，通常把它们排成一个队列，称为就绪队列。</li></ul></li><li><font color=green>运行态</font>（Running）：<ul><li>定义：进程正在处理机上运行，CPU会执行该进程对应的程序<font color="orange">（执行指令序列）</font>。</li><li>注：在单核CPU环境下，每个时刻最多有一个进程处于运行态。</li></ul></li><li><font color=green>阻塞态</font>（Waiting/Blocked）：<ul><li>定义：进程正在等待某一事件而暂停运行。</li><li>注：即使处理机空闲，该进程也不能运行。</li></ul></li><li>终止态（Terminated）：<ul><li>定义：进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。</li><li>步骤：<ul><li>将该进程置为终止态</li><li>进程下CPU，并回收内存空间等资源</li><li>回收该进程的PCB</li></ul></li></ul></li></ul><p><font color="green">上述标绿的为3种基本状态</font></p></li><li><p>3种基本状态的转换：</p><ul><li>就绪态——&gt;运行态：处于就绪态的进程被调度后，获得处理机资源</li><li>运行态——&gt;就绪态：<ul><li>处于运行态的进程在时间片用完后，不得不让出处理机</li><li>在可剥夺的操作系统中，被更高优先级的进程抢占</li></ul></li><li>运行态——&gt;阻塞态：<ul><li>进程请求某一资源的使用和分配或等待某一事件的发生</li><li>注：此种转换是进程自身作出的<font color="red">主动行为</font>。</li></ul></li><li>阻塞态——&gt;就绪态：<ul><li>进程等待的事件到来</li><li>注：此种转换是<font color="red">被动行为</font>，需要其他相关进程的协助。</li></ul></li></ul><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="data:image/png;base64,666" alt="进程状态"></p></li></ol><h3 id="8-进程调度算法"><a href="#8-进程调度算法" class="headerlink" title="8.进程调度算法"></a>8.进程调度算法</h3><ol><li><p>先来先服务（FCFS）：算法规则：按照作业/进程到达的先后顺序进行服务</p></li><li><p>短作业优先（SJF）：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p></li><li><p>高响应比优先（HRRN）：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。</p><p>$$<br>响应比=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p></li><li><p>时间片轮转（RR）：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p></li><li><p>优先级调度：调度时选择优先级最高的作业/进程</p></li><li><p>多级反馈队列调度：</p><ul><li>设置多个就绪队列，各队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进若第一级队列，按FCFS原则排队等待被分配时间片；若使用完时间片进程还未结束，则进程进入下一级队列队尾。若此时已经在最下级队列，则重新放回该队列队尾。</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ul></li></ol><h3 id="9-同步和互斥"><a href="#9-同步和互斥" class="headerlink" title="9.同步和互斥"></a>9.同步和互斥</h3><ol><li>同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区</li><li>同步机制的四个准则：<ul><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul></li></ol><h3 id="10-死锁"><a href="#10-死锁" class="headerlink" title="10.死锁"></a>10.死锁</h3><ol><li><p>定义：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p></li><li><p>死锁产生的必要条件：<font color=red>必须同时满足下列四个条件</font></p><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>请求和保持条件：进程已经至少保持了至少一个资源，但又提除了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul></li><li><p>死锁的处理策略：</p><ul><li>预防死锁：破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁（资源分配图、资源剥夺法、撤销进程法、进程回退法）</li></ul></li><li><p>与饥饿和死循环的区别：</p></li></ol><table align="center">    <tr>        <th></th><th>共同点</th><th>区别</th>    </tr>    <tr>        <td>死锁</td><td rowspan="3">都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手中的资源”导致的，因此如果有死锁现象，那<font color=red>至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。</font></td>    </tr>    <tr>        <td>饥饿</td><td><font color=red>可能只有一个进程发生饥饿。</font>发生饥饿的进程既可能时阻塞态，也可能时就绪态。</td>    </tr>    <tr>        <td>死循环</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<font color=red>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题。</font></td>    </tr></table><ol start="5"><li>死锁定理：如果资源分配图是完全简化的，就没有死锁</li></ol><h3 id="11-银行家算法"><a href="#11-银行家算法" class="headerlink" title="11.银行家算法"></a>11.银行家算法</h3><ul><li>算法思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</li><li>数据结构：<ul><li>长度为m的一维数组Available：还有多少可用资源</li><li>n*m矩阵Max：各进程对资源的最大需求数</li><li>n*m矩阵Allocation：已经给各进程分配了多少资源</li><li>Max-Allocation=Need矩阵：各进程最多还需要多少资源</li><li>长度为m的一维数组Request：进程此次申请的各种资源数</li></ul></li><li>算法步骤：<ul><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ul></li><li>安全性算法步骤：<ul><li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</li><li>不断重复上述过程，看最终是否能让所有进程都加入安全序列</li></ul></li></ul><h3 id="12-存储器管理的功能"><a href="#12-存储器管理的功能" class="headerlink" title="12.存储器管理的功能"></a>12.存储器管理的功能</h3><ul><li>内存空间的分配与回收：实施内存的分配，回收系统或用户释放的内存空间</li><li>地址转换：逻辑地址转换为物理地址</li><li>内存空间的扩充：<ul><li>覆盖技术：把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位，把程序执行时并不要<br>求同时装入内存的覆盖组成一组</li><li>交换技术：把暂时不用的某个程序及数据部分从内存移到外存中去，以便腾出必要的内存空间；或者把指定<br>的程序或数据从外存读到相应的内存中，并将控制权交给它</li><li>虚拟内存技术</li></ul></li><li>存储保护：保证各进程在自己的内存空间内运行，不会越界访问</li></ul><h3 id="13-将用户程序变为可在内存中执行的程序的步骤"><a href="#13-将用户程序变为可在内存中执行的程序的步骤" class="headerlink" title="13.将用户程序变为可在内存中执行的程序的步骤"></a>13.将用户程序变为可在内存中执行的程序的步骤</h3><ol><li>编译：由编译程序将用户源代码编译程若干目标模块</li><li>链接：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块<ul><li>静态链接：在程序运行前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开</li><li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式</li><li>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。便于修改和更新，便于实现对目标模块的共享</li></ul></li><li>装入：由装入程序将装入模块装入内存运行<ul><li>绝对装入：编译时产生绝对地址</li><li>可重定位装入：装入时将逻辑地址转换为物理地址</li><li>动态运行时装入：运行时将逻辑地址转换为物理地址，需要设置重定位寄存器</li></ul></li></ol><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319111551753.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319111551753.png" srcset="data:image/png;base64,666" alt="image-20230319111551753"></p><h3 id="14-连续分配管理方式"><a href="#14-连续分配管理方式" class="headerlink" title="14.连续分配管理方式"></a>14.连续分配管理方式</h3><ol><li>单一连续分配：<ul><li>内存被分为系统区和用户区</li><li>特点：<ul><li>系统区通常处于内存的低地址部分，用于存放操作系统相关数据</li><li>用户区用于存放用户进程相关数据，内存中<font color=red>只能有一道用户程序</font>，用户程序独占整个用户区空间</li></ul></li><li>优点：<ul><li>实现简单</li><li>无外部碎片</li><li>可以采用覆盖技术扩充内存</li><li>不一定需要采取内存保护</li></ul></li><li>缺点：<ul><li>只能用于单用户、单任务的操作系统中</li><li>有内部碎片</li><li>存储器利用率极低</li></ul></li></ul></li><li>固定分区分配：<ul><li>将整个用户空间划分为若干个固定大小的分区</li><li>特点：<ul><li>在每个分区中直撞入一道作业</li><li>操作系统建立一个数据结构──分区说明表，包含分区号、大小、起始地址、状态（是否已分配）</li></ul></li><li>分类：<ul><li>分区大小相等：缺乏灵活性，但很适合用于一台计算机控制多个相同对象的场合</li><li>分区大小不等：增加了灵活性，可以满足不同大小的进程需求</li></ul></li><li>优点：<ul><li>实现简单</li><li>无外部碎片</li></ul></li><li>缺点：<ul><li>当用户程序太大时，可能所有的分区都不能满足需求，不得不采用覆盖技术解决，会降低性能</li><li>会产生内部碎片，内存利用率低</li></ul></li></ul></li><li>动态分区分配：<ul><li>不会预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区。</li><li>系统要用什么样的数据结构记录内存的使用情况？<ul><li>空闲分区表：每一个空闲分区对应一个表项，表项中包含分区号、分区大小、起始地址、状态等信息</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向和后向的指针。</li></ul></li><li>当有很多空闲分区都满足需求时，应该选择哪个分区进行分配？──动态分配算法<ul><li>首次适应算法（First Fit）：<ul><li>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</li><li>实现方法：空闲分区以地址递增的次序排列。每次分配时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>优点：综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排列。</li></ul></li><li>最佳适应算法（Best Fit）：<ul><li>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此尽可能保留大片的空闲区，优先使用更小的空闲区。</li><li>实现方法：空闲分区以容量递增的次序排列。每次分配时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>优点：会有更多的大分区被保留下来，更能满足大进程的需求。</li><li>缺点：每次都选最小的分区进行分配，会留下越来越多、很小的、难以利用的内存块，产生很多外碎片</li></ul></li><li>最坏适应算法（Worst Fit）：<ul><li>算法思想：为了解决最佳适应算法留下太多外部碎片的问题，优先使用最大的连续区。</li><li>实现方法：空闲分区以容量递减的次序排列。每次分配时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>可以减少难以利用的外碎片</li><li>缺点：每次都选最小=大的分区进行分配，会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有空间可以使用了</li></ul></li><li>邻近适应算法（Next Fit）：<ul><li>算法思想：每次都从上次查找结束的位置开始检索。</li><li>实现方法：空闲分区以地址递增的次序排列（可排成一个循环链表）。每次分配时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>优点：不用每次都从低地址的小分区开始检索，算法开销小。</li><li>缺点：会使高地址的大分区也被用完。</li></ul></li></ul></li><li>如何进行分区的分配与回收？──更新空闲分区表/空闲分区链</li></ul></li></ol><h3 id="15-基本分页和请求分页"><a href="#15-基本分页和请求分页" class="headerlink" title="15.基本分页和请求分页"></a>15.基本分页和请求分页</h3><ol><li><p>基本分页存储管理方式：</p><ul><li><p>将内存空间分为一个个大小相等的分区，每个分区就是一个“页框”（页帧=内存快=物理块=物理页=实页=块）。每个页框都有一个编号，即“页框号”，页框号<font color=red>从0开始</font>。</p></li><li><p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页面”（页=逻辑页=虚页）。每个页面页有一个编号，即“页号”，页号也是<font color=red>从0开始的</font>。</p></li><li><p>操作系统<font color=red>以页框为单位为各个进程分配内存空间</font>。进程的每个页面分别放入一个页框中，<font color=red>进程的页面与内存的页框由一一对应的关系</font>。</p></li><li><p>页表：</p><ul><li>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表</li><li>一个进程对应一张页表</li><li>进程的每个页面对应一个页表项</li><li>每个页表项由“页号”和“块号”组成</li><li>页表记录进程页面和实际存放的页框之间的映射关系</li><li>每个页表项的长度是相同的</li></ul></li><li><p>每个页表项占多少字节？</p><ul><li>寻找内存块大小（内存块大小=页面大小）</li><li>计算内存块数</li><li>找寻内存块号的范围</li><li>计算内存块号至少需要多少bit表示</li><li>计算内存块号至少需要多少字节表示(xB)</li><li>由于页号时隐含的，因此每个页表项占xB，存储整个页表至少需要x*nB</li></ul></li><li><p>如何实现地址的转换：（若要访问逻辑地址A）</p><ul><li>确定逻辑地址A对应的页号P<br>$$<br>页号=逻辑地址/页面长度<br>$$</li></ul></li><li><p>找到P号页面在内存中的起始地址（查页表）</p></li><li><p>确定逻辑地址A的“页内偏移量”W<br>$$<br>页内偏移量=逻辑地址%页面长度<br>$$</p><ul><li>逻辑地址A的物理地址=P号页面在内存中的起始地址+页内偏移量W</li></ul></li><li><p>页面大小取2的整数幂：</p><ul><li>逻辑地址的拆分更加迅速：如果每个页面大小为2^k B，用二进制表示逻辑地址，则末尾k位即为页内偏移量，其余部分就是页号。</li><li>物理地址的计算更加迅速：根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的存放号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li></ul></li><li><p>逻辑地址结构：页号+页内偏移量</p><ul><li>如果由K位表示页内偏移量，则说明该系统中一个页面的大小是2^K个内存单元</li><li>如果由M位表示页号，则说明在该系统中，一个进程最多允许有2^M个页面</li></ul></li><li><p>基本地址变换机构：</p><ul><li>页表寄存器（PTR）：存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块PCB中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li><li>变换过程：<ul><li>根据逻辑地址计算页号P和页内偏移量W</li><li>比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行</li><li>页表中的页号P对应的<font color=red>页表项地址=页表起始地址F+页号P*页表项长度</font>，取出该页表项内容b，即为内存块号。<ul><li>页表长度：页表中总共有几个页表项</li><li>页表项长度：每个页表项占多大的存储空间</li><li>页面大小：一个页面占多大的存储空间</li></ul></li><li>计算E=b*L+W，用得到的物理地址E去访存。</li></ul></li><li>为了页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装下整数个页表项。</li></ul></li><li><p>具有快表的地址变换机构：</p><ul><li>快表（TLB）：联想寄存器，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，加速地址变换的速度。</li><li>过程：<ul><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<font color=red>若快表命中，则访问某个逻辑地址仅需一次访存即可</font>。</li><li>如果没有找到匹配的页号，则访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<font color=red>若快表未命中，则访问某个逻辑地址需要两次访存</font>。</li></ul></li><li>若快表和慢表同时查询，则计算快表未命中时不需要加上查询快表的时间。</li><li>局部性原理：<ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。</li><li>基于此，一般快表命中率可达90%以上</li></ul></li></ul></li><li><p>两级页表：</p><ul><li>单级页表的问题：<ul><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</li></ul></li><li>两级页表的原理和地址结构：<ul><li>将原本长长的页表分为两部分，新建页目录表（外层页表/顶级页表）</li><li>地址分为三部分：一级页号、二级页号和页内偏移量</li></ul></li><li>地址变换：<ul><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中存放位置</li><li>根据二级页号查表，找到最终想访问的内存块号</li><li>结合页内偏移量的到物理地址</li></ul></li><li>注：<ul><li>若采用多级页表机制，<font color=red>各级页表的大小不能超过一个页面</font></li><li>x级页表访存次数需要x+1次（没有快表机构）</li></ul></li></ul></li></ul></li><li><p>请求分页管理方式</p><ul><li><p>页表机制：页号+内存块号+状态位+访问字段+修改位+外存地址</p><ul><li><p>状态位：是否已调入内存</p></li><li><p>访问字段：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</p></li><li><p>修改位：页面调入内存后是否被修改过</p></li><li><p>外存地址：页面在外存中的存放位置</p></li></ul></li><li><p>缺页中断机构：</p><ul><li><p>请求分页系统中，每当访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时<font color=red>缺页的进程阻塞</font>，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列。</p></li><li><p>如果内存中有空闲块，则为进程分配一个空闲块，将所却页面装入该块，并修改页表中相应的页表项。</p></li><li><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间<font color=red>被修改过</font>，则要将其<font color=red>写回外存</font>。未修改过的页面不用写回外存</p></li><li><p><font color=red>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</font><font color=orange>（故障）</font></p></li></ul></li><li><p>地址变换机构：</p><ul><li><p>流程图：</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/fenye.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/fenye.png" srcset="data:image/png;base64,666" alt="请求分页地址变换"></p></li></ul></li></ul></li></ol><pre><code> - 注：   - 快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除。   - 只有“写指令”才需要修改“修改位”。并且，一般来说&lt;font color=red&gt;只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表&lt;/font&gt;。这样可以减少访问次数。   - 和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。   - 需要用某种“页面置换算法”来决定一个换出页面   - 换入/换出页面都需要启动慢速的I/O操作，如果操作太频繁，会有很大的开销   - 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</code></pre><h3 id="16-页面置换算法"><a href="#16-页面置换算法" class="headerlink" title="16.页面置换算法"></a>16.页面置换算法</h3><ol><li><p>最佳置换算法（OPT）：</p><ul><li>思想：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面</li><li>注：实际上最佳置换算法时无法实现的</li></ul></li><li><p>先进先出置换算法（FIFO）：</p><ul><li>思想：每次选择淘汰的页面是最早进入内存的页面</li><li>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。<font color=orange>（队列的最大长度取决于系统为进程分配了多少个内存块）</font></li></ul></li><li><p>最近最久未使用置换算法（LRU）：</p><ul><li>思想：每次淘汰的页面时最近最久未使用的页面</li><li>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值最大的。</li></ul></li><li><p>时钟置换算法（CLOCK）：</p><ul><li><p>简单的时钟淘汰算法（CLOCK）：</p><ul><li>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。<font color=orange>（最多会经过两轮扫描）</font></li></ul></li><li><p>改进的时钟淘汰算法──最近未用算法（NRU）：</p><ul><li><p>实现方法：用（访问位，修改位）一起判断页面状态。将所有可能被置换的页面排成一个循环队列，执行下列操作：</p><ul><li>第一轮：从当前位置开始扫描第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位。</li><li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0.</li><li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位。</li><li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。</li></ul><p><font color=orange>最多会进行四轮扫描</font></p></li></ul></li></ul></li></ol><h3 id="17-页表与快表"><a href="#17-页表与快表" class="headerlink" title="17.页表与快表"></a>17.页表与快表</h3><ol><li>页表：指出逻辑地址中的页号与所占主存块号的对应关系</li><li>快表：放在高速缓冲寄存器的部分页表</li></ol><h3 id="18-地址翻译过程"><a href="#18-地址翻译过程" class="headerlink" title="18.地址翻译过程"></a>18.地址翻译过程</h3><p>​    TLB——&gt;页表（TLB未命中）——&gt;Cache——&gt;主存（Cache未命中）——&gt;外存</p><h3 id="19-文件的基本操作"><a href="#19-文件的基本操作" class="headerlink" title="19. 文件的基本操作"></a>19. 文件的基本操作</h3><ul><li>创建文件</li><li>写文件</li><li>读文件</li><li>文件重定位（文件寻址）</li><li>删除文件</li><li>截断文件</li></ul><h3 id="20-磁盘调度算法"><a href="#20-磁盘调度算法" class="headerlink" title="20. 磁盘调度算法"></a>20. 磁盘调度算法</h3><ol><li><p>先来先服务算法（FCFS）</p><pre><code>根据进程请求访问磁盘的先后次序进行调度，公平、简单，不会出现某一进程的请求长期得不到满足的情况，但平均寻道时间可能较长</code></pre></li><li><p>最短寻道时间优先算法（SSTF） </p><p>​    该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，可能导致饥饿</p></li><li><p>扫描算法（SCAN）电梯调度<br>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向，避免了饥饿现象的出现</p></li><li><p>循环扫描算法（CSCAN）<br>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，立即返回到另一端</p></li></ol><h3 id="21-I-O控制方式"><a href="#21-I-O控制方式" class="headerlink" title="21. I/O控制方式"></a>21. I/O控制方式</h3><ul><li>程序I/O方式</li></ul><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319113357387.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319113357387.png" srcset="data:image/png;base64,666" alt="image-20230319113357387"></p><ul><li>中断驱动方式</li></ul><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319113401584.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319113401584.png" srcset="data:image/png;base64,666" alt="image-20230319113401584"></p><ul><li>DMA方式</li></ul><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319113429382.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/image-20230319113429382.png" srcset="data:image/png;base64,666" alt="image-20230319113438117"></p><h3 id="22-文件存储的方式有哪些"><a href="#22-文件存储的方式有哪些" class="headerlink" title="22. 文件存储的方式有哪些"></a>22. 文件存储的方式有哪些</h3><ul><li>连续分配：每个文件在磁盘上占有一组连续的块</li><li>链接分配：<ul><li>隐式链接：目录项中含有文件第一块和最后一块的指针，每个文件对应一个磁盘块的链表；除最后一个盘块外，每个盘块都含有指向文件下一盘块的指针</li><li>显式链接：把各物理块的指针提取出来，显示的存放在内存的一张链接表中，称为文件分配表FAT</li></ul></li><li>索引分配：将每个文件所有的盘块号都集中放在一起构成索引表</li></ul><h1 id="计算机网络篇"><a href="#计算机网络篇" class="headerlink" title="计算机网络篇"></a>计算机网络篇</h1><h3 id="1-计算机网络的功能"><a href="#1-计算机网络的功能" class="headerlink" title="1.计算机网络的功能"></a>1.计算机网络的功能</h3><ul><li>数据通信：实现联网计算机之间各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。</li><li>资源共享：同一个计算机上的其他计算机可使用某台计算机的计算机资源的行为，可共享硬件、软件和数据。</li><li>分布式处理：多台计算机各自承担同一工作任务的不同部分。</li><li>提高可靠性：计算机网络中的各台计算机可以通过网络互为替代机。</li><li>负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。</li></ul><h3 id="2-主机间的通讯方式"><a href="#2-主机间的通讯方式" class="headerlink" title="2.主机间的通讯方式"></a>2.主机间的通讯方式</h3><ul><li>客户-服务器（C/S）</li><li>对等（P2P）</li></ul><h3 id="3-计算机网络性能指标"><a href="#3-计算机网络性能指标" class="headerlink" title="3. 计算机网络性能指标"></a>3. 计算机网络性能指标</h3><ol><li><p>速率：</p><ul><li><p>定义：连接在计算机网络上的主机在数字信道上传送数据位数的速率。</p></li><li><p>单位：<br>$$<br>1Tb/s=10^3Gb/s=10^6Mb/s=10^9kb/s=10^{12}b/s<br>$$</p></li></ul></li><li><p>带宽：</p><ul><li>通信定义：某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</li><li>网络定义：表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。</li><li>单位：同上</li><li>实质：主机发送数据的最高速率</li></ul></li><li><p>吞吐量：</p><ul><li>定义：表示在单位时间内通过某个网络（或信道、接口）的数据量。</li><li>单位：同上</li><li>注：吞吐量受网络的带宽或网络的额定速率的限制  </li></ul></li><li><p>时延：</p><ul><li><p>定义：指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫延迟或迟延。</p></li><li><p>单位：s</p></li><li><p>分类：</p><ul><li><p>发送时延（传输时延）：</p><ul><li><p>定义：结点将分组的所有比特推向链路所需要的时间。</p></li><li><p>公式：<br>$$<br>发送时延=\frac{分组长度}{信道带宽}<br>$$</p></li></ul></li><li><p>传播时延：</p><ul><li><p>定义：电磁波在信道中传播一定的举例花费的时间。</p></li><li><p>公式：<br>$$<br>传播时延=\frac{信道长度}{电磁波在信道上的传播速率}<br>$$</p></li></ul></li><li><p>排队时延：等待输出/输入链路可用的时间。</p></li><li><p>处理时延：数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。</p></li></ul></li><li><p>注：</p><ul><li>一般情况下，排队时延和处理时延可以忽略不计。</li><li>高速链路，实际是提高数据发送速率，所以仅会减小发送时延；并不改变电磁波传播速率，故传播时延没有变化。</li></ul></li></ul></li><li><p>时延带宽积：</p><ul><li><p>定义：指发送段发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，又称以比特为单位的链路长度。</p></li><li><p>单位：bit</p></li><li><p>公式：<br>$$<br>时延带宽积=传播时延\times信道带宽<br>$$</p></li><li><p>实质：某段链路的比特容量</p></li></ul></li><li><p>往返时延RTT：</p><ul><li>定义：从发送方发送数据开始<font color="orange">（第一个bit到信道上）</font>，到发送方收到接受方的确认<font color="orange">（发送方收到对于第一个bit的确认信息）</font>（接受方收到数据后立即发送确认），总共经历的时延。</li><li>RTT越大，在收到确认前，可以发送的数据越多。</li><li>包括：<ul><li>往返传播时延：两倍的传播时延</li><li>末端处理时间</li></ul></li></ul></li><li><p>利用率：</p><ul><li><p>分类：</p><ul><li><p>信道利用率：</p><ul><li><p>定义：指出某一信道有百分之多少的时间是有数据通过的。</p></li><li><p>公式：<br>$$<br>信道利用率=\frac{有数据通过的时间}{（有+无）数据通过的时间}<br>$$</p></li></ul></li><li><p>网络利用率：信道利用率加权求平均值。</p></li></ul></li></ul></li></ol><h3 id="4-计算机网络提供的服务"><a href="#4-计算机网络提供的服务" class="headerlink" title="4. 计算机网络提供的服务"></a>4. 计算机网络提供的服务</h3><ul><li>面向连接与无连接服务<ul><li>面向连接：<ul><li>连接建立</li><li>数据传输</li><li>连接释放</li></ul></li><li>无连接服务：双方不需要先建立连接，不可靠，尽最大努力交付</li></ul></li><li>可靠服务与不可靠服务<ul><li>可靠服务：具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地</li><li>不可靠服务：尽量正确、可靠地传送</li></ul></li><li>有应答服务和无应答服务<ul><li>有应答服务：接收方在收到数据后向发送方给出相应的应答</li><li>无应答服务：接收方收到数据后不自动给出应答，如需应答，则由高层实现</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库篇&quot;&gt;&lt;a href=&quot;#数据库篇&quot; class=&quot;headerlink&quot; title=&quot;数据库篇&quot;&gt;&lt;/a&gt;数据库篇&lt;/h1&gt;&lt;h3 id=&quot;1-如何理解数据库系统的三层模式结构？&quot;&gt;&lt;a href=&quot;#1-如何理解数据库系统的三层模式结构？&quot; class</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="专业课" scheme="https://www.oliverbryant.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>DataBase</title>
    <link href="https://www.oliverbryant.cn/2023/03/17/DataBase/"/>
    <id>https://www.oliverbryant.cn/2023/03/17/DataBase/</id>
    <published>2023-03-17T08:10:30.000Z</published>
    <updated>2023-03-18T07:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-如何理解数据库系统的三层模式结构？"><a href="#1-如何理解数据库系统的三层模式结构？" class="headerlink" title="1.如何理解数据库系统的三层模式结构？"></a>1.如何理解数据库系统的三层模式结构？</h2><p>​    三层模式结构分别为外模式、模式和内模式</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/1654684980985_333333333333.jpg" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/1654684980985_333333333333.jpg" srcset="data:image/png;base64,666" alt="image"></p><ul><li>模式：又称逻辑模式，是对数据库中全部数据的逻辑结构和特性的描述，是数据库所有用户的公共数据视图。它处于三级结构的中间层，是整个数据库实际存储的抽象表示。DBMS提供模式描述语言（模式DDL）来严格定义模式</li><li>外模式：又称用户模式或子模式，通常是模式的子集，是数据库系统每个用户看到和使用的数据视图，即与某一应用有关的数据的逻辑表示。DBMS提供子模式描述语言（子模式DDL）来定义子模式</li><li>内模式：又称存储模式，是数据库所有数据的内部表示或者说是底层的描述，用来定义数据的存储方式和物理结构。DBMS提供内模式描述语言（内模式DDL）来定义内模式</li></ul><p>​    三层模式结构的优点：</p><ul><li>保证数据的独立性</li><li>有利于数据共享</li><li>简化了用户接口</li><li>利于数据的安全保密</li></ul><h2 id="2-什么是数据E-R图"><a href="#2-什么是数据E-R图" class="headerlink" title="2.什么是数据E-R图"></a>2.什么是数据E-R图</h2><p>​    E-R图是实体-联系模型，用以描述现实世界的概念模型，应用于数据库设计的概念模型设计</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/images%20%281%29.jpg" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/images%20%281%29.jpg" srcset="data:image/png;base64,666" alt="image"></p><p>​    E-R模型主要的元素是：实体集、属性、联系集</p><ul><li>实体集：方框表示，内部标注实体的命名。</li><li>属性：椭圆框或圆角矩阵表示，内部表明属性名，通过实线与实体集相连（某些联系也有属性）</li><li>联系集：用菱形框表示，内部标明联系的命名，并用实线分别与有关的实体集相连，同时在实线旁标注联系的类型（1对1、1对n、m对n）</li></ul><h2 id="3-数据库基本逻辑运算"><a href="#3-数据库基本逻辑运算" class="headerlink" title="3.数据库基本逻辑运算"></a>3.数据库基本逻辑运算</h2><p>​    关系代数用到的运算符包括四类：集合运算符、专门的关系运算符、算术比较运算符和逻辑运算符</p><ul><li>集合运算符：<ul><li>交</li><li>并</li><li>差</li><li>笛卡尔积</li></ul></li><li>专门的关系运算符：<ul><li>选择</li><li>投影</li><li>链接</li><li>除</li></ul></li><li>比较运算符：<ul><li>大于</li><li>大于等于</li><li>小于</li><li>小于等于</li><li>等于</li><li>不等于</li></ul></li><li>逻辑运算符：<ul><li>非</li><li>与</li><li>或</li></ul></li></ul><h2 id="4-数据库管理系统（DBMS）的定义及其功能功能"><a href="#4-数据库管理系统（DBMS）的定义及其功能功能" class="headerlink" title="4.数据库管理系统（DBMS）的定义及其功能功能"></a>4.数据库管理系统（DBMS）的定义及其功能功能</h2><ul><li><p>定义：是位于用户与操作系统之间的一层数据管理软件，是数据库系统（DBS）的核心，有一组程序构成，主要功能如下：</p><ul><li>数据定义功能</li><li>数据操纵功能</li><li>数据库的运行管理功能</li><li>数据库的建立和维护功能</li></ul></li></ul><h2 id="5-数据库系统是什么？"><a href="#5-数据库系统是什么？" class="headerlink" title="5.数据库系统是什么？"></a>5.数据库系统是什么？</h2><p>​    数据库系统就是基于数据库的计算机应用系统，由4部分组成：</p><ul><li>数据库：数据的汇集，以一定的组织形式保存在存储介质上</li><li>数据库管理系统：管理数据库的系统软件，可以实现数据库系统的各种功能</li><li>应用程序：以数据库管理系统和数据库中的数据为基础的程序</li><li>用户：<ul><li>应用程序开发人员</li><li>系统管理员</li><li>最终用户</li></ul></li></ul><h2 id="6-什么是数据库定义语言和数据操作语言？"><a href="#6-什么是数据库定义语言和数据操作语言？" class="headerlink" title="6.什么是数据库定义语言和数据操作语言？"></a>6.什么是数据库定义语言和数据操作语言？</h2><ul><li>数据库定义语言DDL：用于描述或定义实体，例如CREATE、ALTER、DROP等</li><li>数据操作语言DML：用于增删改查的操作，例如SELECT、UPDATE、DELETE等</li></ul><h2 id="7-数据库设计步骤"><a href="#7-数据库设计步骤" class="headerlink" title="7.数据库设计步骤"></a>7.数据库设计步骤</h2><ol><li>需求分析<ul><li>调查分析用户的活动</li><li>收集和分析需求数据并确定系统边界</li><li>编写需求分析说明书</li></ul></li><li>概念结构设计：E-R模型</li><li>逻辑结构设计：先将E-R图转换为关系模型，然后根据具体DBMS的特点和限制转换为特定的DBMS支持的数据模型，最后进行优化</li><li>数据库物理设计<ul><li>确定数据库的物理结构，在关系数据库中主要指存取方法（索引方法（B+树）、聚簇方法、Hash方法）和存取结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ul></li><li>数据库实施<ul><li>用DDL定义数据库结构</li><li>组织数据入库（数据装载）</li><li>编制与调试应用程序</li><li>数据库试运行</li></ul></li><li>数据库运行和维护<ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析、改造</li><li>数据库的重组与重构造</li></ul></li></ol><h2 id="8-数据库事务的四个特性"><a href="#8-数据库事务的四个特性" class="headerlink" title="8.数据库事务的四个特性"></a>8.数据库事务的四个特性</h2><ul><li>原子性：若把一个事务看作一个程序，它要么完整地被执行，要么完全不执行</li><li>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>隔离性：当多个事务<B>并发</b>执行时，系统应保证一个事务的执行结果不受其他事务的干扰，事务并发执行结果与这些事务串行执行是的结果是一样的</li><li>持久性：一个事务一旦成功完成全部操作，则它对数据库的所有更新就永远地反映在数据库中，即使以后系统发生了故障</li></ul><h2 id="9-数据库日志文件及其作用"><a href="#9-数据库日志文件及其作用" class="headerlink" title="9. 数据库日志文件及其作用"></a>9. 数据库日志文件及其作用</h2><p>​    日志文件是用来记录事务对数据库的更新操作的文件，主要有两种格式：以记录为单位的日志文件和以数据块为单位的日志文件</p><p>​    作用：事务故障恢复和系统故障恢复并协助后备副本进行介质故障恢复</p><h2 id="10-数据库故障及其修复"><a href="#10-数据库故障及其修复" class="headerlink" title="10.数据库故障及其修复"></a>10.数据库故障及其修复</h2><ul><li>事务故障<ul><li>定义：违反某些完整性规则、出现运算溢出、应用程序发生错误等</li><li>措施：反向阅读日志文件，找出该事务的所有更新操作，对每个操作进行逆操作</li></ul></li><li>系统故障<ul><li>定义：由于某些原因，造成系统停止运行，丢失了系统缓冲区的数据</li><li>措施：<ul><li>根据日志文件建立重做队列和撤销队列</li><li>对各自队列中的事务进行处理</li></ul></li></ul></li><li>介质故障<ul><li>定义：系统运行过程中，存储在外存上的数据部分损失或完全损失</li><li>措施：<ul><li>重装存储的数据库副本，是数据库恢复到转储时的一致状态</li><li>从第一个让日志文件开始装入，找到需要重做的事务，逐一REDO</li></ul></li></ul></li></ul><h2 id="11-并发控制"><a href="#11-并发控制" class="headerlink" title="11.并发控制"></a>11.并发控制</h2><ul><li>并发带来的问题：<ul><li>丢失修改</li><li>不可重复读（包括幻影）</li><li>读脏数据</li></ul></li><li>解决方法：<ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li></ul></li></ul><h2 id="12-封锁"><a href="#12-封锁" class="headerlink" title="12.封锁"></a>12.封锁</h2><ol><li>封锁类型：<ul><li>排它锁（X锁）：又称写锁，事务T对数据对象A加了X锁，T可以对A进行读和更新，期间其他事务不能对A加任何锁</li><li>共享锁（S锁）：又称读锁，事务T对数据对象A加了S锁，T可以对A进行读取操作，但不能进行更新，期间其他事务能对A加S锁，但不能加X锁</li></ul></li><li>封锁协议：<ul><li>三级封锁协议：<ul><li>一级：事务T在修改数据R之前必须对其加X锁，直到事务结束释放（解决丢失修改）</li><li>二级：一级封锁协议加上事务T在读取数据R之前必须对其加S锁，读完即可释放S锁（解决读脏数据）</li><li>三级：一级封锁协议加上事务T在读取数据R之前必须对其加S锁，直到事务结束释放（解决不可重复读）</li></ul></li><li>两段封锁协议<ul><li>将每个事务的执行分为两个阶段：加锁阶段和解锁阶段</li><li>事务开始后就处于加锁阶段，一直执行到ROLLBACK和COMMIT之前都是，而ROLLBACK和COMMIT使事务进入解锁阶段</li></ul></li></ul></li><li>封锁粒度：封锁对象的大小，可以是数据库、表、元组、属性</li></ol><h2 id="13-数据库存储的过程"><a href="#13-数据库存储的过程" class="headerlink" title="13.数据库存储的过程"></a>13.数据库存储的过程</h2><p>​    在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程中的名字并给出参数来执行</p><h2 id="14-数据的预处理"><a href="#14-数据的预处理" class="headerlink" title="14.数据的预处理"></a>14.数据的预处理</h2><p>​    在主要的处理以前对数据进行一些处理，以利于计算机的运算</p><ul><li>数据清理</li><li>数据集成</li><li>数据变换</li><li>数据归约</li></ul><h2 id="15-数据库的连接方式"><a href="#15-数据库的连接方式" class="headerlink" title="15.数据库的连接方式"></a>15.数据库的连接方式</h2><ul><li>等值连接与非等值连接：=</li><li>自身链接：将一个表与其自身链接</li><li>外连接：A中某个元组t，由于在B中没有任何一个元组满足与t的连接条件，因此t不会出现在A和B的连接结果中<ul><li>左外连接：先按照连接条件对表做条件连接，若A的某个元组t没有出现在结果中，则将t和B中的一个万能元组做链接，这个元组在所有列上取空值</li><li>右外连接：先按照连接条件对表做条件连接，若B的某个元组t没有出现在结果中，则将t和A中的一个万能元组做链接，这个元组在所有列上取空值</li><li>全外连接：上述两者的并</li></ul></li></ul><h2 id="16-数据定义"><a href="#16-数据定义" class="headerlink" title="16.数据定义"></a>16.数据定义</h2><ul><li><p>表：可以由一个或多个属性（列）组成，建表同时可以定义与该表有关的完整性约束条件。</p></li><li><p>索引：一个独立的、物理的数据库结构，基于表的一列或多列建立，按列值从小到大排序，索引往往被组织成一棵B+树</p><ul><li>分类：<ul><li>唯一索引与非唯一索引：相当于加了一个UNIQUE约束</li><li>聚簇索引和非聚簇索引：前者要求表中的元组的存放次序和索引中索引项的存放次序完全相同，也可以理解为表中的元组的也是有序的</li></ul></li></ul><p>索引是否越多越好：否。建立索引也需要空间，维护索引耗费性能</p></li><li><p>视图：从一个或多个表中导出的表，可以像对表一样进行查询。视图是一个虚表，数据库中只存储视图的定义，不存储视图的数据。</p><p>作用：</p><ul><li>简化用户操作</li><li>减少冗余数据</li><li>对重构数据库提供了一定程度的逻辑独立性</li><li>对机密数据提供安全保护</li></ul></li></ul><h2 id="17-候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结"><a href="#17-候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结" class="headerlink" title="17.候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结"></a>17.候选码、主码、全码、外码、主属性、主键、主关键字、非主属性清晰总结</h2><p>（引用自<a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446%EF%BC%89">https://blog.csdn.net/sumaliqinghua/article/details/85872446）</a></p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/20190625173457198.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/DataBase/20190625173457198.png" srcset="data:image/png;base64,666" alt="码的关系"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-如何理解数据库系统的三层模式结构？&quot;&gt;&lt;a href=&quot;#1-如何理解数据库系统的三层模式结构？&quot; class=&quot;headerlink&quot; title=&quot;1.如何理解数据库系统的三层模式结构？&quot;&gt;&lt;/a&gt;1.如何理解数据库系统的三层模式结构？&lt;/h2&gt;&lt;p&gt;​ </summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="专业课" scheme="https://www.oliverbryant.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.oliverbryant.cn/2023/03/10/hello-world/"/>
    <id>https://www.oliverbryant.cn/2023/03/10/hello-world/</id>
    <published>2023-03-10T08:09:21.160Z</published>
    <updated>2021-07-01T09:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Software_Engineering</title>
    <link href="https://www.oliverbryant.cn/2021/06/30/Software-Engineering/"/>
    <id>https://www.oliverbryant.cn/2021/06/30/Software-Engineering/</id>
    <published>2021-06-30T11:59:06.000Z</published>
    <updated>2023-03-18T11:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="1-What-is-Software-Engineering"><a href="#1-What-is-Software-Engineering" class="headerlink" title="1. What is Software Engineering?"></a>1. What is Software Engineering?</h3><p>​    Software engineers use their knowledge of computers and computing to help solve problems.Software engineers use techniques, tools, procedures, and paradigms to enhance the quality of their software products. Their aim is to use efficient and productive approaches to generate effective solutions to problems. Instead of investigating hardware design or proving theorems about how algorithms work, a software engineer focuses on the computer as a problem-solving tools.</p><h3 id="2-What-is-good-software"><a href="#2-What-is-good-software" class="headerlink" title="2. What is good software?"></a>2. What is good software?</h3><p>​    Good software engineering must always include a strategy for producing quality software. But before we can devise a strategy, we must understand what we mean by quality software.</p><ol><li>The quality of the product.</li><li>The quality of the process.</li><li>Quality in the context of the business environment.</li></ol><h3 id="3-What-are-9-activities-in-software-development"><a href="#3-What-are-9-activities-in-software-development" class="headerlink" title="3. What are 9 activities in software development?"></a>3. What are 9 activities in software development?</h3><ol><li>requirements analysis and definition</li><li>system design</li><li>program design</li><li>writing the programs (program implementation)</li><li>unit testing</li><li>integration testing</li><li>system testing</li><li>system delivery</li><li>maintenance</li></ol><h3 id="4-How-has-software-engineering-changed"><a href="#4-How-has-software-engineering-changed" class="headerlink" title="4. How has software engineering changed?"></a>4. How has software engineering changed?</h3><ol><li>criticality of time-to-market for commercial products</li><li>shifts in economics of computing: lower HW, higher development/maintenance costs</li><li>availability of powerful desktop computing</li><li>extensive local- and wide-area networking</li><li>availability and adoption of OO technology</li><li>graphical user interfaces</li><li>unpredictability of waterfall model of development</li></ol><h3 id="5-What-is-the-Wasserman’s-discipline-of-software-engineering"><a href="#5-What-is-the-Wasserman’s-discipline-of-software-engineering" class="headerlink" title="5. What is the Wasserman’s discipline of software engineering?"></a>5. What is the Wasserman’s discipline of software engineering?</h3><ol><li>abstraction</li><li>analysis and design methods and notations</li><li>user interface prototyping</li><li>software architecture</li><li>software process</li><li>reuse</li><li>measurement</li><li>tools and integrated environments</li></ol><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h3 id="1-What-are-the-drawbacks-of-the-Waterfall-model"><a href="#1-What-are-the-drawbacks-of-the-Waterfall-model" class="headerlink" title="1. What are the drawbacks of the Waterfall model?"></a>1. What are the drawbacks of the Waterfall model?</h3><ol><li>The model provides no guidance to managers and developers on how to handle changes to products and activities that are likely to occur during development.</li><li>It does not treat software as a problem-solving process. It was derived from a manufacturing view of software development. Software is a creation process, not a manufacturing process. Creation usually involves trying a little of this or that, developing and evaluating prototypes, assessing the feasibility or requirements, contrasting several designs, learning from failure, and eventually setting on a satisfactory solution to the problem at hand.</li><li>The biggest problem with the waterfall model is that it does not reflect the way code is really developed.</li></ol><h3 id="2-What-are-the-benefits-of-the-Incremental-Model-and-Iterative-Model"><a href="#2-What-are-the-benefits-of-the-Incremental-Model-and-Iterative-Model" class="headerlink" title="2. What are the benefits of the Incremental Model and Iterative Model?"></a>2. What are the benefits of the Incremental Model and Iterative Model?</h3><ol><li>Training can begin on an early release, even if some functions are missing.</li><li>Markets can be created early for functionality that has never before been offered.</li><li>Frequent releases allow developers to fix unanticipated problems globally and quickly, as they are reported from the operational system.</li><li>The development team can focus on different areas of expertise with different releases.</li></ol><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="1-Describe-the-process-of-determining-requirements"><a href="#1-Describe-the-process-of-determining-requirements" class="headerlink" title="1. Describe the process of determining requirements."></a>1. Describe the process of determining requirements.</h3><ol><li>Elicitation: Collecting the user’s requirements.</li><li>Analysis: Understanding and modeling the desired behavior.</li><li>Specification: Documenting the behavior of the proposed software system.</li><li>Validation: Checking that our specification matches the user’s requirements.</li></ol><h3 id="2-It-is-usually-helpful-to-separate-the-requirements-into-three-categories-What-are-these-three-categories-Explain-why-it-is-helpful"><a href="#2-It-is-usually-helpful-to-separate-the-requirements-into-three-categories-What-are-these-three-categories-Explain-why-it-is-helpful" class="headerlink" title="2. It is usually helpful to separate the requirements into three categories. What are these three categories? Explain why it is helpful."></a>2. It is usually helpful to separate the requirements into three categories. What are these three categories? Explain why it is helpful.</h3><ol><li>Three categories are:<ul><li>Requirements that absolutely must be met.</li><li>Requirements that are highly desirable but not necessary.</li><li>Requirements that are possible but could be eliminated.</li></ul></li><li>Reasons: The analysis of requirements by category is helpful to all parties in understanding what is really needed. It is also useful when a software development project is constrained by time or resources; if the system as defined will cost too much or take too long to develop, category 3 requirements can be dropped and category 2 requirements can be analyzed for elimination or postponement.</li></ol><h3 id="3-What-is-a-requirements-definition-document-What-is-a-requirements-specification-document"><a href="#3-What-is-a-requirements-definition-document-What-is-a-requirements-specification-document" class="headerlink" title="3. What is a requirements definition document? What is a requirements specification document?"></a>3. What is a requirements definition document? What is a requirements specification document?</h3><ol><li>The requirements definition is a complete listing of everything the customer expects the proposed system to do. It represents an understanding between the customer and developer of what the customer needs or wants, and it is usually written jointly by the customer and developer.</li><li>The requirements specification restates the requirements definition in technical terms appropriate for the development of a system design; it is the technical counterpart to the requirements definition document, and it is written by requirements analysts.</li></ol><h3 id="4-What-is-a-functional-requirement-Give-an-example-to-explain"><a href="#4-What-is-a-functional-requirement-Give-an-example-to-explain" class="headerlink" title="4. What is a functional requirement? Give an example to explain."></a>4. What is a functional requirement? Give an example to explain.</h3><p>​    A functional requirement describes an interaction between the system and its environment.( For example, to determine functional requirements, we decide what states are acceptable ones for the system to be in.) Further, functional requirements describe how the system should behave given certain stimuli.</p><h3 id="5-What-is-a-nonfuctional-requirement-Give-an-example-to-explain"><a href="#5-What-is-a-nonfuctional-requirement-Give-an-example-to-explain" class="headerlink" title="5. What is a nonfuctional requirement? Give an example to explain."></a>5. What is a nonfuctional requirement? Give an example to explain.</h3><p>​    A nonfuctional requirement, or quality requirement, or constraint, describes a restriction on the system that limits our choices for construction a solution to the problem. (For instance, we may be the system must be developed on an Aardvark computer.)</p><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="1-For-each-type-of-coupling-give-an-example-of-two-components-coupled-in-that-way"><a href="#1-For-each-type-of-coupling-give-an-example-of-two-components-coupled-in-that-way" class="headerlink" title="1. For each type of coupling, give an example of two components coupled in that way."></a>1. For each type of coupling, give an example of two components coupled in that way.</h3><h2 id="复试可能的问题"><a href="#复试可能的问题" class="headerlink" title="复试可能的问题"></a>复试可能的问题</h2><h3 id="1-什么是软件工程"><a href="#1-什么是软件工程" class="headerlink" title="1. 什么是软件工程"></a>1. 什么是软件工程</h3><p>​    将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中</p><h3 id="2-软件的生命周期"><a href="#2-软件的生命周期" class="headerlink" title="2.软件的生命周期"></a>2.软件的生命周期</h3><p>​    是软件的产生直到报废的生命周期</p><ul><li>问题定义：确定系统要解决什么问题</li><li>可行性研究：对系统目标进行全面分析，把待开发系统的目标以明确的语言描述出来</li><li>需求分析：弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册</li><li>软件设计：把确定了的各项需求转换成一个相应的体系结构</li><li>编码和单元测试：按选定语言把软件设计转换为计算机能接受的代码并进行测试</li><li>综合测试：在设计测试用例的基础上检验软件的各个组成部分</li><li>运行/维护</li></ul><h3 id="3-软件过程"><a href="#3-软件过程" class="headerlink" title="3.软件过程"></a>3.软件过程</h3><ol><li>定义：将一组有序的任务称为过程</li><li>软件过程模型：<ul><li>瀑布模型：将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段</li><li>快速原型模型：快速建立起来可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成功能的一个子集</li><li>增量模型：假设可以将需求分段为一系列增量产品，每一增量分别开发，第一个增量往往是核心产品，然后不断增加新的功能</li><li>螺旋模型：将瀑布模型和快速原型模型结合起来，加入了风险分析</li><li>喷泉模型：以用户需求为动力，以对象作为驱动的模型，适合面向对象开发 </li></ul></li></ol><h3 id="4-软件开发的过程"><a href="#4-软件开发的过程" class="headerlink" title="4.软件开发的过程"></a>4.软件开发的过程</h3><ol><li>需求分析阶段</li><li>软件设计阶段</li><li>程序编码阶段</li><li>软件测试阶段</li></ol><h3 id="5-软件需求分析"><a href="#5-软件需求分析" class="headerlink" title="5. 软件需求分析"></a>5. 软件需求分析</h3><ul><li>确定对系统的综合要求</li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ul><p>​    </p><h3 id="6-软件测试"><a href="#6-软件测试" class="headerlink" title="6. 软件测试"></a>6. 软件测试</h3><ul><li>发现程序中的错误而执行程序的过程</li><li>好的测试方案是极可能发现迄今为止尚未发现错误的测试</li><li>成功的测试是发现了至今为止尚未发现的错误的测试</li><li>方法：<ul><li>静态分析与动态测试</li><li>黑盒测试和白盒测试</li></ul></li><li>三个测试阶段<ul><li>开发测试：在开发过程中对系统进行测试以发现bug和缺陷</li><li>发布测试：在系统发布给用户之前，单独的测试团队测试系统的完整版本</li><li>用户测试：其中系统的用户或潜在用户在自己的环境中测试</li></ul></li></ul><h3 id="7-黑盒测试与白盒测试"><a href="#7-黑盒测试与白盒测试" class="headerlink" title="7.黑盒测试与白盒测试"></a>7.黑盒测试与白盒测试</h3><ul><li>黑盒测试：<ul><li>把被测软件看成一个黑盒子，只考虑系统的输入和输出，完全不考虑程序内部的逻辑结构和处理过程</li><li>依据是开发各阶段的需求规格说明</li><li>主要检测软件的每一个功能是否能正常使用</li></ul></li><li>白盒测试：<ul><li>将黑盒子打开，研究源代码和程序内部的逻辑结构</li><li>主要检测软件编码过程中的错误</li></ul></li></ul><h3 id="8-软件维护"><a href="#8-软件维护" class="headerlink" title="8.软件维护"></a>8.软件维护</h3><ul><li>目标：纠正使用过程中暴露出来的错误，改进原有的软件而进行的维护</li><li>分类：<ul><li>纠错性维护：诊断和改正用户在使用软件时遇到的错误</li><li>适应性维护：为了使软件能适应新的硬件等环境而引起的程序修改和扩充活动</li><li>完善性维护：为了满足用户新的需求而增加软件功能的活动</li></ul></li></ul><h3 id="9-面向对象和面向过程"><a href="#9-面向对象和面向过程" class="headerlink" title="9.面向对象和面向过程"></a>9.面向对象和面向过程</h3><ul><li>面向对象：<ul><li>把事情看成是一个个小的对象组成的，或者说一个个小部分组成的</li><li>特点：<ul><li>封装：将一个数据及与这个数据有关的操作集合在一起，形成一个能动的实体即对象。用户不必知道对象行为的实现细节，只需要根据对象提供的外部特性接口访问对象即可</li><li>继承：能够直接获得已有事务的性质和特征，而不必重复定义</li><li>多态：同一个消息可以根据发送消息对象的不同表现出多种不同的行为方式</li></ul></li><li>优点：易维护、易复用、易扩展</li><li>缺点：性能比面向过程低</li></ul></li><li>面向过程：<ul><li>把一件事一项工程分解成一个个小的功能，用一个个函数来实现</li><li>优点：性能比面向对象高</li><li>缺点：不易维护、不易复用、不易扩展</li></ul></li></ul><h3 id="10-面向对象的一些概念"><a href="#10-面向对象的一些概念" class="headerlink" title="10.面向对象的一些概念"></a>10.面向对象的一些概念</h3><ul><li>对象：人们要进行研究的任何事物</li><li>类：具有相同或相似性质的对象的抽象，具有属性，即对象的状态的抽象；具有操作，即对象的行为的抽象</li><li>消息：对象之间进行通信的结构</li><li>方法：类中操作的实现过程</li></ul><h3 id="11-面向对象分析设计的三个模型"><a href="#11-面向对象分析设计的三个模型" class="headerlink" title="11.面向对象分析设计的三个模型"></a>11.面向对象分析设计的三个模型</h3><ul><li>对象模型：描述了现实世界中“类与对象”以及它们之间的关系，表达了目标系统的静态数据结构</li><li>动态模型：每个类的动态行为可用一张状态图描述，一组状态图通过共享事件相互关联集合起来，构成系统的动态模型</li><li>功能模型：描述系统的数据处理功能，反应用户对系统的需求，由一组数据流图和一组用例图组成</li></ul><h3 id="12-UML图"><a href="#12-UML图" class="headerlink" title="12.UML图"></a>12.UML图</h3><ul><li>案例图</li><li>类图</li><li>对象图</li><li>构件图</li><li>部署图</li><li>活动图</li><li>协作图</li><li>状态图</li><li>序列图</li></ul><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter-1&quot;&gt;&lt;a href=&quot;#Chapter-1&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1&quot;&gt;&lt;/a&gt;Chapter 1&lt;/h2&gt;&lt;h3 id=&quot;1-What-is-Software-Engineering&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="专业课" scheme="https://www.oliverbryant.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Internet</title>
    <link href="https://www.oliverbryant.cn/2021/04/30/Internet/"/>
    <id>https://www.oliverbryant.cn/2021/04/30/Internet/</id>
    <published>2021-04-30T02:09:45.000Z</published>
    <updated>2021-04-30T02:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：计算机网络体系结构"><a href="#第一章：计算机网络体系结构" class="headerlink" title="第一章：计算机网络体系结构"></a>第一章：计算机网络体系结构</h1><h2 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h2><h3 id="一、计算机网络的概念"><a href="#一、计算机网络的概念" class="headerlink" title="一、计算机网络的概念"></a>一、计算机网络的概念</h3><ol><li>定义：计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</li><li>简要定义：计算机网络是一些互联的、自治的计算机系统的集合。</li><li>三网：电信网络、有线电视网络和计算机网络。</li></ol><h3 id="二、计算机网络的组成"><a href="#二、计算机网络的组成" class="headerlink" title="二、计算机网络的组成"></a>二、计算机网络的组成</h3><ol><li>从组成部分上看：<ul><li>硬件：主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机）、通信处理机（如网卡）</li><li>软件：各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等）</li><li>协议：计算机网络的核心，规定了网络传输数据时所遵循的规范。</li></ul></li><li>从工作方式上看：<ul><li>边缘部分：由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（如传输数据、音频或视频）和资源共享。<ul><li>C/S方式（Client/Server）：服务与被服务关系的通信，客户主体是进程</li><li>B/S方式（Browser/Server）：客户主体是浏览器</li><li>P2P方式（peer-to-peer）：对等连接，每个主机既可以充当服务提供者，也可充当客户。</li></ul></li><li>核心部分：由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li></ul></li><li>从功能组成上看：<ul><li>通信子网：由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。（OSI下三层）</li><li>资源子网：是实现资源共享的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。（OSI上三层）</li></ul></li></ol><h3 id="三、计算机网络的功能"><a href="#三、计算机网络的功能" class="headerlink" title="三、计算机网络的功能"></a>三、计算机网络的功能</h3><ol><li>数据通信：实现联网计算机之间各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。</li><li>资源共享：同一个计算机上的其他计算机可使用某台计算机的计算机资源的行为，可共享硬件、软件和数据。</li><li>分布式处理：多台计算机各自承担同一工作任务的不同部分。</li><li>提高可靠性：计算机网络中的各台计算机可以通过网络互为替代机。</li><li>负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。</li></ol><h3 id="四、计算机网络发展的三个阶段"><a href="#四、计算机网络发展的三个阶段" class="headerlink" title="四、计算机网络发展的三个阶段"></a>四、计算机网络发展的三个阶段</h3><ol><li>从单个网络ARPANET向互联网发展的过程：ARPAnet-&gt;internet-&gt;Internet</li><li>建成三级结构的因特网：<ul><li>主干网</li><li>地区网</li><li>校园网、企业网</li></ul></li><li>形成多层次ISP结构的因特网：<ul><li>ISP：因特网服务提供者（因特网服务提供商）：中国电信、中国移动、中国联通等</li><li>ISP的划分：<ul><li>主干ISP</li><li>地区ISP</li><li>本地ISP</li></ul></li><li>IXP：因特网交换点：将地区ISP之间直接相连。</li></ul></li></ol><h3 id="五、计算机网络的分类"><a href="#五、计算机网络的分类" class="headerlink" title="五、计算机网络的分类"></a>五、计算机网络的分类</h3><ol><li><p>按分布范围分：</p><ul><li><p>广域网（WAN）：</p><ul><li>覆盖范围几十千米到几千千米。</li><li>采用技术：交换技术</li></ul></li><li><p>城域网（MAN）：</p><ul><li>覆盖范围几千米到几十千米。</li><li>采用技术：以太网技术</li></ul></li><li><p>无线局域网（WLAN）：</p><ul><li>覆盖范围几十米到几千米。</li><li>采用技术：广播技术</li></ul></li><li><p>个域网（PAN）：</p><ul><li>覆盖范围：十米左右</li><li>通过短距离的无线电，将计算机各部件连接起来。</li><li>典型的例子：蓝牙技术、ZigBee技术、NFC技术。</li></ul></li></ul></li><li><p>按使用者分：</p><ul><li>共用网（Public Network）：指电信公司出资建造的大型网络。</li><li>专用网（Private Network）：指某个部门为满足本单位特殊业务的需要而建造的网络。</li></ul></li><li><p>按交换技术分：</p><ul><li><p>电路交换网络：</p><ul><li>定义：在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。</li><li>特点：整个报文的比特流连续地从源点直达终点。</li><li>优点：数据直接传送，时延小。</li><li>缺点：线路利用率低，不能充分利用线路容量，不便于进行差错控制。</li></ul></li><li><p>报文交换网络：</p><ul><li>定义：用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复直到到达目的结点。</li><li>特点：整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一结点。</li><li>优点：可以较为充分地利用线路容量，可以实现不同链路之间不同数据传输速率的转换，可以实现格式转换，可以实现一对多、多对一的访问，可以实现差错控制</li><li>缺点：增大了资源开销，增加了换冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。</li></ul></li><li><p>分组交换网络：</p><ul><li>定义：将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储——转发方式传输。</li><li>特点：单个分组传送到相邻结点，存储后查找转发表，转发到下一结点。</li><li>优点：可以较为充分地利用线路容量，可以实现不同链路之间不同数据传输速率的转换，可以实现格式转换，可以实现一对多、多对一的访问，可以实现差错控制，缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。</li></ul></li></ul></li><li><p>按拓扑结构分：</p><p> <img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/3812b31bb051f8195e8f191bdeb44aed2e73e73d.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/3812b31bb051f8195e8f191bdeb44aed2e73e73d.png" srcset="data:image/png;base64,666" alt="拓扑结构分类图"></p><ul><li>总线型网络：<ul><li>定义：用单根数据线把计算机连接起来</li><li>优点：建网容易、增/减结点方便、节省线路</li><li>缺点：重负载时通信效率不高、总线任意一处对故障敏感</li></ul></li><li>星型网络：<ul><li>定义：每个终端或计算机都以单独的线路与中央设备相连。</li><li>优点：便于集中控制和管理</li><li>缺点：成本高、中心设备对故障敏感</li></ul></li><li>环形网络：<ul><li>定义：所有计算机接口设备连接成一个环</li><li>特点：环中信号是单向传输的</li></ul></li><li>网状网络：<ul><li>定义：每个结点至少有两条路径与其他结点相连，多用在广域网中</li><li>优点：可靠性高</li><li>缺点：控制复杂、线路成本高</li></ul></li></ul></li><li><p>按传输技术分：</p><ul><li>广播式网络：所有联网计算机都共享一个公共通信信道。</li><li>点对点网络：每条物理线路连接一对计算机。</li></ul></li></ol><h3 id="六、计算机网络的性能指标"><a href="#六、计算机网络的性能指标" class="headerlink" title="六、计算机网络的性能指标"></a>六、计算机网络的性能指标</h3><ol><li><p>速率：</p><ul><li><p>定义：连接在计算机网络上的主机在数字信道上传送数据位数的速率。</p></li><li><p>单位：<br>  $$<br>  1Tb/s=10^3Gb/s=10^6Mb/s=10^9kb/s=10^{12}b/s<br>  $$</p></li></ul></li><li><p>带宽：</p><ul><li>通信定义：某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</li><li>网络定义：表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。</li><li>单位：同上</li><li>实质：主机发送数据的最高速率</li></ul></li><li><p>吞吐量：</p><ul><li>定义：表示在单位时间内通过某个网络（或信道、接口）的数据量。</li><li>单位：同上</li><li>注：吞吐量受网络的带宽或网络的额定速率的限制  </li></ul></li><li><p>时延：</p><ul><li><p>定义：指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫延迟或迟延。</p></li><li><p>单位：s</p></li><li><p>分类：</p><ul><li><p>发送时延（传输时延）：</p><ul><li><p>定义：结点将分组的所有比特推向链路所需要的时间。</p></li><li><p>公式：<br>  $$<br>  发送时延=\frac{分组长度}{信道带宽}<br>  $$</p></li></ul></li><li><p>传播时延：</p><ul><li><p>定义：电磁波在信道中传播一定的举例花费的时间。</p></li><li><p>公式：<br>  $$<br>  传播时延=\frac{信道长度}{电磁波在信道上的传播速率}<br>  $$</p></li></ul></li><li><p>排队时延：等待输出/输入链路可用的时间。</p></li><li><p>处理时延：数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。</p></li></ul></li><li><p>注：</p><ul><li>一般情况下，排队时延和处理时延可以忽略不计。</li><li>高速链路，实际是提高数据发送速率，所以仅会减小发送时延；并不改变电磁波传播速率，故传播时延没有变化。</li></ul></li></ul></li><li><p>时延带宽积：</p><ul><li><p>定义：指发送段发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，又称以比特为单位的链路长度。</p></li><li><p>单位：bit</p></li><li><p>公式：<br>  $$<br>  时延带宽积=传播时延\times信道带宽<br>  $$</p></li><li><p>实质：某段链路的比特容量</p></li></ul></li><li><p>往返时延RTT：</p><ul><li>定义：从发送方发送数据开始<font color="orange">（第一个bit到信道上）</font>，到发送方收到接受方的确认<font color="orange">（发送方收到对于第一个bit的确认信息）</font>（接受方收到数据后立即发送确认），总共经历的时延。</li><li>RTT越大，在收到确认前，可以发送的数据越多。</li><li>包括：<ul><li>往返传播时延：两倍的传播时延</li><li>末端处理时间</li></ul></li></ul></li><li><p>利用率：</p><ul><li><p>分类：</p><ul><li><p>信道利用率：</p><ul><li><p>定义：指出某一信道有百分之多少的时间是有数据通过的。</p></li><li><p>公式：<br>  $$<br>  信道利用率=\frac{有数据通过的时间}{（有+无）数据通过的时间}<br>  $$</p></li></ul></li><li><p>网络利用率：信道利用率加权求平均值。</p></li></ul></li></ul></li></ol><h2 id="二、计算机网络体系结构与参考模型"><a href="#二、计算机网络体系结构与参考模型" class="headerlink" title="二、计算机网络体系结构与参考模型"></a>二、计算机网络体系结构与参考模型</h2><h3 id="一、计算机网络分层结构"><a href="#一、计算机网络分层结构" class="headerlink" title="一、计算机网络分层结构"></a>一、计算机网络分层结构</h3><ol><li><p>名词解析：</p><ul><li><p>实体：任何可发送或接受信息的硬件或软件进程。同一层的实体称为对等实体。</p></li><li><p>协议：规则的集合。</p></li><li><p>网络协议：</p><ul><li>定义：为进行网络中的数据交换而建立的规则、标准或约定。</li><li>特点：水平的，只有对等实体（同一层）之间才有协议</li><li>构成：<ul><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能<ul><li>发出何种控制信息</li><li>完成何种动作</li><li>作出何种应答</li></ul></li><li>同步：规定执行各种操作的条件、时序关系等，即时间实现顺序的详细说明。</li></ul></li><li>包含：<ul><li>线路管理</li><li>差错控制</li><li>数据转换</li></ul></li></ul></li><li><p>接口（服务访问点SAP）：</p><ul><li>定义：同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。</li><li>注：服务是通过SAP提供给上层使用的。第n层的SAP就是第n+1层可以访问第n层服务的地方。</li></ul></li><li><p>服务：</p><ul><li>定义：指下层为紧邻的上层提供的功能调用，它是垂直的。</li><li>注：对等实体在协议的控制下，使得本层能为上层提供服务，但要实现本层协议还需要使用下一层提供的服务</li></ul></li><li><p>原语：</p><ul><li>定义：上层使用下层提供的服务时与下层交换的命令。</li><li>分类：<ul><li>请求：由服务用户发往服务提供者，请求完成某项工作</li><li>指示：由服务提供者发往服务用户，指示用户做某件事情</li><li>响应：由服务用户发往服务提供者，作为对指示的响应</li><li>证实：由服务提供者发往服务用户，作为对请求的证实。</li></ul></li></ul></li><li><p>SDU服务数据单元：为完成用户所要求的功能而应传送的数据。</p></li><li><p>PCI协议控制信息：控制协议操作的信息</p></li><li><p>PDU协议数据单元：对等层次之间传送的数据单位</p>  <img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210515122628.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210515122628.png" srcset="data:image/png;base64,666" style="zoom:50%;" /></li></ul></li><li><p>分层的基本原则：</p><ul><li>各层之间相互<font color="red">独立</font>，每层只实现一种相对独立的功能。</li><li>每层之间<font color="red">界面自然清晰</font>，易于理解，相互交流尽可能少。</li><li>结构上可分割开。每层都采用<font color="red">最合适的技术</font>来实现。</li><li>保持<font color="red">下层</font>对<font color="red">上层</font>的独立性，<font color="red">上层单向使用下层提供的服务</font>。</li><li>整个分层结构应该能促进标准化工作。</li></ul></li><li><p>注：</p><ul><li>网络体系结构是从<font color="red">功能</font>上描述计算机网络结构。</li><li>计算机网络体系结构建成网络体系结构是<font color="red">分层结构</font>。</li><li>每层遵循某个/些<font color="red">网络协议</font>以完成本层功能。</li><li>计算机网络体系结构是计算机网络<font color="red">各层及其协议</font>的集合</li><li>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的服务，还包含由下层服务提供的功能。</li><li>仅仅在<font color="red">相邻层间</font>有接口，且所提供服务的具题实现细节对上层完全屏蔽</li><li>体系结构是<font color="red">抽象</font>的，而实现是指能运行的一些软件和硬件。</li></ul></li></ol><h3 id="二、OSI参考模型"><a href="#二、OSI参考模型" class="headerlink" title="二、OSI参考模型"></a>二、OSI参考模型</h3><ol><li>国际标准化组织（ISO）于1984年提出开放系统互连（OSI）参考模型，是一种法定标准。<font color="orange">（理论成功，市场失败）</font></li><li>层次：物链网输会示用：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/OSI.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/OSI.png" srcset="data:image/png;base64,666" style="zoom: 50%;" /></li><li>应用层：<ul><li>定义：所有能和用户交互产生网络流量的程序，是用户与网络的界面</li><li>典型服务：<ul><li>文件传输（FTP）</li><li>电子邮件（SMTP）</li><li>万维网（HTTP）</li></ul></li></ul></li><li>表示层：<ul><li>定义：用于处理在两个通信系统中交换信息的表示方式（语法和语义）</li><li>功能：<ul><li>数据格式变换：翻译</li><li>数据加密解密</li><li>数据压缩恢复</li></ul></li><li>典型协议：<ul><li>JPEG</li><li>ASCII</li></ul></li></ul></li><li>会话层：<ul><li>定义：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，也称为建立同步（SYN）。</li><li>功能：<ul><li>建立、管理、终止会话</li><li>使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。</li></ul></li><li>典型协议：<ul><li>ADSP</li><li>ASP</li></ul></li></ul></li><li>传输层：<ul><li>定义：负责主机中两个进程的通信，即端到端的通信。</li><li>传输单位：报文段或用户数据报</li><li>功能：<ul><li>可靠传输、不可靠传输</li><li>差错控制</li><li>流量控制</li><li>复用分用：<ul><li>复用：多个应用层进程可同时使用下面运输层的服务</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</li></ul></li></ul></li><li>典型协议：<ul><li>TCP</li><li>UDP</li></ul></li></ul></li><li>网络层：<ul><li>主要任务：把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务。</li><li>传输单位：数据报（分组是数据报切割后）</li><li>功能：<ul><li>路由选择：寻找最佳路径</li><li>流量控制</li><li>差错控制</li><li>拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。</li></ul></li><li>主要协议：<ul><li>IP</li><li>IPX</li><li>ICMP</li><li>IGMP</li><li>ARP</li><li>RARP</li><li>OSPF</li></ul></li></ul></li><li>数据链路层：<ul><li>主要任务：把网络层传下来的数据报组装成帧。</li><li>传输单位：帧</li><li>功能：<ul><li>成帧：定义帧的开始和结束</li><li>差错控制</li><li>流量控制</li><li>访问（接入）控制：控制对信道的访问</li></ul></li><li>主要协议：<ul><li>SDLC</li><li>HDLC</li><li>PPP</li><li>STP</li></ul></li></ul></li><li>物理层：<ul><li>主要任务：在物理媒体上实现比特流的透明传输（指不管所传数据是什么样的比特组合，都应当能够在链路上传送）</li><li>传输单位：比特</li><li>功能：<ul><li>定义接口特性</li><li>定义传输模式：<ul><li>单工</li><li>半双工</li><li>双工</li></ul></li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li><li>主要协议：<ul><li>Rj45</li><li>802.3</li></ul></li></ul></li></ol><h3 id="三、TCP-IP模型"><a href="#三、TCP-IP模型" class="headerlink" title="三、TCP/IP模型"></a>三、TCP/IP模型</h3><ol><li><p>TCP/IP模型：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/TCPIP%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/TCPIP%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,666" style="zoom:50%;" /></p></li><li><p>TCP/IP协议栈：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88.png" srcset="data:image/png;base64,666" style="zoom:50%;" /></p></li><li><p>TCP/IP模型与OSI模型的比较</p><ul><li><p>相同点：</p><ul><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络的互联</li></ul></li><li><p>不同点：</p><ul><li><p>OSI定义三点：服务、协议、接口</p></li><li><p>OSI先出现，参考模型先于协议发明，不偏向特定协议</p></li><li><p>TCP/IP设计之初就考虑到异构网互联问题，将IP作为重要层次</p></li><li><table><thead><tr><th align="center"></th><th align="center">OSI</th><th align="center">TCP/IP</th></tr></thead><tbody><tr><td align="center">网络层</td><td align="center">无连接+面向连接</td><td align="center">无连接</td></tr><tr><td align="center">传输层</td><td align="center">面向连接</td><td align="center">无连接+面向连接</td></tr></tbody></table><ul><li>面向连接：<ul><li>建立连接：发出一个建立连接的请求。</li><li>数据传输</li><li>释放连接</li></ul></li><li>无连接：直接进行数据传输</li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章：计算机网络体系结构&quot;&gt;&lt;a href=&quot;#第一章：计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;第一章：计算机网络体系结构&quot;&gt;&lt;/a&gt;第一章：计算机网络体系结构&lt;/h1&gt;&lt;h2 id=&quot;一、计算机网络概述&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="专业课" scheme="https://www.oliverbryant.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Data_Structure</title>
    <link href="https://www.oliverbryant.cn/2021/04/24/Data-Structure/"/>
    <id>https://www.oliverbryant.cn/2021/04/24/Data-Structure/</id>
    <published>2021-04-24T01:38:39.000Z</published>
    <updated>2021-04-24T01:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h2 id="一、数据结构的基本概念"><a href="#一、数据结构的基本概念" class="headerlink" title="一、数据结构的基本概念"></a>一、数据结构的基本概念</h2><h3 id="一、基本概念和术语"><a href="#一、基本概念和术语" class="headerlink" title="一、基本概念和术语"></a>一、基本概念和术语</h3><ol><li>数据：<ul><li>数据是<font color="red">信息的载体</font></li><li>是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。</li><li>数据是计算机程序加工的原料。</li></ul></li><li>数据元素：<ul><li>数据元素是<font color="red">数据的基本单位</font>，通常作为一个整体进行考虑和处理。</li><li>一个数据元素可有若干数据项组成，数据项是<font color="red">构成数据元素的不可分割的最小单位</font>。</li></ul></li><li>数据对象：<ul><li>数据对象是<font color="red">具有相同性质的数据元素的集合</font>，是数据的一个子集。</li></ul></li><li>数据类型：<ul><li>数据类型是<font color="red">一个值的集合和定义在此集合上的一组操作的总称</font>。</li><li>分类：<ul><li>原子类型：其值不可再分的数据类型</li><li>结构类型：其值可以再分解为若干成分（分量）的数据类型</li><li>抽象数据类型：抽象数据组织及与之相关的操作</li></ul></li></ul></li><li>数据结构：<ul><li>数据结构是<font color="red">相互之间存在一种或多种特定关系的数据元素的集合</font></li><li>结构：数据元素相互之间的关系</li><li>三要素：<ul><li>逻辑结构：算法的设计</li><li>存储结构：算法的实现</li><li>数据的运算</li></ul></li></ul></li></ol><h3 id="二、数据结构三要素"><a href="#二、数据结构三要素" class="headerlink" title="二、数据结构三要素"></a>二、数据结构三要素</h3><ol><li><p>数据的逻辑结构：</p><ul><li>定义：逻辑结构是指<font color="red">数据元素之间的逻辑关系，即从逻辑关系上描述数据</font>。它与数据的存储<font color="red">无关</font>，是独立于计算机的。</li><li>分类：<ul><li>线性结构：只存在一对一的关系</li><li>非线性结构：存在一对多、多对多的关系</li></ul></li></ul><p> <img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/image-20210424100359950.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/image-20210424100359950.png" srcset="data:image/png;base64,666" alt="image-20210424100359950"></p></li><li><p>数据的存储结构：</p><ul><li>定义：存储结构是指<font color="red">数据结构在计算机中的表示（映像）</font>，也称物理结构。它是用计算机语言实现的逻辑结构，它依赖于计算机语言。</li><li>分类：<ul><li>顺序存储：<ul><li>定义：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单位的邻接来体现。</li><li>优点：实现随机存储，每个元素占用最少的存储空间。</li><li>缺点：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li></ul></li><li>链式存储：<ul><li>定义：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li><li>优点：不会出现碎片现象，能充分利用所有存储单元。</li><li>缺点：每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li></ul></li><li>索引存储：<ul><li>定义：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的形式一般是<font color="red">（关键字，地址）</font></li><li>优点：检索速度快</li><li>缺点：附加的索引表额外占用存储空间；增加和删除数据时也需要修改索引表，因而会花费较多时间。</li></ul></li><li>散列存储：<ul><li>定义：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储。</li><li>优点：检索、增加和删除结点的操作都很快</li><li>缺点：若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li></ul></li></ul></li></ul></li><li><p>数据的运算：</p><ul><li>运算的定义：针对逻辑结构，指出运算的功能。</li><li>运算的实现：针对存储结构，指出运算的具体操作步骤。</li></ul></li></ol><h2 id="二、算法和算法评价"><a href="#二、算法和算法评价" class="headerlink" title="二、算法和算法评价"></a>二、算法和算法评价</h2><h3 id="一、算法的基本概念"><a href="#一、算法的基本概念" class="headerlink" title="一、算法的基本概念"></a>一、算法的基本概念</h3><ol><li>算法的定义：算法是<font color="red">对特定问题求解步骤的一种描述</font>，它是指令的有限序列，其中的每条指令表示<font color="red">一个或多个操作</font>。</li><li>算法的特性：<ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得到相同的输出。</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li><li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li></ul></li><li>算法的目标：<ul><li>正确性：算法应能够正确地解决求解问题。</li><li>可读性：算法应具有良好的可读性，以帮助人们理解。</li><li>健壮性：输入非法数据时，算法能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果。</li><li>效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</li></ul></li></ol><h3 id="二、算法效率的度量"><a href="#二、算法效率的度量" class="headerlink" title="二、算法效率的度量"></a>二、算法效率的度量</h3><ol><li><p>时间复杂度：</p><ul><li><p>频度：一个语句的频度是指该语句在算法中被重复执行的次数。</p></li><li><p>定义：算法中所有语句的频度之和记作T(n)，它是算法问题规模n的函数，时间复杂度就是分析T(n)的数量级。</p><ul><li>最坏时间复杂度：在最坏情况下，算法的时间复杂度。</li><li>平均时间复杂度：所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</li><li>最好时间复杂度：在最好情况下，算法的时间复杂度。</li></ul></li><li><p>公式：T(n)=O(f(n))</p></li><li><p>依赖：</p><ul><li>问题的规模n</li><li>待输入数据的性质</li></ul></li><li><p>规则：</p><ul><li><p>加法规则：<br>  $$<br>  T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))<br>  $$</p></li><li><p>乘法规则：<br>  $$<br>  T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O((f(n)\times g(n))<br>  $$</p></li></ul></li><li><p>常见的渐进时间复杂度：<br>  $$<br>  O(1)&lt;O(\log_2n)&lt;O(n)&lt;O(n\log_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)<br>  $$</p></li></ul></li><li><p>空间复杂度：</p><ul><li>定义：该算法所消耗的存储空间，它是问题规模n的函数。</li><li>公式：S(n)=O(g(n))</li><li>原地工作：指算法所需的辅助空间为常量，即O(1)。</li></ul></li></ol><h1 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h1><h2 id="一、线性表的定义和基本操作"><a href="#一、线性表的定义和基本操作" class="headerlink" title="一、线性表的定义和基本操作"></a>一、线性表的定义和基本操作</h2><h3 id="一、线性表的定义"><a href="#一、线性表的定义" class="headerlink" title="一、线性表的定义"></a>一、线性表的定义</h3><ol><li>定义：线性表是<font color="red">具有相同数据类型的n(n&gt;=0)个数据元素的有限序列</font>，其中n为表长，当n=0时线性表是一个空表。即L=(a1,a2,…,ai,ai+1,…,an)。a1是唯一的”第一个“数据元素，又称表头元素；an是唯一的”最后一个“数据元素，又称表尾元素。</li><li>逻辑特性：除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且只有一个直接后继。</li><li>特点：<ul><li>表中元素的个数有限。</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li><li>表中元素都是数据元素，每个元素都是单个元素。</li><li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。</li><li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li></ul></li></ol><p><u>注：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。</u></p><h3 id="二、线性表的基本操作"><a href="#二、线性表的基本操作" class="headerlink" title="二、线性表的基本操作"></a>二、线性表的基本操作</h3><ol><li>InitList(&amp;L)：初始化表，构建一个空的线性表。</li><li>Length(L)：求表长。返回线性表L的长度。</li><li>LocateElem(L,e)：按值查找操作。</li><li>GetElem(L,i)：按位查找操作。</li><li>ListInsert(&amp;L,i,e)：插入操作。</li><li>ListDelete(&amp;L,i,&amp;e)：删除操作。</li><li>PrintList(L)：输出操作。</li><li>Empty(L)：判空操作。</li><li>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</li></ol><h2 id="二、线性表的顺序表示"><a href="#二、线性表的顺序表示" class="headerlink" title="二、线性表的顺序表示"></a>二、线性表的顺序表示</h2><h3 id="一、顺序表的定义"><a href="#一、顺序表的定义" class="headerlink" title="一、顺序表的定义"></a>一、顺序表的定义</h3><ol><li><p>定义：它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p></li><li><p>第一个元素存储在线性表中的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素ai在线性表中的位序。</p></li><li><p>特点：</p><ul><li>表中元素的逻辑顺序与其物理顺序相同。</li><li>随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li><li>存储密度高，每个结点只存储数据元素。</li><li>逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</li></ul></li><li><p>代码实现：</p><ul><li>静态分配：数组的大小和空间事先固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50               <span class="comment">//定义线性表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];      <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length;                  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                         <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure><ul><li>动态分配：</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100                                           <span class="comment">//表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *data;                                            <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize,length;                                        <span class="comment">//数组的最大容量和当前个数</span></span><br><span class="line">&#125;SqList;                                                       <span class="comment">//动态分配数组顺序表的类型定义</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*InitSize);         <span class="comment">//C的初始动态分配语句</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二、顺序表上基本操作的实现"><a href="#二、顺序表上基本操作的实现" class="headerlink" title="二、顺序表上基本操作的实现"></a>二、顺序表上基本操作的实现</h3><ol><li><p>插入操作：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListInsert</span><span class="params">(SqList* L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置错误，请检查后重试！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length + <span class="number">1</span> &gt; L-&gt;Maxsize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间不足，请扩容！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L-&gt;length; j &gt;= i; j--) &#123;</span><br><span class="line">        L-&gt;data[j + <span class="number">1</span>] = L-&gt;data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i] = e;</span><br><span class="line">    L-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul></li><li><p>删除操作：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListDelete</span><span class="params">(SqList* L, <span class="type">int</span> i, ElemType* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; L-&gt;length; j++) &#123;</span><br><span class="line">        L-&gt;data[j - <span class="number">1</span>] = L-&gt;data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul></li><li><p>按值查找：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul></li></ol><h2 id="三、线性表的链式表示"><a href="#三、线性表的链式表示" class="headerlink" title="三、线性表的链式表示"></a>三、线性表的链式表示</h2><h3 id="一、单链表的定义"><a href="#一、单链表的定义" class="headerlink" title="一、单链表的定义"></a>一、单链表的定义</h3><ol><li><p>单链表：链表的链式存储，它是指<font color="red">通过一组任意的存储单元来存储线性表中的数据元素</font>。</p></li><li><p>结构：</p><ul><li>data：数据域，存放自身元素</li><li>next：指针域，存放其后继结点的地址</li></ul></li><li><p>优点：可以解决顺序表需要大量连续存储单元的缺点。</p></li><li><p>缺点：</p><ul><li>附加指针域，浪费存储空间</li><li>非随机存储的存储结构，不能直接找到表中某个特定的结点，必须从表头遍历，依次查找。</li></ul></li><li><p>头指针：用来标识一个单链表。当头指针为NULL时为空表。</p></li><li><p>头结点：</p><ul><li>定义：在单链表第一个结点前附加的一个结点，可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。</li><li>与头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</li><li>优点：<ul><li>由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理。</li><li>无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。</li></ul></li></ul></li><li><p>代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>          <span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;             <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>        <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、单链表上的基本操作的实现"><a href="#二、单链表上的基本操作的实现" class="headerlink" title="二、单链表上的基本操作的实现"></a>二、单链表上的基本操作的实现</h3><ol><li><p>采用头插法建立单链表：</p><ul><li><p>思想：从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。</p></li><li><p>时间复杂度：每次插入O(1)，若单链表长为n，则总时间复杂度为O(n)。</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList L)</span>&#123;           <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    ElemType x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));          <span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                             <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                             <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)                             <span class="comment">//输入9999结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));        <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;                        <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        L-&gt;next=s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>采用尾插法建立单链表：</p><ul><li><p>思想：将新结点插入到当前链表的表尾，为此必须设置一个尾指针r，使其始终指向表尾。</p></li><li><p>时间复杂度：每次插入O(1)，若单链表长为n，则总时间复杂度为O(n)。</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList L)</span>&#123;             <span class="comment">//正向建立单链表</span></span><br><span class="line">    ElemType x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LNode *s,*r=L;                                <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;                                      <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;                                 <span class="comment">//表尾置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>按序号查找结点值：</p><ul><li><p>思想：在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。</p></li><li><p>时间复杂度：O(n)</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LNode* <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;                        <span class="comment">//计数，初始为1</span></span><br><span class="line">    LNode* p = L-&gt;next;               <span class="comment">//头结点指针域给p</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> L;                     <span class="comment">//若i等于0，则返回头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                  <span class="comment">//若i无效，则返回NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j != i) &#123;             <span class="comment">//从第1个结点开始找，查找第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;                         <span class="comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>按值查找结点：</p><ul><li><p>思想：从单链表的第一个结点出发，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点指针；若整个单链表中没有这样的结点，则返回NULL。</p></li><li><p>时间复杂度：O(n)</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LNode* <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;        <span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;                                  <span class="comment">//找到后返回该结点指针，否则返回NULL`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>插入结点操作：</p><ul><li><p>思想：首先调用按序查找找到前驱结点，令新结点的指针域指向前驱结点的指针域，再令前驱结点的指针域指向新结点。</p></li><li><p>时间复杂度：查找元素为O(n)，插入结点为O(1).</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">BackInsert</span><span class="params">(LinkList L, LNode* p, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode* q;</span><br><span class="line">    q = GetElem(L, i - <span class="number">1</span>);           <span class="comment">//查找插入位置的前驱结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除结点操作：</p><ul><li><p>思想：先检查删除位置的合法性，后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除。</p></li><li><p>时间复杂度：查找元素为O(n)，插入结点为O(1).</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>);          <span class="comment">//查找删除位置的前驱结点</span></span><br><span class="line">q=p-&gt;next;                 <span class="comment">//令q指向被删除结点</span></span><br><span class="line">p-&gt;next=q-&gt;next;           <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line"><span class="built_in">free</span>(q);                   <span class="comment">//释放结点的存储空间</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、双链表"><a href="#三、双链表" class="headerlink" title="三、双链表"></a>三、双链表</h3><ol><li><p>定义：结点中有两个指针prior和next，分别指向其前驱结点和后继结点。</p></li><li><p>代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>                <span class="comment">//定义双链表结点类型</span></span><br><span class="line">ElemType data;                   <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span>       <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure></li><li><p>优点：插入和删除操作的时间复杂度均为O(1).</p><ul><li><p>插入：在p之前插入结点*s</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=s;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br></pre></td></tr></table></figure></li><li><p>删除：删除结点*p的后继结点 *q</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、循环链表"><a href="#四、循环链表" class="headerlink" title="四、循环链表"></a>四、循环链表</h3><ol><li>循环单链表：<ul><li>定义：表中最后一个结点的指针域不是NULL，而是指向头结点，从而整个链表形成一个环。</li><li>特点：<ul><li>在循环单链表中没有指针域为NULL的结点，因此判空条件是头结点的指针是否等于头指针。</li><li>在循环链表中可以从任意结点开始遍历整个链表。</li><li>循环单链表一般不设头指针而只设尾指针，从而使效率更高。<ul><li>对单链表的操作很多是从表头表尾进行。</li><li>若设头指针，对表尾的操作需要O(n)来遍历，而设尾指针r，r-&gt;next即为头指针，因此对表头表尾操作都是O(1).</li></ul></li></ul></li></ul></li><li>循环双链表：<ul><li>定义：在循环单链表的基础上增加prior指针。头结点的prior指向尾结点。</li><li>特点：在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L；当表为空表时，其头结点的prior和next都等于L。</li></ul></li></ol><h3 id="五、静态链表"><a href="#五、静态链表" class="headerlink" title="五、静态链表"></a>五、静态链表</h3><ol><li><p>定义：静态链表借助数组来描述线性表的链式结构，结点中也有数据域data和指针域next，在指针域中存放的是下一个结点的相对地址（数组下标），又称游标。</p></li><li><p>特点：</p><ul><li>和顺序表一样，静态链表也要预先分配一块连续的空间。</li><li>静态链表以next==-1作为结束的标志。</li></ul></li><li><p>代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50         <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>            <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;         <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;              <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125; SLinkList[MaxSize];</span><br></pre></td></tr></table></figure></li></ol><h3 id="六、顺序表和链表的比较"><a href="#六、顺序表和链表的比较" class="headerlink" title="六、顺序表和链表的比较"></a>六、顺序表和链表的比较</h3><ol><li>比较</li></ol><table><thead><tr><th align="center"></th><th align="center">顺序表</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">存取（读写）方式</td><td align="center">顺序存取、随机存取</td><td align="center">从表头顺序存取</td></tr><tr><td align="center">逻辑结构与物理结构</td><td align="center">逻辑上相邻的元素，对应的物理存储结构也相邻</td><td align="center">逻辑上相邻的元素，物理存储位置不一定相邻</td></tr><tr><td align="center">按值查找</td><td align="center">无序时O(n),有序时O(log2n)</td><td align="center">O(n)</td></tr><tr><td align="center">按序号查找</td><td align="center">O(1)</td><td align="center">O(n)</td></tr><tr><td align="center">插入和删除</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">空间分配</td><td align="center">开始前分配，存满不能扩充，存储密度大</td><td align="center">空间在需要时申请分配，且只要内存有空间就可以分配，存储密度不大</td></tr></tbody></table><ol start="2"><li>如何选择存储结构？<ul><li>基于存储的考虑：难以估计线性表长度或存储规模时，不宜采用顺序表。</li><li>基于运算的考虑：<ul><li>若经常做的运算是按序号访问元素，则选择顺序表</li><li>若操作主要是删除或者插入，则选择链表</li></ul></li><li>基于环境的考虑：<ul><li>顺序表容易实现</li><li>链表的操作基于指针</li></ul></li></ul></li></ol><h1 id="第三章：栈和队列"><a href="#第三章：栈和队列" class="headerlink" title="第三章：栈和队列"></a>第三章：栈和队列</h1><h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="一、栈的基本概念"><a href="#一、栈的基本概念" class="headerlink" title="一、栈的基本概念"></a>一、栈的基本概念</h3><ol><li><p>栈的定义：</p><ul><li>栈：只允许在一端进行插入或删除操作的线性表。</li><li>栈顶：线性表允许进行插入删除的那一端。</li><li>栈底：固定的，不允许进行插入和删除的另一端。</li><li>空栈：不含任何元素的空表。</li></ul></li><li><p>栈的特点：后进先出（LIFO）</p></li><li><p>栈的数学性质：卡特兰数，n个不同元素进栈，出栈元素不同排列的个数。<br> $$<br> \frac1{n+1}C_{2n}^n<br> $$</p></li><li><p>栈的基本操作：可以直接使用这些基本操作函数。</p><ul><li>InitStack(&amp;S)：初始化一个空栈S</li><li>StackEmpty(S)：判断一个栈是否为空</li><li>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为栈顶</li><li>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回</li><li>GetTop(S,&amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素</li><li>DestroyStack(&amp;S)：销毁栈，并释放栈S占用的存储空间</li></ul></li></ol><h3 id="二、栈的顺序存储结构"><a href="#二、栈的顺序存储结构" class="headerlink" title="二、栈的顺序存储结构"></a>二、栈的顺序存储结构</h3><ol><li><p>定义：采用顺序存储结构的栈。它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针(top)指示当前栈顶元素的位置。</p></li><li><p>代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50                     <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];            <span class="comment">//存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                           <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><ul><li>栈顶指针：S.top，初始设置S.top=-1；</li><li>栈顶元素：S.data[S.top]</li><li>栈空条件：S.top==-1</li><li>栈满条件：S.top==MaxSize-1</li><li>栈长：S.top+1</li></ul></li><li><p>顺序栈的基本运算：</p><ul><li><p>初始化：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack* S)</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;top = <span class="number">-1</span>;                  <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判栈空：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;            <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">//非空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进栈：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(SqStack *S,ElemType e)</span>&#123;      </span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==MaxSize<span class="number">-1</span>)&#123;          <span class="comment">//栈满，报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;data[++S-&gt;top]=e;            <span class="comment">//指针先+1，再入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出栈：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(SqStack* S, ElemType* e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;             <span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top--];         <span class="comment">//先出栈，指针再-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读栈顶元素：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType* e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)               <span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *e = S.data[S.top];            <span class="comment">//e记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>共享栈：</p><ul><li>定义：让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</li><li>原理：两个栈的栈顶指针都指向栈顶元素，top0==-1是0号栈为空，top1==MaxSize时1号栈为空；仅当(top1-top0==1)时，则为栈满。</li><li>优点：更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被栈满时才发生上溢。</li></ul></li></ol><h3 id="三、栈的链式存储结构"><a href="#三、栈的链式存储结构" class="headerlink" title="三、栈的链式存储结构"></a>三、栈的链式存储结构</h3><ol><li><p>定义：采用链式存储的称为链栈。通常采用单链表实现。</p></li><li><p>优点：便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。</p></li><li><p>代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;                 <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span>         <span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;                        <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="一、队列的基本概念"><a href="#一、队列的基本概念" class="headerlink" title="一、队列的基本概念"></a>一、队列的基本概念</h3><ol><li>队列的定义：<ul><li>定义：一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。</li><li>入队：向队列中插入元素成为入队，也叫仅队</li><li>出队：删除元素，也叫离队</li><li>队头（Front）：允许删除的一端，又称队首</li><li>队尾（Rear）：允许插入的一端</li><li>空队列：不含任何元素的空表</li></ul></li><li>队列的特点：先进先出（FIFO）</li><li>队列常见的基本操作：<ul><li>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q</li><li>QueueEmpty(Q)：判队列空</li><li>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾</li><li>DeQueue(&amp;Q,&amp;x)：出队，若队列非空，删除队头元素，并用x返回</li><li>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x</li></ul></li></ol><h3 id="二、队列的顺序存储结构"><a href="#二、队列的顺序存储结构" class="headerlink" title="二、队列的顺序存储结构"></a>二、队列的顺序存储结构</h3><ol><li><p>队列的顺序存储：</p><ul><li>定义：分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。</li><li>代码实现：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50                   <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           </span><br><span class="line">    ElemType data[MaxSize];          <span class="comment">//存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;                  <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><ul><li>队空条件：Q.front==Q.rear==0</li><li>缺点：栈满难以判断，容易出现假溢出。</li></ul></li><li><p>循环队列：</p><ul><li>定义：把存储队列元素的表从逻辑上视为一个环。当队首指针Q.front==MaxSize-1时，再进一个位置就自动到0.</li><li>队空条件：Q.front==Q.rear==0</li><li>队首指针进1：Q.front=(Q.front+1)%MaxSize</li><li>队尾指针进1：Q.rear=(Q.rear+1)%MaxSize</li><li>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize</li><li>判断队满：<ul><li>牺牲一个单元来区分队满和队空，入队时少用一个队列单元。此时队头指针在队尾指针的下一位置为队满的标志。</li><li>类型中增设表示元素个数的数据成员。</li><li>类型中增设tag数据成员，以区分队满还是队空，此时条件都是Q.front==Q.rear。通过tag判断。</li></ul></li></ul></li><li><p>循环队列的操作：</p><ul><li><p>初始化：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line">    Q-&gt;rear=Q-&gt;front=<span class="number">0</span>;                 <span class="comment">//初始化队首，队尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判队空：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)                 <span class="comment">//队空条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>入队：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MaxSize==Q-&gt;front)          <span class="comment">//队满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=x;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MaxSize;               <span class="comment">//队尾指针+1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出队：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,ElemType *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front)                      <span class="comment">//队空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MaxSize;             <span class="comment">//队头指针+1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、队列的链式存储结构"><a href="#三、队列的链式存储结构" class="headerlink" title="三、队列的链式存储结构"></a>三、队列的链式存储结构</h3><ol><li><p>队列的链式存储：</p><ul><li><p>定义：一个同时带有队头指针和队尾指针的单链表，也称链队列。</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                         <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                         <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear;              <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></li><li><p>队空条件：Q.front==NULL且Q.rear==NULL</p></li><li><p>一般采用<font color="red">带有头结点</font>的单链表。</p></li></ul></li><li><p>链式队列的基本操作：</p><ul><li><p>初始化：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span>&#123;</span><br><span class="line">    Q-&gt;front=Q-&gt;rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));     <span class="comment">//建立头结点</span></span><br><span class="line">    Q-&gt;front-&gt;next=<span class="literal">NULL</span>;                                      <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判队空：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>入队：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q,ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;s-&gt;next=<span class="literal">NULL</span>;                                <span class="comment">//创建新结点，插入到链尾</span></span><br><span class="line">    Q-&gt;rear-&gt;next=s;</span><br><span class="line">    Q-&gt;rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出队：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q,ElemType *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p=Q-&gt;front-&gt;next;</span><br><span class="line">    *x=p-&gt;data;</span><br><span class="line">    Q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear==p)&#123;</span><br><span class="line">        Q-&gt;rear=Q-&gt;front;                 <span class="comment">//若原队列中只有一个结点，删除后变空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、双端队列"><a href="#四、双端队列" class="headerlink" title="四、双端队列"></a>四、双端队列</h3><ol><li>定义：允许两端都可以进行入队和出队操作的队列。</li><li>逻辑结构：线性结构</li><li>进队：前端进的元素排列在队列中后端进的元素前面，后端进的元素排列在队列中前端进的元素的后面。</li><li>出队：无论是前端还是后端出队，先出的元素排列在后出的元素的前面。</li><li>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。</li><li>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。</li></ol><h2 id="三、栈和队列的应用"><a href="#三、栈和队列的应用" class="headerlink" title="三、栈和队列的应用"></a>三、栈和队列的应用</h2><h3 id="一、栈在括号匹配中的应用"><a href="#一、栈在括号匹配中的应用" class="headerlink" title="一、栈在括号匹配中的应用"></a>一、栈在括号匹配中的应用</h3><ol><li>算法思想：<ul><li>初始设置一个空栈，顺序读入括号</li><li>若是右括号，则或者使置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）</li><li>若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性降了一级。</li><li>算法结束时，栈为空，否则括号序列不匹配。</li></ul></li></ol><h3 id="二、栈在表达式求值中的应用"><a href="#二、栈在表达式求值中的应用" class="headerlink" title="二、栈在表达式求值中的应用"></a>二、栈在表达式求值中的应用</h3><ol><li><p>中缀表达式转化为后缀表达式的过程：</p><ul><li><p>运算符优先级表：</p><table><thead><tr><th align="center">操作符</th><th align="center">#</th><th align="center">(</th><th align="center">*,/</th><th align="center">+,-</th><th align="center">)</th></tr></thead><tbody><tr><td align="center">isp</td><td align="center">0</td><td align="center">1</td><td align="center">5</td><td align="center">3</td><td align="center">6</td></tr><tr><td align="center">icp</td><td align="center">0</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">1</td></tr></tbody></table></li><li><p>操作方法：a+b-a*((c+d)/e-f)+g——&gt;ab+acd+e/f- *-g+</p></li></ul><table><thead><tr><th align="center">步骤</th><th align="center">扫描项</th><th align="center">项类型</th><th align="center">动作</th><th align="center">栈内内容</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">0</td><td align="center"></td><td align="center"></td><td align="center">‘#’进栈，读下一符号</td><td align="center">#</td><td align="center"></td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">+</td><td align="center">操作符</td><td align="center">isp(‘#’)&lt;icp(‘+’)，进栈</td><td align="center">#+</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">b</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#+</td><td align="center">b</td></tr><tr><td align="center">4</td><td align="center">-</td><td align="center">操作符</td><td align="center">isp(‘+’)&gt;icp(‘-‘)，退栈并输出</td><td align="center">#</td><td align="center">+</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center"></td><td align="center">isp(‘#’)&lt;icp(‘-‘)，进栈</td><td align="center">#-</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">a</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#-</td><td align="center">a</td></tr><tr><td align="center">7</td><td align="center">*</td><td align="center">操作符</td><td align="center">isp(‘-‘)&lt;icp(‘*’)，进栈</td><td align="center">#-*</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">(</td><td align="center">操作符</td><td align="center">isp(‘*’)&lt;icp(‘(‘)，进栈</td><td align="center">#-*(</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">(</td><td align="center">操作符</td><td align="center">isp(‘(‘)&lt;icp(‘(‘)，进栈</td><td align="center">#-*((</td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">c</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#-*((</td><td align="center">c</td></tr><tr><td align="center">11</td><td align="center">+</td><td align="center">操作符</td><td align="center">isp(‘(‘)&lt;icp(‘+’)，进栈</td><td align="center">#-*((+</td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">d</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#-*((+</td><td align="center">d</td></tr><tr><td align="center">13</td><td align="center">)</td><td align="center">操作符</td><td align="center">isp(‘+’)&gt;icp(‘)’)，退栈并输出</td><td align="center">#-*((</td><td align="center">+</td></tr><tr><td align="center">14</td><td align="center"></td><td align="center"></td><td align="center">isp(‘(‘)==icp(‘)’)，直接退栈</td><td align="center">#-*(</td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">/</td><td align="center">操作符</td><td align="center">isp(‘(‘)&lt;icp(‘/‘)，进栈</td><td align="center">#-*(/</td><td align="center"></td></tr><tr><td align="center">16</td><td align="center">e</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#-*(/</td><td align="center">e</td></tr><tr><td align="center">17</td><td align="center">-</td><td align="center">操作符</td><td align="center">isp(‘/‘)&gt;icp(‘-‘)，退栈并输出</td><td align="center">#-*(</td><td align="center">/</td></tr><tr><td align="center">18</td><td align="center"></td><td align="center"></td><td align="center">isp(‘(‘)&lt;icp(‘-‘)，进栈</td><td align="center">#-*(-</td><td align="center"></td></tr><tr><td align="center">19</td><td align="center">f</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#-*(-</td><td align="center">f</td></tr><tr><td align="center">20</td><td align="center">)</td><td align="center">操作符</td><td align="center">isp(‘-‘)&gt;icp(‘)’)，退栈并输出</td><td align="center">#-*(</td><td align="center">-</td></tr><tr><td align="center">21</td><td align="center"></td><td align="center"></td><td align="center">isp(‘(‘)==icp(‘)’)，直接退栈</td><td align="center">#-*</td><td align="center"></td></tr><tr><td align="center">22</td><td align="center">+</td><td align="center">操作符</td><td align="center">isp(‘*’)&gt;icp(‘+’)，退栈并输出</td><td align="center">#-</td><td align="center">*</td></tr><tr><td align="center">23</td><td align="center"></td><td align="center"></td><td align="center">isp(‘-‘)&gt;icp(‘+’)，退栈并输出</td><td align="center">#</td><td align="center">-</td></tr><tr><td align="center">24</td><td align="center"></td><td align="center"></td><td align="center">isp(‘#’)&lt;icp(‘+’)，进栈</td><td align="center">#+</td><td align="center"></td></tr><tr><td align="center">25</td><td align="center">g</td><td align="center">操作数</td><td align="center">直接输出</td><td align="center">#+</td><td align="center">g</td></tr><tr><td align="center">26</td><td align="center">#</td><td align="center">操作符</td><td align="center">isp(‘+’)&gt;icp(‘#’)，退栈并输出</td><td align="center">#</td><td align="center">+</td></tr><tr><td align="center">27</td><td align="center"></td><td align="center"></td><td align="center">isp(‘#’)==icp(‘#’)，退栈，结束</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li><p>后缀表达式求值过程：abcd-*+ef/-</p><table><thead><tr><th align="center">步</th><th align="center">扫描项</th><th align="center">项类型</th><th align="center">动作</th><th align="center">栈中内容</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">置空栈</td><td align="center">空</td></tr><tr><td align="center">2</td><td align="center">a</td><td align="center">操作数</td><td align="center">进栈</td><td align="center">a</td></tr><tr><td align="center">3</td><td align="center">b</td><td align="center">操作数</td><td align="center">进栈</td><td align="center">a,b</td></tr><tr><td align="center">4</td><td align="center">c</td><td align="center">操作数</td><td align="center">进栈</td><td align="center">a,b,c</td></tr><tr><td align="center">5</td><td align="center">d</td><td align="center">操作数</td><td align="center">进栈</td><td align="center">a,b,c,d</td></tr><tr><td align="center">6</td><td align="center">-</td><td align="center">操作符</td><td align="center">d,c退栈，计算c-d，结果R1进栈</td><td align="center">a,b,R1</td></tr><tr><td align="center">7</td><td align="center">*</td><td align="center">操作符</td><td align="center">R1,b退栈，计算b*R1，结果R2进栈</td><td align="center">a,R2</td></tr><tr><td align="center">8</td><td align="center">+</td><td align="center">操作符</td><td align="center">R2.a退栈，计算a+R2，结果R3进栈</td><td align="center">R3</td></tr><tr><td align="center">9</td><td align="center">e</td><td align="center">操作数</td><td align="center">进栈</td><td align="center">R3,e</td></tr><tr><td align="center">10</td><td align="center">f</td><td align="center">操作数</td><td align="center">进栈</td><td align="center">R3,e,f</td></tr><tr><td align="center">11</td><td align="center">/</td><td align="center">操作符</td><td align="center">f,e退栈，计算e/f，结果R4进栈</td><td align="center">R3,R4</td></tr><tr><td align="center">12</td><td align="center">-</td><td align="center">操作符</td><td align="center">R4,R3退栈，计算R3-R4，结果R5进栈</td><td align="center">R5</td></tr></tbody></table></li></ul></li></ol><h3 id="三、栈在递归中的应用"><a href="#三、栈在递归中的应用" class="headerlink" title="三、栈在递归中的应用"></a>三、栈在递归中的应用</h3><ul><li>思想：通过栈来实现将递归算法转换为非递归算法，避免递归次数过多造成栈溢出。</li></ul><h3 id="四、队列在层次遍历中的应用"><a href="#四、队列在层次遍历中的应用" class="headerlink" title="四、队列在层次遍历中的应用"></a>四、队列在层次遍历中的应用</h3><ul><li><p>算法思想：</p><ol><li><p>根结点入队</p></li><li><p>若队空，则所有结点遍历完成，结束遍历。否则重复3号操作。</p></li><li><p>队列中的第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回2号操作。</p></li></ol></li></ul><h3 id="五、队列在计算机系统中的应用"><a href="#五、队列在计算机系统中的应用" class="headerlink" title="五、队列在计算机系统中的应用"></a>五、队列在计算机系统中的应用</h3><ol><li>解决主机与外部设备之间速度不匹配的问题：<ul><li>设置一个缓冲区，该缓冲区就是一个队列</li></ul></li><li>解决由多用户引起的资源竞争问题：<ul><li>采用先来先服务（FCFS）策略，将它们按照时间先后排成一个队列。</li></ul></li></ol><h2 id="四、特殊矩阵的压缩存储"><a href="#四、特殊矩阵的压缩存储" class="headerlink" title="四、特殊矩阵的压缩存储"></a>四、特殊矩阵的压缩存储</h2><h3 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h3><ol><li>定义：数组是由n个<font color="red">相同类型</font>的<font color="red">数据元素</font>构成的<font color="red">有限序列</font>。每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。</li><li>数组和线性表的关系：数组是线性表的推广。一维数组可以视为一个线性表；二位数组可视为其元素也是定长线性表的线性表。</li></ol><h3 id="二、数组的存储结构"><a href="#二、数组的存储结构" class="headerlink" title="二、数组的存储结构"></a>二、数组的存储结构</h3><ol><li><p>一维数组：A[0…n-1]<br> $$<br> LOC(a_i)=LOC(a_0)+i\times L;(0\leq i&lt;n)<br> $$</p></li><li><p>二维数组：</p><ul><li><p>按行优先方式：<br>  $$<br>  LOC(a_{i,j})=LOC(a_{0,0})+\lbrack i\times(h_2+1)+j\rbrack\times L<br>  $$</p></li><li><p>按列优先方式：<br>  $$<br>  LOC(a_{i,j})=LOC(a_{0,0})+\lbrack j\times(h_1+1)+i\rbrack\times L<br>  $$</p></li></ul></li></ol><h3 id="三、矩阵的压缩存储"><a href="#三、矩阵的压缩存储" class="headerlink" title="三、矩阵的压缩存储"></a>三、矩阵的压缩存储</h3><ol><li><p>对称矩阵的压缩存储：</p><ul><li>策略：只存储主对角线和下三角区，因为aij==aji，所以可以很方便的将上三角区转化为下三角区。 </li></ul></li><li><p>三角矩阵：</p><ul><li>定义：下三角矩阵中，上三角区均为同一常量；上三角矩阵中，下三角区均为同一常量。</li><li>策略：存储主对角线和元素不同的区域，在最后增加一个存储空间存储常量。访问同一常量区时，直接访问数组最后一个元素。</li></ul></li><li><p>三对角矩阵：</p><ul><li><p>将三对角矩阵A中三条对角线上的元素按行优先方式存放在一维数组中。</p></li><li><p>已知aij，B中下标k=2i+j-3.</p></li><li><p>已知下标k，<br>  $$<br>  \begin{array}{l}3(i-1)-1&lt;k+1\leq3i-1\i\geq(k+2)/3\i=\left\lceil(k+2)/3\right\rceil\j=k-2i+3\end{array}<br>  $$</p></li></ul></li><li><p>稀疏矩阵：</p><ul><li>定义：非零元素的个数远小于0元素的个数。</li><li>存储方法：<ul><li>顺序存储（数组）：定义一个结构体，存放三元组&lt;i,j,v&gt;（i：行号；j：列号；v：值）</li><li>十字链表法：每行指针指向当前行第一个元素，若还有继续往下指；每列同样。</li></ul></li></ul></li></ol><h1 id="第四章：串"><a href="#第四章：串" class="headerlink" title="第四章：串"></a>第四章：串</h1><h2 id="一、串的定义和实现"><a href="#一、串的定义和实现" class="headerlink" title="一、串的定义和实现"></a>一、串的定义和实现</h2><h3 id="一、串的定义"><a href="#一、串的定义" class="headerlink" title="一、串的定义"></a>一、串的定义</h3><ol><li><p>定义：字符串简称串，是由<font color="red">零个或多个字符组成的有限序列</font>。</p></li><li><p>表示：<br> $$<br> S=’a_1a_2a_3…a_n’;\left(n\geq0\right)<br> $$<br> 其中S是串名，单引号内是串的值，可以是字母、数字或其他字符。n为串的长度，n=0时为空串。</p></li><li><p>子串：串中任意多个连续的字符组成的子序列称为该串的字串。</p></li><li><p>主串：包含子串的串称为主串。</p></li><li><p>位置：某个字符在串中的序号称为该字符在串中的位置。</p></li><li><p>空格串：由一个或多个空格组成的串，长度为空格的个数，不是空串。</p></li></ol><h3 id="二、串的存储结构"><a href="#二、串的存储结构" class="headerlink" title="二、串的存储结构"></a>二、串的存储结构</h3><ol><li><p>定长顺序存储表示：</p><ul><li><p>思想：类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。（定长数组）</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255               <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];             <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;                  <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>截断：超过预定义长度的串值会被舍去。</li></ul></li><li><p>串长的两种表达方式：</p><ul><li>定义一个length变量来存放串的长度。</li><li>在最后加上一个不计入串长的结束标记字符”\0”，此时串长为隐含值。</li></ul></li></ul></li><li><p>堆分配存储表示：</p><ul><li><p>思想：仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储结构在程序执行过程中动态分配。</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;              <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;            <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure></li><li><p>实现方式：利用malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来表示；若分配失败则返回NULL。已分配的空间可用free()释放掉。</p></li></ul></li><li><p>块链存储表示：</p><ul><li>思想：类似线性表的链式存储结构，也可采用链表方式存储串值。</li><li>实现方式：每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。</li></ul></li></ol><h3 id="三、串的基本操作"><a href="#三、串的基本操作" class="headerlink" title="三、串的基本操作"></a>三、串的基本操作</h3><ul><li>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。</li><li>StrCopy(&amp;T,S)：复制操作。由串S得到串T。</li><li>StrEmpty(S)：判空操作。若S为空串，返回1，否则返回0。</li><li>StrCompare(S,T)：比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。</li><li>StrLength(S)：求串长。返回串的元素个数。</li><li>SubString(&amp;Sub,S,pos,len)：求字串。用Sub返回串S中第pos个字符起长度为len的字串。</li><li>Concat(&amp;T,S1,S2)：串联接。用T返回由S1，S2联接而成的新串。</li><li>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</li><li>ClearString(&amp;S)：清空操作。将S变为空串。</li><li>DestroyString(&amp;S)：销毁串。将串S销毁。</li></ul><h2 id="二、串的模式匹配"><a href="#二、串的模式匹配" class="headerlink" title="二、串的模式匹配"></a>二、串的模式匹配</h2><h3 id="一、简单的模式匹配算法"><a href="#一、简单的模式匹配算法" class="headerlink" title="一、简单的模式匹配算法"></a>一、简单的模式匹配算法</h3><ol><li><p>模式匹配的定义：字串的定位操作通常称为串的模式匹配，它求的是字串在主串中的位置。</p></li><li><p>简单的模式匹配算法（暴力匹配）：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            i++; j++;                               <span class="comment">//继续比较后续字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                    <span class="comment">//指针后退继续比较</span></span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思想：从主串S的第一个字符开始，与模式串T的第一个字符比较，若相等，则继续比较；否则从主串的下一个字符开始重新和模式串进行比较。直到T中的每个字符依次与主串S中的一个连续字符串相匹配，则匹配成功，返回T中第一个字符在S中的位置；否则匹配失败，返回0.</p></li><li><p>时间复杂度：O(nm)</p></li></ol><h3 id="二、改进的模式匹配算法——KMP算法"><a href="#二、改进的模式匹配算法——KMP算法" class="headerlink" title="二、改进的模式匹配算法——KMP算法"></a>二、改进的模式匹配算法——KMP算法</h3><ol><li><p>前缀：除最后一个字符外，字符串的所有头部子串。</p></li><li><p>后缀：除第一个字符外，字符串的所有尾部子串。</p></li><li><p>next数组的含义：在子串的第j个字符与主串发生失配时，则调到字串的next[j]位置重新与主串当前位置进行比较。</p></li><li><p>next数组的公式：<br> $$<br> next\left[j\right]=\left{\begin{array}{c}0;;;;;;;;;;j=1\max\left{k\vert1&lt;k&lt;j;&amp;&amp;;‘p_1…p_{k-1}’=’p_{j-k+1}…p_{j-1}’\right};;;;;;;\mathrm{当集合不为空时}\1;;;;;;;;;\mathrm{其他情况}\end{array}\right.<br> $$<br> 简单来说，第一个字符的next=0，其余的next值为它前面字符串的前缀和后缀的最大匹配长度+1.</p></li><li><p>求next数组的代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i, ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>KMP算法的代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> next[T.length + <span class="number">1</span>];</span><br><span class="line">    get_next(T, next);                                     <span class="comment">//求next数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;                <span class="comment">//继续比较后继字符</span></span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];                                   <span class="comment">//模式串向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;                               <span class="comment">//匹配成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/next.gif" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/next.gif" srcset="data:image/png;base64,666" alt="next"></p></li><li><p>KMP的时间复杂度：O(m+n)</p><ul><li>O(m)是求KMP的时间复杂度。</li><li>O(n)是进行模式匹配的时间复杂度。</li></ul></li></ol><h3 id="三、KMP算法的进一步优化——nextval"><a href="#三、KMP算法的进一步优化——nextval" class="headerlink" title="三、KMP算法的进一步优化——nextval"></a>三、KMP算法的进一步优化——nextval</h3><ol><li><p>求nextval数组的代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            j++, i++;</span><br><span class="line">            <span class="keyword">if</span> (T.ch[i] != T.ch[j]) &#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 简单来说，就是从第二个字符开始，如果该字符与next[j]代表的字符相等，则他的nextval等于next[j]代表的字符的nextval，否则它的nextval等于它的next值。</p></li></ol><h1 id="第五章：树与二叉树"><a href="#第五章：树与二叉树" class="headerlink" title="第五章：树与二叉树"></a>第五章：树与二叉树</h1><h2 id="一、树的基本概念"><a href="#一、树的基本概念" class="headerlink" title="一、树的基本概念"></a>一、树的基本概念</h2><h3 id="一、树的定义"><a href="#一、树的定义" class="headerlink" title="一、树的定义"></a>一、树的定义</h3><ol><li>定义：树是n(n&gt;=0)个结点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：<ul><li>有且仅有一个特定的称为根的结点。</li><li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。</li></ul></li><li>特点：<ul><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点可以有零个或多个后继。</li></ul></li><li>结构：树是一种递归的数据结构。既是一种逻辑结构，同时也是一种分层结构。</li></ol><h3 id="二、基本术语"><a href="#二、基本术语" class="headerlink" title="二、基本术语"></a>二、基本术语</h3><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/image-20210430090338702.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/image-20210430090338702.png" srcset="data:image/png;base64,666"></p><ol><li>对于K结点：根A到结点K的唯一路径上的任意结点，称为结点K的<font color="red">祖先</font>。如B是K的祖先，K是B的<font color="red">子孙</font>。E是K的<font color="red">双亲</font>，K是E的<font color="red">孩子</font>。K和L互为兄弟。</li><li>度：<ul><li>结点的度：树中一个结点的孩子个数称为该结点的度。</li><li>树的度：树中结点的最大度数。</li></ul></li><li>结点：<ul><li>分支结点：度大于0的结点。</li><li>叶子结点：度为0的结点。</li><li>结点的层次：从树根开始定义，根结点为第一层，它的子结点为第二层，以此类推。双亲在同一层的结点互为堂兄弟。</li><li>结点的深度：从根结点开始自顶向下逐层累加的。</li><li>结点的高度：从叶结点开始自底向上逐层累加的。</li></ul></li><li>树的高度：树中结点的最大层数。</li><li>有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。</li><li>路径和路径长度：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。</li><li>森林：森林是m(m&gt;=0)棵互不相交的树的集合。</li></ol><h3 id="三、树的性质"><a href="#三、树的性质" class="headerlink" title="三、树的性质"></a>三、树的性质</h3><ol><li><p>树中的结点数等于所有结点的度数之和+1。</p></li><li><p>度为m的树中第i层上至多有m^(i-1)个结点(i&gt;=1)。</p></li><li><p>高度为h的m叉树最多有(m^h-1)/(m-1)个结点。</p></li><li><p>具有n个结点的m叉树的最小高度为<br> $$<br> \left\lceil\log_m(n(m-1)+1)\right\rceil<br> $$</p></li></ol><h2 id="二、二叉树的概念"><a href="#二、二叉树的概念" class="headerlink" title="二、二叉树的概念"></a>二、二叉树的概念</h2><h3 id="一、二叉树的定义及其主要特性"><a href="#一、二叉树的定义及其主要特性" class="headerlink" title="一、二叉树的定义及其主要特性"></a>一、二叉树的定义及其主要特性</h3><ol><li><p>特点：</p><ul><li>每个结点至多只有两棵子树</li><li>二叉树的子树有左右之分，次序不能任意颠倒。</li></ul></li><li><p>定义：二叉树是n(n&gt;=0)个结点的有限集合。</p><ul><li>或者为空二叉树，n==0</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树分别又是一棵二叉树。</li></ul></li><li><p>二叉树与度为2的有序树的区别：</p><ul><li>度为2的树至少有三个结点，而二叉树可以为空</li><li>度为2的有序树的孩子的左右次序是相对另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无序区分左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。</li></ul></li><li><p>几个特殊的二叉树：</p><ul><li><p>满二叉树：高度为h，含有(2^h-1)个结点的二叉树。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2.对于满二叉树的编号：<br>  $$<br>  \begin{array}{l}\mathrm{双亲}：\left\lfloor i/2\right\rfloor\\mathrm{左孩子}：2i\\mathrm{右孩子}：2i+1\end{array}<br>  $$</p></li><li><p>完全二叉树：高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中的编号为1~n的结点一一对应时，称为完全二叉树。其特点为：</p><ul><li>若i&lt;=n/2向上取整，则结点i为分支结点，否则为叶子结点。</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。</li><li>若有度为1的结点，则只可能有一个，且该结点只有左孩子没有右孩子。</li><li>按层次编号后，一旦出现某个结点（编号i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。</li><li>若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左右孩子都有。</li></ul></li><li><p>二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。</p></li><li><p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1.</p></li></ul></li><li><p>二叉树的性质：</p><ul><li><p>非空二叉树上的叶子结点数等于度为2的结点数+1，即<br>  $$<br>  n_0=n_2+1<br>  $$</p></li><li><p>非空二叉树上第k层上至多有2^(k-1)个结点（k&gt;=1）</p></li><li><p>高度为h的二叉树至多有2^h-1个结点（h&gt;=1）</p></li><li><p>对完全二叉树按从上到下、从左到右的顺序依次编号1，2，…，n，则有下列关系：</p><ul><li><p>当i&gt;1时，结点i的双亲的编号为（i/2）向下取整，即当i为偶数时，其双亲的编号为i/2，它是双亲的左孩子；当i为奇数时，其双亲的编号为（i-1）/2，它是双亲的右孩子。</p></li><li><p>当2i&lt;=n时，结点i的左孩子编号为2i，否则无左孩子。</p></li><li><p>当2i+1&lt;=n时，结点i的右孩子编号为2i+1，否则无右孩子。</p></li><li><p>结点i所在层次（深度）为<br>  $$<br>  \left\lfloor\log_2i\right\rfloor+1<br>  $$</p></li></ul></li><li><p>具有n个（n&gt;0）结点的完全二叉树的高度为<br>  $$<br>  \left\lfloor\log_2n\right\rfloor+1或\left\lceil\log_2(n+1)\right\rceil<br>  $$</p></li></ul></li></ol><h3 id="二、二叉树的存储结构"><a href="#二、二叉树的存储结构" class="headerlink" title="二、二叉树的存储结构"></a>二、二叉树的存储结构</h3><ol><li><p>顺序存储结构：</p><ul><li>定义：用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</li><li>比较适合完全二叉树和满二叉树，既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</li></ul></li><li><p>链式存储结构：</p><ul><li><p>定义：用链表结点来存储二叉树中的每个结点。</p></li><li><p>属性：</p><ul><li>data：数据域</li><li>lchild：左孩子</li><li>rchild：右孩子</li></ul></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">ElemType data;                            <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>           <span class="comment">//左、右指针域</span></span><br><span class="line">&#125;BiTNode,*BiTree;                              </span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="三、二叉树的遍历和线索二叉树"><a href="#三、二叉树的遍历和线索二叉树" class="headerlink" title="三、二叉树的遍历和线索二叉树"></a>三、二叉树的遍历和线索二叉树</h2><h3 id="一、二叉树的遍历"><a href="#一、二叉树的遍历" class="headerlink" title="一、二叉树的遍历"></a>一、二叉树的遍历</h3><ol><li><p>定义：按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。</p></li><li><p>先序遍历：</p><ul><li><p>操作过程：</p><ul><li>访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ul></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);                     <span class="comment">//访问根结点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);          <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);          <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归思路：</p><ol><li>沿着根一边遍历一边将左孩子入栈，直到左孩子为空。</li><li>栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不空，将右孩子转执行1.</li></ol></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder2</span><span class="params">(Bitree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);                      <span class="comment">//初始化栈S</span></span><br><span class="line">    Bitree p = T;                      <span class="comment">//p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span> (p || IsEmpty(S)) &#123;          <span class="comment">//栈不空或者p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;                       <span class="comment">//一路向左</span></span><br><span class="line">            visit(p);                  <span class="comment">//访问根结点</span></span><br><span class="line">            Push(S, p);                <span class="comment">//当前结点入栈</span></span><br><span class="line">            p = p-&gt;lchild;             <span class="comment">//左孩子不空，指向左孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop(S, p);                 <span class="comment">//出栈</span></span><br><span class="line">            p = p-&gt;rchild;             <span class="comment">//向右子树走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>中序遍历：</p><ul><li><p>操作过程：</p><ul><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ul></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);           <span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);                     <span class="comment">//访问根结点</span></span><br><span class="line">        InOrder(T-&gt;rchild);           <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归思路：</p><ol><li><p>沿着根的左孩子，依次入栈，直到左孩子为空</p></li><li><p>栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不空，将右子树转执行1.</p></li></ol></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder2</span><span class="params">(Bitree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);                      <span class="comment">//初始化栈S</span></span><br><span class="line">    Bitree p = T;                      <span class="comment">//p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span> (p || !IsEmpty(S)) &#123;         <span class="comment">//栈不空或者p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;                       <span class="comment">//一路向左</span></span><br><span class="line">            Push(S, p);                <span class="comment">//当前结点入栈</span></span><br><span class="line">            p = p-&gt;lchild;             <span class="comment">//左孩子不空，指向左孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop(S,p);                  <span class="comment">//出栈</span></span><br><span class="line">            visit(p);                  <span class="comment">//访问出栈结点</span></span><br><span class="line">            p=p-&gt;rchild;               <span class="comment">//向右子树走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>后序遍历：</p><ul><li><p>操作过程：</p><ul><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ul></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);          <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild);          <span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);                      <span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归思路：</p><ul><li>沿着根的左孩子，依次入栈，直到左孩子为空</li><li>读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1；否则，栈顶元素出栈并访问</li></ul></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder2</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    Bitree p=T,r=<span class="literal">NULL</span>;                            <span class="comment">//r为标记域，记录是否已被访问</span></span><br><span class="line">    <span class="keyword">while</span> (p||IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GetTop(S,p);                          <span class="comment">//访问栈顶元素</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)&#123;          <span class="comment">//若右子树存在且未被访问过</span></span><br><span class="line">                p=p-&gt;rchild;                      <span class="comment">//转向右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                Pop(S,p);                         <span class="comment">//否则，弹出结点</span></span><br><span class="line">                visit(p);                         <span class="comment">//访问当前结点</span></span><br><span class="line">                r=p;                              <span class="comment">//记录最近访问过的结点</span></span><br><span class="line">                p=<span class="literal">NULL</span>;                           <span class="comment">//结点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：p=NULL的作用：每次出栈访问完一个结点相当于遍历完以该结点为根的子树，需将p置NULL。</p></li></ul></li><li><p>层次遍历：</p><ul><li><p>操作过程：队列</p><ol><li>先将二叉树根结点入队</li><li>出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队，重复2.</li></ol></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);                            <span class="comment">//初始化辅助队列</span></span><br><span class="line">    Bitree p;</span><br><span class="line">    EnQueue(Q,T);                            <span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;                      <span class="comment">//如果队列非空</span></span><br><span class="line">        DeQueue(Q,p);                        <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);                            <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树非空</span></span><br><span class="line">            EnQueue(Q,p-&gt;lchild);            <span class="comment">//左子树根结点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;                 <span class="comment">//右子树非空</span></span><br><span class="line">            EnQueue(Q,p-&gt;rchild);            <span class="comment">//右子树根结点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>由遍历序列构造二叉树：</p><ul><li>先序+中序：先序第一个确定根结点，根据中序判断哪些结点在根结点左边，哪些在右边，然后写出二叉树。</li><li>后序+中序：后序最后一个确定根结点，根据中序判断哪些结点在根结点左边，哪些在右边，然后写出二叉树。</li><li>层次+中序：层次第一个是根结点，根据中序判断哪些结点在根结点左边，哪些在右边，然后写出二叉树。</li></ul></li></ol><h3 id="二、线索二叉树"><a href="#二、线索二叉树" class="headerlink" title="二、线索二叉树"></a>二、线索二叉树</h3><ol><li><p>线索二叉树的基本概念：</p><ol><li><p>引入：在含有n个结点的二叉树中，有n+1个空指针——&gt;可不可以用这些空指针存放指向前驱或后继的指针？</p></li><li><p>概念：在二叉树的基础上增加两个标记域ltag和rtag，当ltag为0时代表指向左孩子，为1时代表指向前驱；当rtag为0时代表指向右孩子，为1时代表指向后继。</p></li><li><p>线索链表代码实现：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;                            <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>       <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag;                           <span class="comment">//左、右线索标记</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>中序线索二叉树：</p><ul><li><p>构造：</p><ul><li>思想：附设指针pre指向刚刚访问过的结点，中序遍历二叉树，检查p的左指针是否为空，若为空则将它指向pre；检查pre的右指针是否为空，若为空则将它指向p。</li><li>代码实现：</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree p,ThreadTree *pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre);                       <span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;                           <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;                             <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            p-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;                                         <span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">        InThread(p-&gt;rchild,pre);                       <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历：</p><ul><li><p>求中序线索二叉树中中序序列下的第一个结点：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode* <span class="title function_">Firstnode</span><span class="params">(ThreadNode* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)                      <span class="comment">//指向最左下结点（不一定是叶子结点）</span></span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求中序线索二叉树中结点p在中序序列下的后继：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode* <span class="title function_">Nextnode</span><span class="params">(ThreadNode* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)                         <span class="comment">//还有右孩子，就指向右孩子</span></span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;                     <span class="comment">//rtag==1代表rchild为后继</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不含头结点的中序线索二叉树的中序遍历：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求中序线索二叉树中中序遍历下的最后一个结点：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode* <span class="title function_">Lastnode</span><span class="params">(ThreadNode* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求中序线索二叉树中结点p在中序遍历下的前驱：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode* <span class="title function_">Prenode</span><span class="params">(ThreadNode* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不含头结点的中序线索二叉树的逆遍历：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode* p = Lastnode(T); p != <span class="literal">NULL</span>; p = Prenode(p)) &#123;</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>先序线索二叉树：</p><ul><li><p>构造：</p><ul><li>代码实现：</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree p,ThreadTree *pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;                           <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;                             <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            p-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;                                         <span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        PreThread(p-&gt;lchild,pre);                   <span class="comment">//递归，线索化左子树                                 </span></span><br><span class="line">        PreThread(p-&gt;rchild,pre);                       <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>后序线索二叉树：</p><ul><li><p>构造：</p><ul><li>代码实现：</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree p,ThreadTree *pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostThread(p-&gt;lchild,pre);                       <span class="comment">//递归，线索化左子树</span></span><br><span class="line">        PostThread(p-&gt;rchild,pre);                       <span class="comment">//递归，线索化右子树</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;                           <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;                             <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            p-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;                                         <span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="四、树和森林"><a href="#四、树和森林" class="headerlink" title="四、树和森林"></a>四、树和森林</h2><h3 id="一、树的存储结构"><a href="#一、树的存储结构" class="headerlink" title="一、树的存储结构"></a>一、树的存储结构</h3><ol><li><p>双亲表示法：</p><ul><li><p>概念：采用一组连续空间来存储每个结点（顺序存储），同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置。</p></li><li><p>注：根结点下标为0，伪指针域为-1.</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 50             <span class="comment">//树中最多结点数量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                     <span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;                   <span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;                      <span class="comment">//双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                     <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];     <span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;                           <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure></li><li><p>添加操作：直接在最后添加新的结点信息即可</p></li><li><p>删除操作：</p><ul><li>将删除结点的双亲域改为-1并删除数据域，结点数-1</li><li>用最后一个结点的信息覆盖删除结点，结点数-1</li></ul></li><li><p>优点：查指定结点的双亲非常方便</p></li><li><p>缺点：查指定结点的孩子结点只能从头遍历</p></li></ul></li><li><p>孩子表示法：</p><ul><li><p>定义：将每个结点的孩子结点都用单链表连接起来形成一个线性结构。（顺序存储+链式存储）</p></li><li><p>实质：顺序存储每个结点，孩子结点链式存放。</p></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span>                      <span class="comment">//孩子链表</span></span><br><span class="line">    <span class="type">int</span> child;                      <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>            <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                     <span class="comment">//树中结点的定义</span></span><br><span class="line">    ElemType data;                  <span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>      <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                     <span class="comment">//树的类型定义</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];     <span class="comment">//孩子表示</span></span><br><span class="line">    <span class="type">int</span> n,r;                        <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></li><li><p>优点：查指定结点的孩子非常方便</p></li><li><p>缺点：查指定结点的双亲复杂</p></li></ul></li><li><p>孩子兄弟表示法：</p><ul><li><p>定义：以二叉链表作为树的存储结构。（链式存储）</p></li><li><p>三部分：</p><ul><li>结点值</li><li>指向结点第一个孩子结点的指针</li><li>指向结点下一个兄弟结点的指针</li></ul></li><li><p>代码实现：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;                                <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstChild</span>,*<span class="title">nextsibling</span>;</span>       <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、树、森林与二叉树的转换"><a href="#二、树、森林与二叉树的转换" class="headerlink" title="二、树、森林与二叉树的转换"></a>二、树、森林与二叉树的转换</h3><ol><li>树转换为二叉树：<ul><li>规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟。</li><li>注：根结点没有兄弟，所以对应的二叉树没有右子树。</li><li>画法：<ul><li>在兄弟结点之间加一连线</li><li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉。</li><li>以树根为轴心，顺时针旋转45度</li></ul></li></ul></li><li>森林转换为二叉树：<ul><li>规则：先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必为空，则把森林中第二课树根视为第一棵树根的右兄弟，以此类推。</li><li>画法：<ul><li>将森林中的每棵树转换成相应的二叉树</li><li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线</li><li>以第一棵树的根为轴心顺时针旋转45度</li></ul></li></ul></li><li>二叉树转换为森林：<ul><li>规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样地方法，直到最后一棵没有右子树的二叉树为止，再将每棵二叉树依次转换成树，就得到了原森林。</li></ul></li></ol><h3 id="三、树和森林的遍历"><a href="#三、树和森林的遍历" class="headerlink" title="三、树和森林的遍历"></a>三、树和森林的遍历</h3><ol><li>树的遍历：<ul><li>先根遍历：<ul><li>规则：若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。</li><li>遍历序列与相应二叉树的先序序列相同</li></ul></li><li>后根遍历：<ul><li>规则：若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。</li><li>遍历序列与相应二叉树的<font color="red">中序序列</font>相同</li></ul></li><li>层次遍历（队列实现）：<ol><li>若树非空，则根结点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复2直到队列为空</li></ol></li><li>注：<ul><li>层次遍历也称为树的广度优先遍历</li><li>先根遍历和后根遍历也称为树的深度优先遍历</li></ul></li></ul></li><li>森林的遍历：<ul><li>先序遍历：<ul><li>规则：<ul><li>访问森林中第一棵树的根结点</li><li>先序遍历第一棵树中根结点的子树森林</li><li>先序遍历除去第一棵树之后剩余树构成的森林</li></ul></li><li>实质：<ul><li>等同于依次对各个树进行先根遍历</li><li>等同于对应二叉树的先序遍历</li></ul></li></ul></li><li>中序遍历：<ul><li>规则：<ul><li>中序遍历森林中的一棵树的根结点的子树森林</li><li>访问第一棵树的根结点</li><li>中序遍历除去第一棵树之后剩余的树构成的森林</li></ul></li><li>实质：<ul><li>等同于依次对各个树进行后根遍历</li><li>等同于对应二叉树的中序遍历</li></ul></li></ul></li></ul></li></ol><h2 id="五、树和二叉树的应用"><a href="#五、树和二叉树的应用" class="headerlink" title="五、树和二叉树的应用"></a>五、树和二叉树的应用</h2><h3 id="一、二叉排序树"><a href="#一、二叉排序树" class="headerlink" title="一、二叉排序树"></a>一、二叉排序树</h3><ol><li><p>特性：</p><ul><li>若左子树非空，则左子树上所有结点的值均小于根结点的值</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值</li><li>左、右子树也分别是一棵二叉排序树</li></ul></li><li><p>优点：通过中序遍历可以得到一个递增的有序序列</p></li><li><p>二叉排序树的查找：</p><ul><li><p>思路：若树非空，目标值与根结点比较：若相等，则查找成功；若小于根结点，则在左子树上查找，否则在右子树上查找。</p></li><li><p>代码实现：空间复杂度：O(1)</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BSTNode* <span class="title function_">BST_Search</span><span class="params">(BStree T, ElemType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;key) &#123;           <span class="comment">//若树非空并且查找值不等于根结点的值</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;                        <span class="comment">//小于，则向左子树查找</span></span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                   <span class="comment">//大于，则向右子树查找</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找成功返回结点指针，查找失败返回NULL。</p></li><li><p>递归实现：空间复杂度：O(h)</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTNode* <span class="title function_">BSTSearch</span><span class="params">(BStree T,ElemType key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                              <span class="comment">//查找失败</span></span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;                                 <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);          <span class="comment">//递归左子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);          <span class="comment">//递归右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二叉排序树的插入：</p><ul><li><p>思想：若原二叉树为空，则直接插入结点；否则，若关键字小于根结点值，则插入到左子树；若关键字大于根结点值，则插入到右子树。</p></li><li><p>递归实现：空间复杂度O(h)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BST_Insert</span><span class="params">(BStree &amp;T,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;                                   <span class="comment">//原树为空</span></span><br><span class="line">        T=(BStree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key=key;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==T-&gt;key)&#123;                          <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;                           <span class="comment">//插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                           <span class="comment">//插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二叉排序树的构造：</p><ul><li><p>思想：不断插入</p></li><li><p>代码实现：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat_BST</span><span class="params">(BStree &amp;T,ElemType str[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>;                                             <span class="comment">//初始T为空</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="built_in">BST_Insert</span>(T,str[i]);                           <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二叉排序树的删除：</p><ol><li>若被删除结点x是叶子结点，则直接删除</li><li>若结点x只有一棵左子树或右子树，则让x的子树称为x父结点的子树，代替x的位置</li><li>若x有左右两棵子树，则令x的直接后继（或直接前驱）替代x，然后从二叉排序树中删除这个直接后继（直接前驱），就会转变成1或2.</li></ol></li><li><p>二叉排序树的查找效率：</p><ul><li><p>查找长度：在查找运算中，需要对比关键字的次数——反映了查找操作时间复杂度</p></li><li><p>查找成功的平均查找长度ASL：<br>  $$<br>  ASL=\sum_{i=1}^{树的高度}\left(每一排结点个数\times该层层数\right)\div结点总数<br>  $$</p></li><li><p>时间复杂度：</p><ul><li><p>最好情况：<br>  $$<br>  O(log_2n)<br>  $$</p></li><li><p>最坏情况：O(n)</p></li></ul></li><li><p>查找失败的平均查找长度ASL：</p><ul><li>补齐每个叶子结点的左右孩子</li></ul><p>  $$<br>  ASL=\sum_{最低深度}^{最高深度}\left(每一排补充结点个数\times该层层数\right)\div结点总数<br>  $$</p></li></ul></li></ol><h3 id="二、平衡二叉树"><a href="#二、平衡二叉树" class="headerlink" title="二、平衡二叉树"></a>二、平衡二叉树</h3><ol><li><p>定义：树上任一结点的左子树和右子树的高度之差不超过1.</p></li><li><p>结点的平衡因子：左子树高-右子树高</p></li><li><p><font color="red">平衡二叉树结点的平衡因子的值只可能是-1，0，1</font></p></li><li><p>代码实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">    ElemType key;                           <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> balance;                            <span class="comment">//平衡因子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild,*rchild;</span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure></li><li><p>平衡二叉树的插入：</p><ol><li>最小不平衡子树：插入路径上里插入结点最近的平衡因子中大于1的结点为根的子树。</li><li>调整最小不平衡子树：<ul><li>LL平衡旋转：<ul><li>条件：在结点A的左孩子(L)的左子树(L)上插入了新结点，导致以A为根的子树失去平衡</li><li>解决方法：进行一次向右旋转，将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。</li><li>图解：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/LL.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/LL.png" srcset="data:image/png;base64,666" alt="LL"></li></ul></li><li>RR平衡旋转：<ul><li>条件：在结点A的右孩子(R)的右子树(R)上插入了新结点，导致以A为根的子树失去平衡</li><li>解决方法：进行一次向左旋转，将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。</li><li>图解：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/RR.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/RR.png" srcset="data:image/png;base64,666" alt="RR"></li></ul></li><li>LR平衡旋转：<ul><li>条件：在A的左孩子(L)的右子树(R)上插入新结点，导致以A为根的子树失去平衡。</li><li>解决方法：进行两次旋转操作，先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后把该C结点向右上旋转提升到A结点的位置。</li><li>图解：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/LR.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/LR.png" srcset="data:image/png;base64,666" alt="LR"></li></ul></li><li>RL平衡旋转：<ul><li>条件：在A的右孩子(R)的左子树(L)上插入新结点，导致以A为根的子树失去平衡。</li><li>解决方法：进行两次旋转操作，先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后把该C结点向左上旋转提升到A结点的位置。</li><li>图解：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/RL.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/RL.png" srcset="data:image/png;base64,666" alt="RL"></li></ul></li></ul></li></ol></li><li><p>平衡二叉树的查找效率：</p><ul><li><p>时间复杂度：O(h)</p></li><li><p>深度为h的平衡树中最少结点数的公式：(n0=0,n1=1,n2=2)<br>  $$<br>  n_h=n_{h-1}+n_{h-2}+1<br>  $$</p></li></ul></li></ol><h3 id="三、哈夫曼树"><a href="#三、哈夫曼树" class="headerlink" title="三、哈夫曼树"></a>三、哈夫曼树</h3><ol><li><p>哈夫曼树的定义：</p><ul><li><p>结点的权：有某种现实含义的数值。</p></li><li><p>结点的带权路径长度：从树的根结点到该结点的路径长度（经过的边数）与该结点上权值的乘积。</p></li><li><p>树的带权路径长度WPL：树中所有叶子结点的带权路径之和。<br>  $$<br>  WPL=\sum_{i=1}^{n}{w_il_i}<br>  $$</p></li><li><p>哈夫曼树：</p><ul><li>定义：在含有n个带权叶子结点的二叉树中，其中WPL最小的二叉树。</li><li>性质：<ul><li>每个初始结点最终都成为叶子结点，且权值越小的结点到根结点的路径长度越大。</li><li>构造过程中共新建了n-1个结点，总结点数为2n-1.</li><li>哈夫曼树中不存在度为1的结点。</li><li>哈夫曼树不唯一，但WPL必然相同且为最优。</li></ul></li></ul></li></ul></li><li><p>哈夫曼树的构造：</p><ol><li><p>将n个结点分别作为n棵仅含一个几点的二叉树，形成森林F。</p></li><li><p>构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</p></li><li><p>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</p></li><li><p>重复2、3步骤，直至F中只剩下一棵树。</p></li></ol></li><li><p>哈夫曼编码：</p><ul><li>定义：字符集中的每个祖父字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前的方法构造哈夫曼树。</li><li>左0右1</li><li>哈夫曼编码不唯一，但是WPL一定相同且最优</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章：绪论&quot;&gt;&lt;a href=&quot;#第一章：绪论&quot; class=&quot;headerlink&quot; title=&quot;第一章：绪论&quot;&gt;&lt;/a&gt;第一章：绪论&lt;/h1&gt;&lt;h2 id=&quot;一、数据结构的基本概念&quot;&gt;&lt;a href=&quot;#一、数据结构的基本概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="专业课" scheme="https://www.oliverbryant.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Operating_System</title>
    <link href="https://www.oliverbryant.cn/2021/04/23/Operating-System/"/>
    <id>https://www.oliverbryant.cn/2021/04/23/Operating-System/</id>
    <published>2021-04-23T02:45:52.000Z</published>
    <updated>2021-04-23T02:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：计算机系统概述"><a href="#第一章：计算机系统概述" class="headerlink" title="第一章：计算机系统概述"></a>第一章：计算机系统概述</h1><h2 id="一、操作系统的基本概念"><a href="#一、操作系统的基本概念" class="headerlink" title="一、操作系统的基本概念"></a>一、操作系统的基本概念</h2><h3 id="一、操作系统的概念"><a href="#一、操作系统的概念" class="headerlink" title="一、操作系统的概念"></a>一、操作系统的概念</h3><ol><li>计算机系统：自下而上分为：<ul><li>硬件</li><li>操作系统：管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的媒介。</li><li>应用程序</li><li>用户</li></ul></li><li>操作系统的定义：是控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。<font color="red">操作系统是计算机系统中最基本的系统软件</font>。</li></ol><h3 id="二、操作系统的特征"><a href="#二、操作系统的特征" class="headerlink" title="二、操作系统的特征"></a>二、操作系统的特征</h3><ul><li>并发：<ul><li>定义：两个或多个事件在<font color="red">同一时间间隔内</font>发生。</li><li>实质：在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行。操作系统的并发性实际是通过<font color="red">分时</font>得以实现的</li><li>并行：<ul><li>定义：系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。</li><li>需要相关硬件的支持，如多流水线或多处理机硬件环境</li></ul></li></ul></li><li>共享：<ul><li>定义：系统中的资源可供内存中多个并发执行的进程共同使用。</li><li>分类：<ul><li>互斥共享方式：<ul><li>定义：在一段时间内只允许一个进程访问该资源。</li><li>举例：打印机、磁带机</li><li>过程：进程A需要访问某个资源<font color="orange">（称为临界资源或独占资源）</font>，先提出请求。若该资源空闲，则系统将其分配给A使用。此后有其他进程也要访问该资源，只要A没有使用完成就必须等待。仅当A访问完并释放该资源后，才允许另一个进程对该资源进行访问。</li></ul></li><li>同时访问方式：<ul><li>定义：允许在一段时间内由多个进程“同时”访问。</li><li>实质：宏观上“同时”，微观上“分时”</li><li>举例：磁盘设备，一些用重入码编写的文件</li></ul></li></ul></li></ul></li></ul><p><font color="green"><b>并发与共享的关系：两者是操作系统两个最基本的特征，两者之间互为存在的条件</b></font></p><ol><li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。</li><li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li></ol><ul><li>虚拟：<ul><li>定义：把一个物理上的实体变为若干逻辑上的对应物。</li><li>举例：<ul><li>虚拟处理器：<ul><li>定义：利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU。</li><li>原理：通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器。</li></ul></li><li>虚拟存储器：<ul><li>定义：用户感觉到的但是实际不存在的存储器</li><li>原理：采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。</li></ul></li><li>虚拟外部设备：采用虚拟设备技术将一台物理I/O设备虚拟为多态逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备。</li></ul></li><li>虚拟技术的分类：<ul><li>时分复用技术：处理器的分时共享</li><li>空分复用技术：虚拟存储器</li></ul></li></ul></li><li>异步：<ul><li>定义：由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。</li></ul></li></ul><h3 id="三、操作系统的目的和功能"><a href="#三、操作系统的目的和功能" class="headerlink" title="三、操作系统的目的和功能"></a>三、操作系统的目的和功能</h3><ol><li>操作系统作为计算机系统资源的管理者：<ul><li>处理机管理：<ul><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>死锁处理</li><li>处理机调度</li></ul></li><li>存储器管理：<ul><li>内存分配与回收</li><li>地址映射</li><li>内存保护</li><li>共享和内存扩充</li></ul></li><li>文件管理：<ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件读写管理和保护</li></ul></li><li>设备管理：<ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li><li>虚拟设备</li></ul></li></ul></li><li>操作系统作为用户与计算机硬件系统之间的接口：<ul><li>命令接口：用户利用这些操作命令来组织和控制作业的执行<ul><li>联机命令接口：<ul><li>联机控制方式进行作业控制，适用于分时或实施系统的接口。</li></ul></li><li>脱机命令接口：<ul><li>脱机控制方式进行作业控制，适用于批处理系统，由一组作业控制命令组成。</li></ul></li></ul></li><li>程序接口（系统调用）：<ul><li>编程人员可以使用它们来请求操作系统服务。</li><li>由一组系统调用组成，它是操作系统为应用程序使用内核功能所提供的接口。</li><li>广义指令：系统调用命令</li></ul></li></ul></li><li>操作系统用作扩充机器：操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器。因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</li></ol><h3 id="四、注"><a href="#四、注" class="headerlink" title="四、注"></a>四、注</h3><ol><li><p>库函数：高级语言中提供的与系统调用对应的函数（也有些库函数与系统调用无关），目的是隐藏”访管“指令的细节，使系统调用更为方便、抽象。库函数属于用户程序而非系统调用，是系统调用的上层。</p></li><li><p>库函数与系统调用的区别和联系：</p><p> 库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态的转换（由用户态转向核心态）</p></li></ol><h2 id="二、操作系统的发展与分类"><a href="#二、操作系统的发展与分类" class="headerlink" title="二、操作系统的发展与分类"></a>二、操作系统的发展与分类</h2><h3 id="一、手工操作阶段"><a href="#一、手工操作阶段" class="headerlink" title="一、手工操作阶段"></a>一、手工操作阶段</h3><ol><li>定义：用户在计算机上算题的所有工作都要人工干预。</li><li>缺点：<ul><li>用户独占全机</li><li>CPU等待手工操作，CPU的利用不充分</li></ul></li></ol><h3 id="二、批处理阶段"><a href="#二、批处理阶段" class="headerlink" title="二、批处理阶段"></a>二、批处理阶段</h3><ol><li>单道批处理系统：<ul><li>定义：引入脱机输入/输出技术，并由监督程序<font color="orange">（操作系统的雏形）</font>负责控制作业的输入、输出。</li><li>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li><li>缺点：<ul><li>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。</li><li>CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。</li></ul></li></ul></li><li>多道批处理系统：<ul><li>定义：每次往内存中读入多道程序，<font color="red">操作系统正式诞生，用于支持多道程序并发运行</font>。</li><li>特点：<ul><li>多道：</li><li>宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</li><li>微观上串行：内存中的多道程序轮流占有CPU，交替执行。</li></ul></li><li>优点：<ul><li>多道程序并发执行，共享计算机资源。</li><li>资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</li></ul></li><li>缺点： <ul><li>用户响应时间长，没有人机交互功能</li></ul></li></ul></li></ol><h3 id="三、分时操作系统"><a href="#三、分时操作系统" class="headerlink" title="三、分时操作系统"></a>三、分时操作系统</h3><ol><li>定义：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</li><li>特点：<ul><li>同时性</li><li>交互性</li><li>独立性</li><li>及时性</li></ul></li><li>优点：<ul><li>用户请求可以被即时响应，解决了人机交互问题。</li><li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li></ul></li><li>缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li></ol><h3 id="四、实时操作系统"><a href="#四、实时操作系统" class="headerlink" title="四、实时操作系统"></a>四、实时操作系统</h3><ol><li>定义：在实时操作系统的控制下，计算机系统接受到外部信号后及时处理，并在严格的时限内处理完事件。</li><li>特点：<ul><li>及时性</li><li>可靠性</li></ul></li><li>优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</li><li>分类：<ul><li>硬实时系统：必须在绝对严格的规定时间内完成处理<ul><li>导弹控制系统</li><li>自动驾驶系统</li></ul></li><li>软实时系统：能接受偶尔违反时间规定<ul><li>12306火车订票系统</li></ul></li></ul></li></ol><h3 id="五、网络操作系统"><a href="#五、网络操作系统" class="headerlink" title="五、网络操作系统"></a>五、网络操作系统</h3><ol><li>定义：能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。</li></ol><h3 id="六、分布式操作系统"><a href="#六、分布式操作系统" class="headerlink" title="六、分布式操作系统"></a>六、分布式操作系统</h3><ol><li>定义：系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</li><li>特点：<ul><li>分布性</li><li>并行性</li></ul></li></ol><h3 id="七、个人计算机操作系统"><a href="#七、个人计算机操作系统" class="headerlink" title="七、个人计算机操作系统"></a>七、个人计算机操作系统</h3><ul><li>Windows</li><li>Linux</li><li>MacOS</li></ul><h2 id="三、操作系统的运行环境"><a href="#三、操作系统的运行环境" class="headerlink" title="三、操作系统的运行环境"></a>三、操作系统的运行环境</h2><h3 id="一、操作系统的运行机制"><a href="#一、操作系统的运行机制" class="headerlink" title="一、操作系统的运行机制"></a>一、操作系统的运行机制</h3><ol><li>指令：CPU能识别、执行的最基本命令。（二进制）</li><li>内核程序和应用程序：<ul><li>内核（kernel）：内核是操作系统最重要最核心的部分，也是最接近硬件的部分。由许多内核程序组成。可以运行特权指令。<font color="orange">（I/O指令、置中断指令等等）</font></li><li>应用程序：运行于操作系统之上的程序。只能运行非特权指令。</li></ul></li><li>内核态与用户态：<ul><li>内核态：<ul><li>定义：处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令。</li><li>别名：核心态、管态</li></ul></li><li>用户态：<ul><li>定义：处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令。</li><li>别名：目态</li></ul></li><li>内核态与用户态的切换：CPU中有一个寄存器叫<font color="red">程序状态字寄存器（PSW）</font>，其中有个二进制位，1表示“内核态”，0表示“用户态”。<ul><li>内核态—&gt;用户态：执行一条<font color="red">特权指令——修改PSW</font>的标志位为“用户态”</li><li>用户态—&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。</li></ul></li></ul></li><li>内核内容：<ul><li>时钟管理：<ul><li>计时</li><li>时钟中断：实现进程的切换</li></ul></li><li>中断机制：<ul><li>目的：提高多道程序运行环境中CPU的利用率<font color="orange">（主要是针对外部设备）</font></li><li>作用：保护和恢复中断现场的信息，转移控制权到相关的处理程序</li></ul></li><li>原语：<ul><li>定义：具有以下特点的程序称为原语（Atomic Operation）</li><li>特点：<ul><li>处于操作系统的最底层，是最接近硬件的部分</li><li>这些程序的运行具有原子性，其操作只能是一气呵成。<font color="orange">（主要从系统安全性和便于管理考虑）</font></li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul></li><li>定义方法：关闭中断，让其所有动作都不可分割地完成后再打开中断。</li></ul></li><li>系统控制的数据结构及处理：<ul><li>进程管理：进程状态管理、进程调度和分配、创建与撤销进程控制块</li><li>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序</li><li>设备管理：缓冲区管理、设备分配和回收</li></ul></li></ul></li></ol><h3 id="二、中断和异常"><a href="#二、中断和异常" class="headerlink" title="二、中断和异常"></a>二、中断和异常</h3><ol><li>中断的概念：在CPU上会运行两种程序，一种是<font color="red">应用程序</font>，一种是<font color="red">操作系统内核程序</font>。在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。而“中断”是让操作系统内核夺回CPU使用权的唯一途径。</li><li>中断的分类：<ul><li>内中断（异常）：<ul><li>定义：与当前执行的指令有关，中断信号来源于CPU内部</li><li>类型：<ul><li>陷阱、陷入（trap）：由陷入指令引发，是应用程序故意引发的</li><li>故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让他继续执行下去。<font color="orange">（缺页故障）</font></li><li>终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。<font color="orange">（整数除0、非法使用特权指令）</font></li></ul></li></ul></li><li>外中断（中断）：<ul><li>定义：与当前执行的指令无关，中断信号来自CPU外部</li><li>类型：<ul><li>时钟中断</li><li>I/O中断请求</li></ul></li></ul></li></ul></li><li>中断处理的过程：<ul><li>关中断：CPU响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU不应响应更高级中断源的中断请求。否则，若现场保存不完整，中断服务程序结束后，不能正确地恢复并继续执行现行程序。</li><li>保存断点：为保证中断服务程序执行完毕后能正确地回到原来的程序，必须将原来的程序的断点（程序计数器PC）保存起来。</li><li>中断服务程序寻址：取出中断服务程序的入口地址送入程序计数器PC。</li><li>保存现场和屏蔽字：进入中断服务程序后，首先要保存现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容。</li><li>开中断：允许更高级中断请求得到响应。</li><li>执行中断服务程序：中断请求的目的。</li><li>关中断：保证在恢复现场和屏蔽字时不被中断。</li><li>恢复现场和屏蔽字：将现场和屏蔽字恢复到原来的状态。</li><li>开中断，中断返回：中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</li></ul></li></ol><h3 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h3><ol><li><p>定义：用户在程序中调用操作系统所提供的一些子功能，可视为特殊的公共子程序，<font color="red">应用程序可以通过系统调用来请求获得操作系统内核的服务</font>。</p></li><li><p>何时用：凡是与共享资源有关的操作（存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求。</p></li><li><p>目的：保证系统的稳定性和安全性。</p></li><li><p>分类：</p><ul><li>设备管理：完成设备的请求/释放/启动等功能</li><li>文件管理：完成文件的读/写/创建/删除等功能</li><li>进程控制：完成进程的创建/撤销/阻塞/唤醒等功能</li><li>进程通信：完成进程之间的消息传递/信号传递等功能</li><li>内存管理：完成内存的分配/回收等功能</li></ul></li><li><p>系统调用的过程：</p><ul><li>传递系统调用参数</li><li>执行陷入指令<font color="red">（用户态）</font></li><li>运行相应的内请求核程序处理系统调用<font color="red">（核心态）</font></li><li>返回应用程序</li></ul><p> 注：</p><ol><li>陷入指令是在用户态执行的，执行陷入指令后引发一个内中断，使CPU进入核心态</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li></ol></li></ol><h2 id="四、操作系统的体系结构"><a href="#四、操作系统的体系结构" class="headerlink" title="四、操作系统的体系结构"></a>四、操作系统的体系结构</h2><ol><li>大内核：<ul><li>定义：将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而应用提高性能的系统服务。</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li><li>典型系统：Linux、Unix</li></ul></li><li>微内核：<ul><li>定义：将内核中最基本的功能保留在内核，将那些不需要在核心态执行的功能移到用户态执行。</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li><li>典型系统：Windows NT</li></ul></li></ol><h1 id="第二章：进程管理"><a href="#第二章：进程管理" class="headerlink" title="第二章：进程管理"></a>第二章：进程管理</h1><h2 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h2><h3 id="一、进程的概念和特征"><a href="#一、进程的概念和特征" class="headerlink" title="一、进程的概念和特征"></a>一、进程的概念和特征</h3><ol><li><p>定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p></li><li><p>组成：</p><ul><li>进程控制块（PCB）：进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收PCB。<font color="red">操作系统对进程进行管理工作所需的信息都在PCB中</font><ul><li>进程描述信息：<ul><li>进程标识符PID</li><li>用户标识符UID</li></ul></li><li>进程控制和管理信息：<ul><li>CPU、磁盘、网络流量使用情况统计…</li><li>进程当前状态</li></ul></li><li>资源分配清单：<ul><li>正在使用哪些文件</li><li>正在使用哪些内存区域</li><li>正在使用哪些I/O设备</li></ul></li><li>处理机相关信息：<ul><li>如PSW、PC等各种寄存器的值<font color="orange">（用于实现进程切换）</font></li></ul></li></ul></li><li>程序段：程序的代码<font color="orange">（指令序列）</font></li><li>数据段：运行过程中产生的各种数据</li></ul><p> <font color="green">PCB是给操作系统用的，程序段、数据段是给进程自己用的。</font></p></li><li><p>特征：</p><ul><li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的。<font color="red">动态性是进程最基本的特征</font></li><li>并发性：内存中有多个进程实体，各进程可并发执行。</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位。</li><li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步性。</li><li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段和PCB组成。</li></ul></li></ol><h3 id="二、进程的状态与转换"><a href="#二、进程的状态与转换" class="headerlink" title="二、进程的状态与转换"></a>二、进程的状态与转换</h3><ol><li><p>五种状态：</p><ul><li>创建态（New）：<ul><li>定义：进程正在被创建</li><li>步骤：<ul><li>申请一个空白的PCB</li><li>向PCB中填写一些控制和管理进程的信息</li><li>由系统为该进程分配运行时所必须的资源</li><li>把该进程转入就绪态</li></ul></li></ul></li><li><font color=green>就绪态</font>（Ready）：<ul><li>定义：进程获得了除处理机外的一切所需资源。一旦得到处理机，便可立即运行。</li><li>注：系统中处于就绪态的进程可以有多个，通常把它们排成一个队列，称为就绪队列。</li></ul></li><li><font color=green>运行态</font>（Running）：<ul><li>定义：进程正在处理机上运行，CPU会执行该进程对应的程序<font color="orange">（执行指令序列）</font>。</li><li>注：在单核CPU环境下，每个时刻最多有一个进程处于运行态。</li></ul></li><li><font color=green>阻塞态</font>（Waiting/Blocked）：<ul><li>定义：进程正在等待某一事件而暂停运行。</li><li>注：即使处理机空闲，该进程也不能运行。</li></ul></li><li>终止态（Terminated）：<ul><li>定义：进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。</li><li>步骤：<ul><li>将该进程置为终止态</li><li>进程下CPU，并回收内存空间等资源</li><li>回收该进程的PCB</li></ul></li></ul></li></ul><p> <font color="green">上述标绿的为3种基本状态</font></p></li><li><p>3种基本状态的转换：</p><ul><li>就绪态——&gt;运行态：处于就绪态的进程被调度后，获得处理机资源</li><li>运行态——&gt;就绪态：<ul><li>处于运行态的进程在时间片用完后，不得不让出处理机</li><li>在可剥夺的操作系统中，被更高优先级的进程抢占</li></ul></li><li>运行态——&gt;阻塞态：<ul><li>进程请求某一资源的使用和分配或等待某一事件的发生</li><li>注：此种转换是进程自身作出的<font color="red">主动行为</font>。</li></ul></li><li>阻塞态——&gt;就绪态：<ul><li>进程等待的事件到来</li><li>注：此种转换是<font color="red">被动行为</font>，需要其他相关进程的协助。</li></ul></li></ul><p> <img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="data:image/png;base64,666" alt="进程状态"></p></li></ol><h3 id="三、进程控制"><a href="#三、进程控制" class="headerlink" title="三、进程控制"></a>三、进程控制</h3><ol><li><p>功能：对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p></li><li><p>进程控制的实现：原语</p><ul><li>原语的执行具有原子性，期间不允许被中断。</li><li>通过“关中断指令”和“开中断指令”两条<font color="red">特权指令</font>实现。</li><li>CPU在执行关中断指令后，不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</li></ul></li><li><p>进程的创建：</p><ul><li>创建原语：操作系统创建一个进程时使用的原语，会将进程从创建态转入就绪态<ul><li>为新进程分配一个唯一的进程标识号，并申请空白PCB</li><li>为新进程分配所需资源。<font color="red">若资源不足，不会创建失败，而是进入阻塞态</font>。</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul></li><li>引起进程创建的事件：<ul><li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul></li></ul></li><li><p>进程的终止：</p><ul><li>撤销原语：操作系统终止一个进程时使用的原语，会将进程从就绪态/阻塞态/运行态变为终止态。<ul><li>从PCB集合中找到终止进程的PCB，读出该进程的状态</li><li>若该进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程所用由的全部资源，归还给父进程或操作系统</li><li>删除PCB</li></ul></li><li>引起进程终止的事件：<ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul></li></ul></li><li><p>进程的阻塞</p><ul><li>阻塞原语：将进程从运行态变为阻塞态<ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件：<ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li><p>进程的唤醒：</p><ul><li>唤醒原语：将进程从阻塞态转为就绪态<ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列中移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件：等待的事件发生</li></ul><p> <font color="green">注：因何事阻塞，就应由何事唤醒，故阻塞原语唤醒原语必须成对使用。</font></p></li><li><p>进程的切换：</p><ul><li>切换原语：将进程从运行态变为就绪态，或从就绪态变为运行态<ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，并更新其PCB</li><li>更新内存管理的数据结构</li><li>恢复处理机上下文</li></ul></li><li>引起进程切换的事件：<ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul></li></ol><h3 id="四、进程通信"><a href="#四、进程通信" class="headerlink" title="四、进程通信"></a>四、进程通信</h3><ol><li>进程通信的概念：进程之间的信息交换。</li><li>共享存储：<ul><li>定义：在通信的进程之间存在一块可以直接访问的共享空间<font color="orange">（由操作系统提供）</font>，<font color="red">两个进程对共享空间的访问必须互斥<font color="orange">（互斥访问通过操作系统提供的工具实现）</font></font></li><li>基于数据结构的共享：速度慢，限制多，低级通信方式</li><li>基于存储区的共享：<ul><li>在内存中画出一块共享存储区。</li><li>速度快，高级通信方式</li></ul></li></ul></li><li>管道通信：<ul><li>定义：管道（pipe）是指用于连接读写进程的一个共享文件，其实就是在内存中开辟的一个大小固定的缓冲区。</li><li>管道只能采用<font color="red">半双工通信</font>，某一时间段只能实现单向的传输。如果要实现双向同时通信，则需设置两个管道。</li><li>各进程要互斥地访问管道</li><li>数据以<font color="red">字符流</font>的形式写入管道，当管道写满时，写进程的write()系统调用被阻塞，等待度进程将数据取走；当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读；如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这意味着<font color="red">读进程最多只能有一个</font>。</li></ul></li><li>消息传递：<ul><li>定义：进程见的数据交换以<font color="red">格式化的消息（Message）</font>为单位，通过操作系统提供的”发送消息/接受消息“两个原语进行数据交换</li><li>消息：<ul><li>消息头：包括发送进程ID、接收进程ID、消息类型、消息长度等格式化的信息</li><li>消息体</li></ul></li><li>类型：<ul><li>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</li><li>简介通信方式：消息要先发送到中间实体<font color="orange">（信箱）</font>中</li></ul></li></ul></li></ol><h3 id="五、线程概念和多线程模型"><a href="#五、线程概念和多线程模型" class="headerlink" title="五、线程概念和多线程模型"></a>五、线程概念和多线程模型</h3><ol><li><p>线程的概念：”轻量级进程“，是一个基本的CPU执行单元，也是程序执行流的最小单位。</p></li><li><p>与进程的比较：</p><table><thead><tr><th align="center">变化</th><th align="center">进程</th><th align="center">线程</th></tr></thead><tbody><tr><td align="center">调度</td><td align="center">进程时用由资源和独立调度的基本单位</td><td align="center">线程是独立调度的基本单位，进程是资源分配的基本单位</td></tr><tr><td align="center">并发性</td><td align="center">只能进程间并发</td><td align="center">既能进程间并发，也可线程间并发</td></tr><tr><td align="center">系统开销</td><td align="center">进程间并发，需要切换进程的运行环境，系统开销大</td><td align="center">线程间并发，若为统一进程内线程切换，则不需切换进程环境，系统开销小</td></tr></tbody></table></li><li><p>线程的属性：</p><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，每个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块TCB</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>统一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预</li><li>同一进程中线程切换，不会引起进程切换，系统开销很小</li><li>不同进程中的线程切换，会引起进程切换，系统开销较大</li></ul></li><li><p>线程的实现方式：</p><ul><li>用户级线程：<ul><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责</li><li>线程切换在用户态下即可完成，无需操作系统干预</li><li>在用户看来，是有多个线程。在操作系统内核看来，只有进程。</li><li>优点：线程切换不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li></ul></li><li>内核级线程：<ul><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>操作系统会为每个内核级线程建立相应的TCB，通过TCB对线程进行管理。</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul></li></ul></li><li><p>多线程模型：</p><ul><li>一对一模型：<ul><li>定义：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程。</li><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul></li><li>多对一模型：<ul><li>定义：多个用户级线程映射到一个内核级线程，即一个进程只被分配一个内核级线程。</li><li>优点：线程切换不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li></ul></li><li>多对多模型：<ul><li>定义：n个用户级线程映射到m个内核级线程<font color="red">（n&gt;=m）</font>。每个用户进程对应m个内核级线程。</li><li>特点：克服了多对一模型并发度不高的特点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li></ul></li></ul></li></ol><h2 id="二、处理机调度"><a href="#二、处理机调度" class="headerlink" title="二、处理机调度"></a>二、处理机调度</h2><h3 id="一、调度的概念"><a href="#一、调度的概念" class="headerlink" title="一、调度的概念"></a>一、调度的概念</h3><ol><li><p>定义：对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发地运行。</p></li><li><p>调度的层次：</p><ul><li>高级调度（作业调度）：<ul><li>主要任务：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。</li><li>特点：<ul><li>每个作业只调入一次，调出一次。调入时建立PCB，调出时撤销PCB。</li><li>执行频率较低，通常是几分钟一次</li></ul></li></ul></li><li>中级调度（内存调度）：<ul><li>主要任务：内存不够时，将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</li><li>特点：<ul><li>一个进程可能会被多次调出、调入内存</li><li>执行频率比高级调度高</li></ul></li><li>暂时调到外存等待的进程状态为<font color=red>挂起状态</font>。被挂起的进程PCB会被组织成<font color=red>挂起队列</font>。</li></ul></li><li>低级调度（进程调度）：<ul><li>主要任务：按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</li><li>特点：<ul><li>进程调度是操作系统中<font color=red>最基本的一种调度</font>，在一般的操作系统中必须配置进程调度。</li><li>执行频率很高，一般几十毫秒一次</li></ul></li></ul></li></ul></li><li><p>进程的挂起态和七状态模型：</p><ul><li>暂时调到外存等待的进程状态为挂起状态（挂起态，Suspend）</li><li>挂起态又可进一步细分为就绪挂起、阻塞挂起两种状态。</li><li>七状态模型：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,666" alt="七状态模型"></li><li>挂起和阻塞都是暂时不能获得CPU服务，但是挂起态是将进程映像调到外存去了，而阻塞态进程映像还在内存中</li></ul></li><li><p>三种调度的联系与对比：</p><table><thead><tr><th align="center"></th><th align="center">要做什么</th><th align="center">调度发生位置</th><th align="center">发生频率</th><th align="center">对进程状态的影响</th></tr></thead><tbody><tr><td align="center">高级调度</td><td align="center">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td align="center">外存—&gt;内存</td><td align="center">最低</td><td align="center">无—&gt;创建态—&gt;就绪态</td></tr><tr><td align="center">中级调度</td><td align="center">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td align="center">外存—&gt;内存</td><td align="center">中等</td><td align="center">挂起态—&gt;就绪态</td></tr><tr><td align="center">低级调度</td><td align="center">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td align="center">内存—&gt;CPU</td><td align="center">最高</td><td align="center">就绪态—&gt;运行态</td></tr></tbody></table></li></ol><h3 id="二、进程调度的时机、切换和过程"><a href="#二、进程调度的时机、切换和过程" class="headerlink" title="二、进程调度的时机、切换和过程"></a>二、进程调度的时机、切换和过程</h3><ol><li>时机：<ul><li>需要进行进程调度与切换的情况：<ul><li>当前运行的进程主动放弃处理机：<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞</li></ul></li><li>当前运行的进程被动放弃处理机：<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li>不能进行进程调度与切换的情况：<ul><li>在处理中断的过程中：中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在操作系统内核程序临界区中<ul><li>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</li><li>临界区：访问临界资源的那段代码。</li><li>内核临界区：用来访问某种内核数据结构</li></ul></li><li>在原子操作过程中（原语）：原子操作不可中断</li></ul></li></ul></li><li>方式：<ul><li>非剥夺调度方式（非抢占方式）：<ul><li>定义：只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li><li>优点：实现简单，系统开销小</li><li>缺点：无法及时处理紧急任务</li></ul></li><li>剥夺调度方式（抢占方式）：<ul><li>定义：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的进程。</li><li>优点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（时钟中断）</li></ul></li></ul></li><li>进程的切换与过程：<ul><li>狭义的进程调度：从就绪队列中选中一个要运行的进程。</li><li>进程切换：让一个进程让出处理机，由另一个进程占用处理机。 <ul><li>步骤：<ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ul></li><li>进程切换是有代价的，如果过于频繁进行进程调度、切换，必然会使整个系统的效率降低。</li></ul></li><li>广义的进程调度：包含选择和进程切换两个步骤。</li></ul></li></ol><h3 id="三、调度算法的评价指标"><a href="#三、调度算法的评价指标" class="headerlink" title="三、调度算法的评价指标"></a>三、调度算法的评价指标</h3><ol><li><p>CPU利用率：</p><ul><li><p>定义：CPU“忙碌”的时间占总时间的比例。</p></li><li><p>公式：<br>$$<br>利用率=\frac{忙碌的时间}{总时间}<br>$$</p></li></ul></li><li><p>系统吞吐量：</p><ul><li><p>定义：单位时间内完成作业的数量</p></li><li><p>公式：<br>$$<br>系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}<br>$$</p></li></ul></li><li><p>周转时间：</p><ul><li><p>定义：从作业被提交给系统开始，到作业完成为止这段时间间隔。</p></li><li><p>包括：</p><ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列上等待进程调度（低级调度）的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I/O操作完成的时间</li></ul></li><li><p>公式：</p><ul><li><p>周转时间：<br>$$<br>周转时间=作业完成时间-作业提交时间<br>$$</p></li><li><p>平均周转时间：<br>$$<br>平均周转时间=\frac{各作业周转时间之和}{作业数}<br>$$</p></li><li><p>带权周转时间：<br>$$<br>带权周转时间=\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}<br>$$</p></li><li><p>平均带权周转时间：<br>$$<br>平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}<br>$$</p></li></ul></li></ul></li><li><p>等待时间：</p><ul><li>定义：进程/作业等待处理机状态时间之和，等待时间越长，用户满意度越低。<ul><li>进程：等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li><li>作业：不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</li></ul></li></ul></li><li><p>响应时间：</p><ul><li>定义：用户从提交请求到首次产生响应所用的时间。</li></ul></li></ol><h3 id="四、调度算法"><a href="#四、调度算法" class="headerlink" title="四、调度算法"></a>四、调度算法</h3><ol><li><p>先来先服务（FCFS）：</p><ul><li>算法思想：主要从“公平”的角度考虑</li><li>算法规则：按照作业/进程到达的先后顺序进行服务</li><li>用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。</li><li>是否可抢占：非抢占式的算法</li><li>优点：公平、算法实现简单</li><li>缺点：排在长作业（进程）后面的短作业需要等待很长的时间，带权周转时间很大，对短作业来说用户体验不好</li><li>是否会导致饥饿：不会</li></ul></li><li><p>短作业优先（SJF）：</p><ul><li>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</li><li>算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</li><li>用于作业/进程调度：既可用于作业调度，也可用于进程调度。<font color=orange>（用于进程调度时称为“短进程优先算法”，SPF）</font></li><li>是否可抢占：SJF和SPF是非抢占式的算法。但是也有可抢占式的版本——最短剩余时间优先算法（SRTN）</li><li>优点：“最短的”平均等待时间、平均周转时间</li><li>缺点：<ul><li>不公平，对短作业有利，对长作业不利。</li><li>可能产生饥饿现象</li><li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</li></ul></li><li>是否会导致饥饿：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。</li></ul></li><li><p>高响应比优先（HRRN）：</p><ul><li><p>算法思想：综合考虑作业/进程的等待时间和要求服务的时间</p></li><li><p>算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。<br>$$<br>响应比=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p></li><li><p>用于作业/进程调度：既可用于作业调度，也可用于进程调度</p></li><li><p>是否可抢占：非抢占式的算法。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。</p></li><li><p>优点：</p><ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。</li></ul></li><li><p>是否会导致饥饿：不会</p></li></ul><p><font color=green>注：以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是交互性很差。因此这三种算法一般适合早期的批处理系统。</font></p></li><li><p>时间片轮转（RR）：</p><ul><li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</li><li>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>用于作业/进程调度：用于进程调度。<font color=orange>（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</font></li><li>是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。<font color=orange>由时钟装置发出时钟中断来通知CPU时间片已到</font>。</li><li>优点：<ul><li>公平</li><li>响应快，适合于分时操作系统</li></ul></li><li>缺点：<ul><li>由于高频率的进程切换，因此有一定开销</li><li>不区分任务的紧急程度</li></ul></li><li>是否会导致饥饿：不会</li><li>补充：<ul><li>若时间片太大，则几乎变成FCFS</li><li>若时间片太小，则大部分时间用于进程切换，浪费资源</li></ul></li></ul></li><li><p>优先级调度：</p><ul><li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li><li>算法规则：调度时选择优先级最高的作业/进程</li><li>用于作业/进程调度：既可用于作业调度，也可用于进程调度。</li><li>是否可抢占：抢占式、非抢占式都有</li><li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。</li><li>是否会导致饥饿：会</li><li>补充：<ul><li>就绪队列未必只有一个，可以按照不同优先级来组织；也可把优先级高的进程排在更靠近队头的位置。</li><li>优先级的分类：<ul><li>静态优先级：创建进程时确定，之后就一直不变</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级</li></ul></li><li>系统进程优先级高于用户进程</li><li>前台进程优先级高于后台进程</li><li>操作系统更偏好<font color=red>I/O型进程</font></li><li>动态优先级调整原则：<ul><li>如果某进程在就绪队列等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可以适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可以适当提升其优先级</li></ul></li></ul></li></ul></li><li><p>多级反馈队列调度：</p><ul><li>算法思想：对其他调度算法的折中权衡</li><li>算法规则：<ul><li>设置多个就绪队列，各队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进若第一级队列，按FCFS原则排队等待被分配时间片；若使用完时间片进程还未结束，则进程进入下一级队列队尾。若此时已经在最下级队列，则重新放回该队列队尾。</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ul></li><li>用于作业/进程调度：用于进程调度</li><li>是否可抢占：抢占式的算法。<font color=orange>在k级队列的进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</font>。</li><li>优点：对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程。</li><li>是否会导致饥饿：会</li></ul></li></ol><h2 id="三、进程同步"><a href="#三、进程同步" class="headerlink" title="三、进程同步"></a>三、进程同步</h2><h3 id="一、进程同步的基本概念"><a href="#一、进程同步的基本概念" class="headerlink" title="一、进程同步的基本概念"></a>一、进程同步的基本概念</h3><ol><li><p>同步：</p><ul><li>定义：亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</li></ul></li><li><p>临界资源：</p><ul><li><p>定义：一次仅允许一个进程使用的资源称为临界资源。</p></li><li><p>临界资源的访问过程：</p><ul><li>进入区：为了进入临界区使用临界资源，进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志<font color=orange>（上锁）</font>，以阻止其他进程同时进入临界区。</li><li>临界区：进程中访问临界资源的那段代码，也称临界段。</li><li>退出区：将正在访问临界区的标志清楚<font color=orange>（解锁）</font>。</li><li>剩余区：代码中的其余部分。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">entry section;           <span class="comment">//进入区</span></span><br><span class="line">critical section;        <span class="comment">//临界区</span></span><br><span class="line"><span class="built_in">exit</span> section;            <span class="comment">//退出区</span></span><br><span class="line">remainder section;       <span class="comment">//剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>互斥：</p><ul><li>定义：亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界进程。</li><li>同步机制应遵循的规则：<ul><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul></li></ul></li></ol><h3 id="二、实现临界区互斥的基本方法"><a href="#二、实现临界区互斥的基本方法" class="headerlink" title="二、实现临界区互斥的基本方法"></a>二、实现临界区互斥的基本方法</h3><ol><li><p>软件实现方法：</p><ul><li><p>单标志法：</p><ul><li><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说，每个进程进入临界区的权限只能被另一个进程赋予。</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn=<span class="number">0</span>; <span class="comment">//turn表示当前允许进入临界区的进程号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程：</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程：</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></li><li><p>优点：同一时刻最多只允许一个进程访问临界区</p></li><li><p>缺点：违反“空闲让进”原则</p></li></ul></li><li><p>双标志先检查法：</p><ul><li><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];          <span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;       <span class="comment">//刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程：</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);        <span class="comment">//如果此时P0想进入临界区，P1就一直等待</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;        <span class="comment">//标记为P0进程想要进入临界区</span></span><br><span class="line">critical section;      <span class="comment">//访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;       <span class="comment">//访问完临界区，修改标记为P0不想使用临界区</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程：</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></li><li><p>优点：解决了“忙则等待”的问题</p></li><li><p>缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象</p></li></ul></li><li><p>Peterson算法：</p><ul><li><p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试先让对方使用。</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;                   <span class="comment">//标记为P0进程想要进入临界区</span></span><br><span class="line">turn = <span class="number">1</span>;                         <span class="comment">//表示可以先让对方使用</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn==<span class="number">1</span>);</span><br><span class="line">critical section;                 <span class="comment">//访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;                  <span class="comment">//访问完临界区，修改标记为P0不想使用临界区</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程：</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn==<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></li><li><p>优点：解决了“空闲让进”、“忙则等待”、“有限等待”三个原则</p></li><li><p>缺点：违背了“让权等待”原则</p></li></ul></li></ul></li><li><p>硬件实现方法：</p><ul><li><p>中断屏蔽方法：</p><ul><li><p>思想：利用“开/关中断指令”实现。</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br></pre></td></tr></table></figure></li><li><p>优点：简单、高效</p></li><li><p>缺点：</p><ul><li>不适用于多处理机</li><li>只适用于操作系统内核进程，不适用于用户进程</li></ul></li></ul></li><li><p>TestAndSet指令</p><ul><li><p>思想：通过硬件实现，这条指令时原子操作，即执行该代码时不允许被中断。</p></li><li><p>功能：读出指定标志后把该标志设为true</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span>&#123;    <span class="comment">//布尔型共享变量lock表示当前临界区是否被加锁，true表示已加锁，false表示未加锁</span></span><br><span class="line">    <span class="type">bool</span> old;</span><br><span class="line">    old = *lock;                 <span class="comment">//old用来存放lock原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>;                <span class="comment">//无论之前是否已加锁，都将lock设为true</span></span><br><span class="line">    <span class="keyword">return</span> old;                  <span class="comment">//返回lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet (&amp;lock));       <span class="comment">//上锁并检查</span></span><br><span class="line">临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;                    <span class="comment">//解锁</span></span><br><span class="line">剩余区代码段;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul></li><li><p>缺点：不满足“让权等待”原则</p></li></ul></li><li><p>Swap指令（Exchang、XCHG）</p><ul><li><p>思想：通过硬件实现，这条指令时原子操作，即执行该代码时不允许被中断。</p></li><li><p>功能：交换两个字的内容</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Swap</span> <span class="params">(<span class="type">bool</span> *a,<span class="type">bool</span> *b)</span>&#123;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)</span><br><span class="line">    Swap (&amp;lock,&amp;old);</span><br><span class="line">临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul></li><li><p>缺点：不满足“让权等待”原则</p></li></ul></li></ul></li></ol><h3 id="三、信号量机制"><a href="#三、信号量机制" class="headerlink" title="三、信号量机制"></a>三、信号量机制</h3><ol><li><p>信号量：一个变量，可以是一个整数，也可以是更复杂的记录型变量。可以用一个信号量来表示系统中某种资源的数量。</p></li><li><p>原语：一种特殊的程序段，只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。</p></li><li><p>P、V操作：wait(S)和signal(S)原语的简称。</p></li><li><p>整型信号量：</p><ul><li><p>定义：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;                <span class="comment">//初始化整形变量S，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span>&#123;        <span class="comment">//wait原语，相当于“进入区”</span></span><br><span class="line">    <span class="keyword">while</span> (S&lt;=<span class="number">0</span>);         <span class="comment">//如果资源数不够，就一直循环等待</span></span><br><span class="line">    S = S<span class="number">-1</span>;              <span class="comment">//如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span>&#123;      <span class="comment">//signal原语，相当于“退出区”</span></span><br><span class="line">    S = S+<span class="number">1</span>;              <span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</p></li><li><p>缺点：不满足“让权等待”原则，会发生“忙等”</p></li></ul></li><li><p>记录型信号量：</p><ul><li><p>定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;             <span class="comment">//如果资源数不够</span></span><br><span class="line">        block(S.L);              <span class="comment">//使用block原语使进程进入阻塞态，并挂到信号量S的等待队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;              <span class="comment">//释放资源后，若还有别的进程在等待这种资源</span></span><br><span class="line">        wakeup(S.L);             <span class="comment">//使用wakeup原语唤醒等待队列中的一个进程，使其从阻塞态变为运行态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：实现了“让权等待”原则</p></li></ul></li><li><p>信号量机制实现进程互斥：</p><ul><li><p>概念：</p><ul><li>设置互斥信号量mutex，初值为1</li><li>在进入区P(mutex)──申请资源</li><li>在退出区V(mutex)──释放资源</li></ul></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;    <span class="comment">//初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);           <span class="comment">//设置临界资源前需要加锁</span></span><br><span class="line">    临界区代码;</span><br><span class="line">    V(mutex);           <span class="comment">//使用临界资源后需要解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);</span><br><span class="line">    临界区代码;</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>对不同的临界资源需要设置不同的互斥信号量</li><li>P、V操作必须成对出现。<ul><li>缺少P(mutex)不能保证临界资源的互斥访问</li><li>缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒</li></ul></li></ul></li></ul></li><li><p>信号量机制实现进程同步：</p><ul><li><p>概念：</p><ul><li>设置同步信号量S，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在”后操作“之后执行P(S)</li></ul></li><li><p>实现：保证代码2在代码4之前执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S);</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>信号量机制实现前驱关系：</p><ul><li><p>方法：</p><ul><li>为每一对前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行V操作</li><li>在”后操作“之后对相应的同步信号量执行P操作</li></ul></li><li><p>例图：<img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/qq.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/qq.png" srcset="data:image/png;base64,666" alt="前驱"></p></li><li><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1=a2=b1=b2=c=d=e=0;</span><br><span class="line">S1()&#123;</span><br><span class="line">...;</span><br><span class="line">V(a1);</span><br><span class="line">V(a2);</span><br><span class="line">&#125;</span><br><span class="line">S2()&#123;</span><br><span class="line">P(a1);</span><br><span class="line">...;</span><br><span class="line">V(b1);</span><br><span class="line">V(b2);</span><br><span class="line">&#125;</span><br><span class="line">S3()&#123;</span><br><span class="line">P(a2);</span><br><span class="line">...;</span><br><span class="line">V(e);</span><br><span class="line">&#125;</span><br><span class="line">S4()&#123;</span><br><span class="line">P(b1);</span><br><span class="line">...;</span><br><span class="line">V(c);</span><br><span class="line">&#125;</span><br><span class="line">S5()&#123;</span><br><span class="line">P(b2);</span><br><span class="line">...;</span><br><span class="line">V(d);</span><br><span class="line">&#125;</span><br><span class="line">S6()&#123;</span><br><span class="line">P(c);</span><br><span class="line">P(d);</span><br><span class="line">P(e);</span><br><span class="line">...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、生产者消费者问题"><a href="#四、生产者消费者问题" class="headerlink" title="四、生产者消费者问题"></a>四、生产者消费者问题</h3><ol><li><p>问题描述：</p><ul><li>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。</li><li>生产者、消费者共享一个初始为空、大小为n的缓冲区</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</li><li>只要缓冲区不空时，消费者才能从中取出产品，否则必须等待</li><li>缓冲区是临界资源，各进程必须互斥地访问</li></ul></li><li><p>分析步骤：</p><ul><li>关系分析：找出题目中描述的各个进程，分析他们之间的同步、互斥关系。</li><li>整理思路：根据各进程的操作流程确定P、V操作的大致顺序。</li><li>设置信号量：根据题目条件确定信号量初值。<font color=orange>（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</font></li></ul></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;               <span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;               <span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;                <span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>实现互斥的P操作一定要在实现同步的P操作之后</li><li>V操作可以互换位置</li><li>使用产品和生产产品也可以放入互斥之间，只是会使得临界区代码冗杂，导致上锁时间加长</li></ul></li></ol><h3 id="五、多生产者多消费者问题"><a href="#五、多生产者多消费者问题" class="headerlink" title="五、多生产者多消费者问题"></a>五、多生产者多消费者问题</h3><ol><li><p>问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line">semaphore plate = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">dad()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个苹果;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把苹果放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个橘子;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把橘子放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple);</span><br><span class="line">    P(mutex);</span><br><span class="line">        从盘中取出苹果;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);</span><br><span class="line">        吃苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        P(mutex);</span><br><span class="line">        从盘中取出橘子;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);</span><br><span class="line">        吃橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>在多生产者多消费者中，如果缓冲区大小为1，那么<font color=red>有可能</font>不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。</li><li>不应该从“进程”的角度分析事件，应该从“事件”的角度来考虑。</li></ul></li></ol><h3 id="六、吸烟者问题"><a href="#六、吸烟者问题" class="headerlink" title="六、吸烟者问题"></a>六、吸烟者问题</h3><ol><li><p>问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复。（让三个抽烟者轮流抽烟）</p></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                将组合一放桌上;</span><br><span class="line">                V(offer1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                将组合二放桌上;</span><br><span class="line">                V(offer2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                将组合三放桌上;</span><br><span class="line">                V(Offer3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        从桌上拿走组合一;</span><br><span class="line">        卷烟;</span><br><span class="line">        抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        从桌上拿走组合二;</span><br><span class="line">        卷烟;</span><br><span class="line">        抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        从桌上拿走组合三;</span><br><span class="line">        卷烟;</span><br><span class="line">        抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="七、读者──写者问题"><a href="#七、读者──写者问题" class="headerlink" title="七、读者──写者问题"></a>七、读者──写者问题</h3><ol><li><p>问题描述：有读者和写者两组并发进程，共享一个文件。当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ul><li>允许多个读者可以同时对文件执行读操作</li><li>只允许一个写者往文件中写信息</li><li>任一写者在完成写操作之前不允许其他读者或写者工作</li><li>写者执行写操作前，应让已有的读者和写者全部退出</li></ul></li><li><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;       <span class="comment">//用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;          <span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;    <span class="comment">//用于保证对count变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);        <span class="comment">//写之前加锁</span></span><br><span class="line">        写文件;</span><br><span class="line">        V(rw);        <span class="comment">//写完了解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);         <span class="comment">//各进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)      <span class="comment">//由第一个读进程负责</span></span><br><span class="line">            P(rw);        <span class="comment">//读之前加锁</span></span><br><span class="line">        count++;          <span class="comment">//访问文件的进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        读文件;</span><br><span class="line">        P(mutex);         <span class="comment">//各进程互斥访问count</span></span><br><span class="line">        count--;          <span class="comment">//访问文件的进程数-1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)      <span class="comment">//由最后一个读进程负责</span></span><br><span class="line">            V(rw);        <span class="comment">//读完了解锁</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li><p>只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。<font color=orange>实际在这种情况下，读进程有更高的优先级</font></p></li><li><p>解决措施：读写公平法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore w = <span class="number">1</span>;          <span class="comment">//用于实现“写优先”</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);</span><br><span class="line">        写文件;</span><br><span class="line">        V(rw);</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            P(rw);</span><br><span class="line">        count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件;</span><br><span class="line">        P(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            V(rw);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="八、哲学家进餐问题"><a href="#八、哲学家进餐问题" class="headerlink" title="八、哲学家进餐问题"></a>八、哲学家进餐问题</h3><ol><li><p>问题描述：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。</p></li><li><p>实现：</p><ul><li><p>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        吃饭;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        思考;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要求奇数号哲学家先拿左边的筷子，再拿右边的筷子，而偶数号哲学家刚好相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">            P(chopstick[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        吃饭;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        思考;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一名哲学家两边都有筷子时，才允许他拿起筷子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        思考;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="九、管程"><a href="#九、管程" class="headerlink" title="九、管程"></a>九、管程</h3><ol><li><p>管程的定义：</p><ul><li>概念：利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程，这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，叫做管程。</li><li>组成：<ul><li>管程的名称</li><li>局部于管程内部的共享结构数据说明</li><li>对该数据结构进行操作的一组过程（函数）</li><li>对局部于管程内部的共享数据设置初始值的语句</li></ul></li><li>特征：<ul><li>需要在管程中定义共享数据</li><li>需要在管程中定义用于访问这些共享数据的“入口”，即函数</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但每次只能开放其中一个“入口”，并且只能让一个进程或线程进入在管程内部执行某个内部过程。</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li></ul></li></ul></li><li><p>用管程解决生产者消费者问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;         <span class="comment">//条件变量用来实现同步</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;                 <span class="comment">//缓冲区中的产品数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span>         <span class="comment">//把产品item放入缓冲区</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == N)</span><br><span class="line">            <span class="built_in">wait</span>(full);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">insert_item</span>(item);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">signal</span>(empty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">(Item item)</span>         <span class="comment">//从缓冲区中取出一个产品</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">wait</span>(empty);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == N - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">signal</span>(full);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">remove_item</span>();</span><br><span class="line">    &#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProducerConsumer.<span class="built_in">insert</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">consumer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = ProducerConsumer.<span class="built_in">remove</span>();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="四、死锁"><a href="#四、死锁" class="headerlink" title="四、死锁"></a>四、死锁</h2><h3 id="一、死锁的概念"><a href="#一、死锁的概念" class="headerlink" title="一、死锁的概念"></a>一、死锁的概念</h3><ol><li><p>定义：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p></li><li><p>死锁、饥饿、死循环的区别：</p><ul><li>死锁：各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。</li></ul><table align="center">    <tr>        <th></th><th>共同点</th><th>区别</th>    </tr>    <tr>        <td>死锁</td><td rowspan="3">都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手中的资源”导致的，因此如果有死锁现象，那<font color=red>至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。</font></td>    </tr>    <tr>        <td>饥饿</td><td><font color=red>可能只有一个进程发生饥饿。</font>发生饥饿的进程既可能时阻塞态，也可能时就绪态。</td>    </tr>    <tr>        <td>死循环</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<font color=red>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题。</font></td>    </tr></table></li><li><p>死锁产生的原因：</p><ul><li>死锁产生的必要条件：<font color=red>必须同时满足下列四个条件</font><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>请求和保持条件：进程已经至少保持了至少一个资源，但又提除了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul></li><li>对系统资源的竞争：各进程对不可剥夺的资源的竞争可能引起死锁。</li><li>进程推进顺序非法</li></ul></li><li><p>死锁的处理策略：</p><ul><li>预防死锁：破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ul></li></ol><h3 id="二、死锁预防"><a href="#二、死锁预防" class="headerlink" title="二、死锁预防"></a>二、死锁预防</h3><ol><li>破坏互斥条件：<ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</li><li>方法：把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li><li>举例：SPOOLing技术</li><li>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候无法破坏互斥条件。</li></ul></li><li>破坏不剥夺条件：<ul><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>方法：<ul><li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。</li><li>当某个进程需要的资源被其他进程所占有时，可以由操作系统协助，将想要的资源强行剥夺。</li></ul></li><li>缺点：<ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都要放弃，以后再重新申请。如果一直发生这样的情况，就会导致饥饿。</li></ul></li></ul></li><li>破坏请求和保持条件：<ul><li>请求和保持条件：进程已经至少保持了至少一个资源，但又提除了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>方法：采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归他所有，该进程就不会再请求别的任何资源了。</li><li>优点：实现简单</li><li>缺点：<ul><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间一直保持著所有资源，就会造成严重的资源浪费，资源利用率极低。</li><li>可能导致饥饿</li></ul></li></ul></li><li>破坏循环等待条件：<ul><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li><li>方法：采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。</li><li>缺点：<ul><li>不方便增加新的设备，因为可能需要重新分配所有编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ul></li></ul></li></ol><h3 id="三、避免死锁"><a href="#三、避免死锁" class="headerlink" title="三、避免死锁"></a>三、避免死锁</h3><ol><li>系统安全状态：<ul><li>安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。<font color=orange>（安全序列可能有多个）</font></li><li>不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。</li><li>与死锁的联系：<ul><li>如果系统处于安全状态，就一定不会发生死锁</li><li>如果系统进入不安全状态，就可能发生死锁</li></ul></li></ul></li><li>银行家算法：<ul><li>算法思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</li><li>数据结构：<ul><li>长度为m的一维数组Available：还有多少可用资源</li><li>n*m矩阵Max：各进程对资源的最大需求数</li><li>n*m矩阵Allocation：已经给各进程分配了多少资源</li><li>Max-Allocation=Need矩阵：各进程最多还需要多少资源</li><li>长度为m的一维数组Request：进程此次申请的各种资源数</li></ul></li><li>算法步骤：<ul><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ul></li><li>安全性算法步骤：<ul><li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</li><li>不断重复上述过程，看最终是否能让所有进程都加入安全序列</li></ul></li></ul></li></ol><h3 id="四、死锁的检测和解除"><a href="#四、死锁的检测和解除" class="headerlink" title="四、死锁的检测和解除"></a>四、死锁的检测和解除</h3><ol><li><p>死锁的检测：</p><ul><li><p>资源分配图：</p><ul><li>两种结点：<ul><li>进程结点：对应一个进程</li><li>资源结点：对应一类资源，一类资源可能有多个</li></ul></li><li>两种边：<ul><li>进程结点──&gt;资源结点：表示进程想申请几个资源</li><li>资源结点──&gt;进程结点：表示已经为进程分配了几个资源</li></ul></li></ul><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/ziyuan.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/ziyuan.png" srcset="data:image/png;base64,666" alt="资源分配图" style="zoom:80%;" /></li><li><p>算法：</p><ul><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi。消去它所有的请求边和分配边，使之成为孤立的结点。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。</li><li>若进行一系列简化后，能消去图中所有的边，则称该图是可简化的。</li><li>死锁定理：若某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</li></ul></li></ul></li><li><p>死锁的解除：</p><ul><li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。</li><li>撤销进程法：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。</li><li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。</li></ul></li></ol><h1 id="第三章：内存管理"><a href="#第三章：内存管理" class="headerlink" title="第三章：内存管理"></a>第三章：内存管理</h1><h2 id="一、内存管理概念"><a href="#一、内存管理概念" class="headerlink" title="一、内存管理概念"></a>一、内存管理概念</h2><h3 id="一、内存管理的基本原理和要求"><a href="#一、内存管理的基本原理和要求" class="headerlink" title="一、内存管理的基本原理和要求"></a>一、内存管理的基本原理和要求</h3><ol><li>内存管理的功能：<ul><li>内存空间的分配与回收：</li><li>地址转换：逻辑地址转换为物理地址<ul><li>绝对装入：编译时产生绝对地址</li><li>可重定位装入：装入时将逻辑地址转换为物理地址</li><li>动态运行时装入：运行时将逻辑地址转换为物理地址，需要设置重定位寄存器</li></ul></li><li>内存空间的扩充：<ul><li>覆盖技术</li><li>交换技术</li><li>虚拟内存技术</li></ul></li><li>存储保护：保证各进程在自己的内存空间内运行，不会越界访问。<ul><li>设置上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用重定位寄存器和界地址寄存器：<ul><li>重定位寄存器：存放进程起始物理地址</li><li>界地址寄存器：存放进程的最大逻辑地址</li></ul></li></ul></li></ul></li><li>程序的装入和链接：<ul><li>编译：由编译程序将用户源代码编译程若干目标模块</li><li>链接：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块<ul><li>静态链接：在程序运行前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开</li><li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式</li><li>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。便于修改和更新，便于实现对目标模块的共享</li></ul></li><li>装入：由装入程序将装入模块装入内存运行<ul><li>绝对装入：编译时产生绝对地址</li><li>可重定位装入：装入时将逻辑地址转换为物理地址</li><li>动态运行时装入：运行时将逻辑地址转换为物理地址，需要设置重定位寄存器</li></ul></li></ul></li><li>逻辑地址空间与物理地址空间：<ul><li>逻辑地址空间：编译后，每个目标模块都是从0号单元开始编址，这称为该目标模块的相对地址（逻辑地址）。</li><li>物理地址空间：内存中物理单元的集合，它是地址转换的最终地址。</li><li>地址重定位：将逻辑地址转换为物理地址</li></ul></li><li>碎片：<ul><li>内部碎片：分配给某进程的内存区域中，没有被用上的部分</li><li>外部碎片：内存中的某些空闲分区由于太小而难以利用<ul><li>可以通过紧凑技术来解决外部碎片（进程挪位，以合并出更大的内存空间）</li></ul></li></ul></li><li>可重入代码（纯代码）：不能被修改的代码。</li></ol><h3 id="二、连续分配管理方式"><a href="#二、连续分配管理方式" class="headerlink" title="二、连续分配管理方式"></a>二、连续分配管理方式</h3><ol><li>单一连续分配：<ul><li>内存被分为系统区和用户区</li><li>特点：<ul><li>系统区通常处于内存的低地址部分，用于存放操作系统相关数据</li><li>用户区用于存放用户进程相关数据，内存中<font color=red>只能有一道用户程序</font>，用户程序独占整个用户区空间</li></ul></li><li>优点：<ul><li>实现简单</li><li>无外部碎片</li><li>可以采用覆盖技术扩充内存</li><li>不一定需要采取内存保护</li></ul></li><li>缺点：<ul><li>只能用于单用户、单任务的操作系统中</li><li>有内部碎片</li><li>存储器利用率极低</li></ul></li></ul></li><li>固定分区分配：<ul><li>将整个用户空间划分为若干个固定大小的分区</li><li>特点：<ul><li>在每个分区中直撞入一道作业</li><li>操作系统建立一个数据结构──分区说明表，包含分区号、大小、起始地址、状态（是否已分配）</li></ul></li><li>分类：<ul><li>分区大小相等：缺乏灵活性，但很适合用于一台计算机控制多个相同对象的场合</li><li>分区大小不等：增加了灵活性，可以满足不同大小的进程需求</li></ul></li><li>优点：<ul><li>实现简单</li><li>无外部碎片</li></ul></li><li>缺点：<ul><li>当用户程序太大时，可能所有的分区都不能满足需求，不得不采用覆盖技术解决，会降低性能</li><li>会产生内部碎片，内存利用率低</li></ul></li></ul></li><li> 动态分区分配：</li></ol><ul><li>不会预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区。</li><li>系统要用什么样的数据结构记录内存的使用情况？<ul><li>空闲分区表：每一个空闲分区对应一个表项，表项中包含分区号、分区大小、起始地址、状态等信息</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向和后向的指针。</li></ul></li><li>当有很多空闲分区都满足需求时，应该选择哪个分区进行分配？──动态分配算法<ul><li>首次适应算法（First Fit）：<ul><li>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</li><li>实现方法：空闲分区以地址递增的次序排列。每次分配时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>优点：综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排列。</li></ul></li><li>最佳适应算法（Best Fit）：<ul><li>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此尽可能保留大片的空闲区，优先使用更小的空闲区。</li><li>实现方法：空闲分区以容量递增的次序排列。每次分配时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>优点：会有更多的大分区被保留下来，更能满足大进程的需求。</li><li>缺点：每次都选最小的分区进行分配，会留下越来越多、很小的、难以利用的内存块，产生很多外碎片</li></ul></li><li>最坏适应算法（Worst Fit）：<ul><li>算法思想：为了解决最佳适应算法留下太多外部碎片的问题，优先使用最大的连续区。</li><li>实现方法：空闲分区以容量递减的次序排列。每次分配时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>可以减少难以利用的外碎片</li><li>缺点：每次都选最小=大的分区进行分配，会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有空间可以使用了</li></ul></li><li>邻近适应算法（Next Fit）：<ul><li>算法思想：每次都从上次查找结束的位置开始检索。</li><li>实现方法：空闲分区以地址递增的次序排列（可排成一个循环链表）。每次分配时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>优点：不用每次都从低地址的小分区开始检索，算法开销小。</li><li>缺点：会使高地址的大分区也被用完。</li></ul></li></ul></li><li>如何进行分区的分配与回收？──更新空闲分区表/空闲分区链</li></ul><h3 id="三、非连续分配管理方式"><a href="#三、非连续分配管理方式" class="headerlink" title="三、非连续分配管理方式"></a>三、非连续分配管理方式</h3><ol><li><p>基本分页存储管理方式：</p><ul><li><p>将内存空间分为一个个大小相等的分区，每个分区就是一个“页框”（页帧=内存快=物理块=物理页=实页=块）。每个页框都有一个编号，即“页框号”，页框号<font color=red>从0开始</font>。</p></li><li><p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页面”（页=逻辑页=虚页）。每个页面页有一个编号，即“页号”，页号也是<font color=red>从0开始的</font>。</p></li><li><p>操作系统<font color=red>以页框为单位为各个进程分配内存空间</font>。进程的每个页面分别放入一个页框中，<font color=red>进程的页面与内存的页框由一一对应的关系</font>。</p></li><li><p>页表：</p><ul><li>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表</li><li>一个进程对应一张页表</li><li>进程的每个页面对应一个页表项</li><li>每个页表项由“页号”和“块号”组成</li><li>页表记录进程页面和实际存放的页框之间的映射关系</li><li>每个页表项的长度是相同的</li></ul></li><li><p>每个页表项占多少字节？</p><ul><li>寻找内存块大小（内存块大小=页面大小）</li><li>计算内存块数</li><li>找寻内存块号的范围</li><li>计算内存块号至少需要多少bit表示</li><li>计算内存块号至少需要多少字节表示(xB)</li><li>由于页号时隐含的，因此每个页表项占xB，存储整个页表至少需要x*nB</li></ul></li><li><p>如何实现地址的转换：（若要访问逻辑地址A）</p><ul><li>确定逻辑地址A对应的页号P<br>$$<br>页号=逻辑地址/页面长度<br>$$</li></ul></li><li><p>找到P号页面在内存中的起始地址（查页表）</p></li><li><p>确定逻辑地址A的“页内偏移量”W<br>  $$<br>  页内偏移量=逻辑地址%页面长度<br>  $$</p><ul><li>逻辑地址A的物理地址=P号页面在内存中的起始地址+页内偏移量W</li></ul></li><li><p>页面大小取2的整数幂：</p><ul><li>逻辑地址的拆分更加迅速：如果每个页面大小为2^k B，用二进制表示逻辑地址，则末尾k位即为页内偏移量，其余部分就是页号。</li><li>物理地址的计算更加迅速：根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的存放号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li></ul></li><li><p>逻辑地址结构：页号+页内偏移量</p><ul><li>如果由K位表示页内偏移量，则说明该系统中一个页面的大小是2^K个内存单元</li><li>如果由M位表示页号，则说明在该系统中，一个进程最多允许有2^M个页面</li></ul></li><li><p>基本地址变换机构：</p><ul><li>页表寄存器（PTR）：存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块PCB中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li><li>变换过程：<ul><li>根据逻辑地址计算页号P和页内偏移量W</li><li>比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行</li><li>页表中的页号P对应的<font color=red>页表项地址=页表起始地址F+页号P*页表项长度</font>，取出该页表项内容b，即为内存块号。<ul><li>页表长度：页表中总共有几个页表项</li><li>页表项长度：每个页表项占多大的存储空间</li><li>页面大小：一个页面占多大的存储空间</li></ul></li><li>计算E=b*L+W，用得到的物理地址E去访存。</li></ul></li><li>为了页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装下整数个页表项。</li></ul></li><li><p>具有快表的地址变换机构：</p><ul><li>快表（TLB）：联想寄存器，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，加速地址变换的速度。</li><li>过程：<ul><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<font color=red>若快表命中，则访问某个逻辑地址仅需一次访存即可</font>。</li><li>如果没有找到匹配的页号，则访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，<font color=red>若快表未命中，则访问某个逻辑地址需要两次访存</font>。</li></ul></li><li>若快表和慢表同时查询，则计算快表未命中时不需要加上查询快表的时间。</li><li>局部性原理：<ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。</li><li>基于此，一般快表命中率可达90%以上</li></ul></li></ul></li><li><p>两级页表：</p><ul><li>单级页表的问题：<ul><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</li></ul></li><li>两级页表的原理和地址结构：<ul><li>将原本长长的页表分为两部分，新建页目录表（外层页表/顶级页表）</li><li>地址分为三部分：一级页号、二级页号和页内偏移量</li></ul></li><li>地址变换：<ul><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中存放位置</li><li>根据二级页号查表，找到最终想访问的内存块号</li><li>结合页内偏移量的到物理地址</li></ul></li><li>注：<ul><li>若采用多级页表机制，<font color=red>各级页表的大小不能超过一个页面</font></li><li>x级页表访存次数需要x+1次（没有快表机构）</li></ul></li></ul></li></ul></li><li><p>基本分段存储管理方式：</p><ul><li>思想：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址。</li><li>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以相互不相邻。</li><li>逻辑地址结构：段号（段名）+段内地址（段内偏移量）<ul><li>段号的位数决定了每个进程最多可以分几个段</li><li>段内地址位数决定了每个段的最大长度是多少</li></ul></li><li>段表：<ul><li>每个段对应一个段表项， 其中记录了该段在内存中的段号、起始位置（基址）和段的长度</li><li><font color=red>各个段表项的长度是相同的</font>。为最大段长二进制位数+物理内存二进制位数。</li></ul></li><li>基本地址变换机构：<ul><li>根据逻辑地址得到段号S和段内地址W</li><li>比较段号S和段表长度M，若S&gt;=M，则产生越界中断，否则继续执行</li><li>查询段表，找到对应的段表项，段表项的存放地址为F+S*段表项长度</li><li>检查段内地址是否超过段长。<font color=red>若W&gt;=C，则产生越界中断</font>，否则继续执行</li><li>段表中的段号S对应的<font color=red>段表项地址=段表基址b+段内地址</font></li></ul></li></ul></li><li><p>分页与分段的区别：</p><table><thead><tr><th align="center"></th><th align="center">分页存储</th><th align="center">分段存储</th></tr></thead><tbody><tr><td align="center">单位</td><td align="center">页是信息的<font color=red>物理</font>单位</td><td align="center">段是信息的<font color=red>逻辑</font>单位</td></tr><tr><td align="center">目的</td><td align="center">实现离散分配，提高内存利用率</td><td align="center">更好地满足用户需求</td></tr><tr><td align="center">是否对用户可见</td><td align="center">不可见</td><td align="center">可见</td></tr><tr><td align="center">大小</td><td align="center">固定且由系统决定</td><td align="center">不固定，取决于用户编写的程序</td></tr><tr><td align="center">地址空间</td><td align="center">一维，只需给出一个记忆符即可表示一个地址</td><td align="center">二维，既要给出段名，又要给出段内地址</td></tr><tr><td align="center">信息的共享和保护</td><td align="center">略劣（分页可能会吧同种功能的指令分割开来）</td><td align="center">更优</td></tr><tr><td align="center">访问地址需要几次访存</td><td align="center">2次</td><td align="center">2次</td></tr><tr><td align="center">优点</td><td align="center">内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td align="center">很方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td align="center">缺点</td><td align="center">不方便按照逻辑模块实现信息的共享和保护</td><td align="center">如果段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生外部碎片</td></tr></tbody></table></li><li><p>段页式管理方式：</p><ul><li>思想：将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同的内存快</li><li>逻辑地址结构：段号+页号+页内地址（页内偏移量）组成<ul><li>段号的位数决定了每个进程最多可以分多少段</li><li>页号位数决定了每个段最大有多少页</li><li>页内偏移量决定了页面大小、内存块大小是多少</li></ul></li><li>段表、页表<ul><li>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个<font color=red>段表项长度相等，段号是隐含的</font></li><li>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的</li></ul></li><li>基本地址变换：<ul><li>根据逻辑地址得到段号S、页号P、页内偏移量W</li><li>比较段号S和段表长度M，若S&gt;=M，则产生越界中断，否则继续执行</li><li>查询段表，找到对应的段表项，段表项的存放地址为F+S*段表项长度</li><li>检查页号P是否超过页表长度。<font color=red>若P&gt;=页表长度，则产生越界中断</font>，否则继续执行</li><li>根据页表存放块号、页号查询页表，找到对应页表项</li><li>根据内存块号、页内偏移量得到最终的物理地址</li></ul></li></ul></li></ol><h2 id="二、虚拟内存管理"><a href="#二、虚拟内存管理" class="headerlink" title="二、虚拟内存管理"></a>二、虚拟内存管理</h2><h3 id="一、虚拟内存的基本概念"><a href="#一、虚拟内存的基本概念" class="headerlink" title="一、虚拟内存的基本概念"></a>一、虚拟内存的基本概念</h3><ol><li>传统存储管理方式：<ul><li>特征：<ul><li>一次性：作业必须一次性全部装入内存后才能开始运行</li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，知道作业运行结束</li></ul></li><li>缺点：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li><li>内存中会驻留大量的、暂时用不到的数据，导致内存资源的浪费</li></ul></li></ul></li><li>虚拟内存：<ul><li>定义：<ul><li>基于局部性原理，在程序装入时，可以将程序中<font color=red>很快会用到的部分装入内存，暂时用不到的部分留在外存</font>，就可以让程序开始执行。</li><li>在程序执行过程中，当所访问的<font color=red>信息不在内存时</font>，由<font color=red>操作系统负责将所需信息从外存调入内存</font>，然后继续执行程序。</li><li>若内存空间不够，由操作系统负责将内存中<font color=red>暂时用不到的信息换出到外存</font>。</li><li>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li></ul></li><li>特征：<ul><li>多次性：无须再作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过城中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul></li><li>实现方式：<ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul></li><li>与传统非连续分配存储管理的区别：<ul><li>操作系统要提供请求调页（或请求调段）功能</li><li>操作系统要提供页面置换（或段置换）的功能</li></ul></li></ul></li></ol><h3 id="二、请求分页管理方式"><a href="#二、请求分页管理方式" class="headerlink" title="二、请求分页管理方式"></a>二、请求分页管理方式</h3><ol><li><p>页表机制：页号+内存块号+状态位+访问字段+修改位+外存地址</p><ul><li>状态位：是否已调入内存</li><li>访问字段：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</li><li>修改位：页面调入内存后是否被修改过</li><li>外存地址：页面在外存中的存放位置</li></ul></li><li><p>缺页中断机构：</p><ul><li>请求分页系统中，每当访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时<font color=red>缺页的进程阻塞</font>，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列。</li><li>如果内存中有空闲块，则为进程分配一个空闲块，将所却页面装入该块，并修改页表中相应的页表项。</li><li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间<font color=red>被修改过</font>，则要将其<font color=red>写回外存</font>。未修改过的页面不用写回外存</li><li><font color=red>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</font><font color=orange>（故障）</font></li></ul></li><li><p>地址变换机构：</p><ul><li><p>流程图：</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/fenye.png" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/OS/fenye.png" srcset="data:image/png;base64,666" alt="请求分页地址变换"></p></li><li><p>注：</p><ul><li>快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除。</li><li>只有“写指令”才需要修改“修改位”。并且，一般来说<font color=red>只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表</font>。这样可以减少访问次数。</li><li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li><li>需要用某种“页面置换算法”来决定一个换出页面</li><li>换入/换出页面都需要启动慢速的I/O操作，如果操作太频繁，会有很大的开销</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li></ul></li></ul></li></ol><h3 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h3><ol><li><p>最佳置换算法（OPT）：</p><ul><li>思想：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面</li><li>注：实际上最佳置换算法时无法实现的</li></ul></li><li><p>先进先出置换算法（FIFO）：</p><ul><li>思想：每次选择淘汰的页面是最早进入内存的页面</li><li>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。<font color=orange>（队列的最大长度取决于系统为进程分配了多少个内存块）</font></li><li>优点：实现简单</li><li>缺点：<ul><li>因为先进入的页面也有可能最经常被访问，因此算法性能差</li><li>会产生Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li></ul></li></ul></li><li><p>最近最久未使用置换算法（LRU）：</p><ul><li>思想：每次淘汰的页面时最近最久未使用的页面</li><li>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值最大的。</li><li>优点：算法性能好</li><li>缺点：需要专门的硬件支持，实现困难，开销大</li></ul></li><li><p>时钟置换算法（CLOCK）：</p><ul><li><p>简单的时钟淘汰算法（CLOCK）：</p><ul><li>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。<font color=orange>（最多会经过两轮扫描）</font></li><li>优点：实现简单，算法开销小</li><li>缺点：仅考虑到页面是否被访问过，没有考虑是否被修改过</li></ul></li><li><p>改进的时钟淘汰算法──最近未用算法（NRU）：</p><ul><li><p>实现方法：用（访问位，修改位）一起判断页面状态。将所有可能被置换的页面排成一个循环队列，执行下列操作：</p><ul><li>第一轮：从当前位置开始扫描第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位。</li><li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0.</li><li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位。</li><li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。</li></ul><p><font color=orange>最多会进行四轮扫描</font></p></li><li><p>优点：</p><ul><li>算法开销小</li><li>性能不错</li></ul></li></ul></li></ul></li></ol><h3 id="四、页面分配策略"><a href="#四、页面分配策略" class="headerlink" title="四、页面分配策略"></a>四、页面分配策略</h3><ol><li>驻留集：<ul><li>定义：指请求分页存储管理中给进程分配的物理块的集合。</li><li>考虑问题：<ul><li>分配给一个进程的存储量越小，任何时候驻留在主存的进程数就越多，从而可以提高处理机的时间利用效率。</li><li>若一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。</li><li>若页数过多，根据局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li></ul></li></ul></li><li>置换策略：<ul><li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。<font color=orange>（即驻留集大小不变）</font></li><li>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。<font color=orange>（即驻留集大小可变）</font></li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将<font color=red>别的进程持有的物理块</font>置换到外存，再分配给缺页进程。</li><li>局部置换：发生缺页时只能选<font color=red>进程自己的物理块进行置换</font></li></ul></li><li>三种常用策略：<ul><li>固定分配局部置换：<ul><li>思想：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行过程中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</li><li>缺点：很难在刚开始就确定应为每个进程分配多少个物理块才合理。</li></ul></li><li>可变分配全局策略：<ul><li>思想：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将给物理块分配给缺页的进程。</li><li><font color=red>只要某进程发生缺页都将获得新的物理块</font></li><li>被选择调出的页可能时是系统中任何一个进程中的页，因此这个<font color=red>被选中的进程拥有的物理块会减少，缺页率会增加</font></li></ul></li><li>可变分配局部策略：<ul><li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给进程的物理块。</li></ul></li></ul></li><li>何时调入页面：<ul><li>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于<font color=red>进程的首次调入</font>，由程序员指出应该先调入哪些部分。</li><li>请求调页策略：进程<font color=red>在运行期间发现缺页时才将所缺页面调入内存</font>。I/O开销较大。</li></ul></li><li>何处调入页面：<ul><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行</li><li>系统缺少足够的对换区空间：凡是不会被修改的数据都是直接从文件区调入。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ul></li></ol><h3 id="五、抖动"><a href="#五、抖动" class="headerlink" title="五、抖动"></a>五、抖动</h3><ol><li>定义：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的行为叫抖动，也称颠簸。</li><li>主要原因：进程频繁访问的页面数目高于可用的物理块数。</li></ol><h3 id="六、工作集"><a href="#六、工作集" class="headerlink" title="六、工作集"></a>六、工作集</h3><ol><li>定义：进程在某段时间间隔内，进程实际访问页面的集合。</li><li>操作系统会根据“窗口尺寸”算出工作集。</li><li>工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。</li><li>基于局部性原理，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法：选择一个不在工作集中的页面进行淘汰</li></ol><h1 id="第四章：文件管理"><a href="#第四章：文件管理" class="headerlink" title="第四章：文件管理"></a>第四章：文件管理</h1><h2 id="一、文件系统基础"><a href="#一、文件系统基础" class="headerlink" title="一、文件系统基础"></a>一、文件系统基础</h2><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章：计算机系统概述&quot;&gt;&lt;a href=&quot;#第一章：计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;第一章：计算机系统概述&quot;&gt;&lt;/a&gt;第一章：计算机系统概述&lt;/h1&gt;&lt;h2 id=&quot;一、操作系统的基本概念&quot;&gt;&lt;a href=&quot;#一、操作系统</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="专业课" scheme="https://www.oliverbryant.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>China-modern-history</title>
    <link href="https://www.oliverbryant.cn/2021/03/08/China-modern-history/"/>
    <id>https://www.oliverbryant.cn/2021/03/08/China-modern-history/</id>
    <published>2021-03-08T02:04:40.000Z</published>
    <updated>2021-03-08T02:04:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章、反对外国侵略的斗争"><a href="#第一章、反对外国侵略的斗争" class="headerlink" title="第一章、反对外国侵略的斗争"></a>第一章、反对外国侵略的斗争</h2><h3 id="一、西方列强侵略和社会性质转变"><a href="#一、西方列强侵略和社会性质转变" class="headerlink" title="一、西方列强侵略和社会性质转变"></a>一、西方列强侵略和社会性质转变</h3><h4 id="一、鸦片战争前的中国"><a href="#一、鸦片战争前的中国" class="headerlink" title="一、鸦片战争前的中国"></a>一、鸦片战争前的中国</h4><ol><li>经济特征：封建地主土地所有制经济占主导地位。</li><li>政治特征：高度中央集权的封建君主专制制度。</li><li>社会结构特点：核心是宗族家长制。</li><li>文化思想体系：以儒家思想为核心。</li></ol><h4 id="二、资本-帝国主义对中国的侵略"><a href="#二、资本-帝国主义对中国的侵略" class="headerlink" title="二、资本-帝国主义对中国的侵略"></a>二、资本-帝国主义对中国的侵略</h4><ol><li>中国近代史的起点：鸦片战争</li><li>鸦片战争：<ul><li>以失败而告终</li><li>签订第一个不平等条约——《南京条约》</li><li>美利坚法兰西趁火打劫，签订——中美《望厦条约》、中法《黄埔条约》</li><li>对中国社会进程的影响：<ul><li>社会性质的变化</li><li>主要矛盾的变化</li><li>革命任务的变化</li></ul></li></ul></li><li>西方列强攫取的侵略特权：<ul><li>破坏中国主权和领土完整<ul><li>香港的瓜分：<ul><li>香港岛——《南京条约》——1842年</li><li>九龙司地方一区——《北京条约》——1860年</li><li>租让新界——《展拓香港界址专条》——1898年</li></ul></li></ul></li><li>破坏中国的领海主权</li><li>破坏中国的司法主权</li><li>破坏中国的关税主权</li></ul></li></ol><h4 id="三、近代中国半殖民地半封建性质"><a href="#三、近代中国半殖民地半封建性质" class="headerlink" title="三、近代中国半殖民地半封建性质"></a>三、近代中国半殖民地半封建性质</h4><ol><li><p>中国逐步变成半殖民地的原因：</p><ul><li>已经丧失完整主权</li><li>还有一定主权</li></ul></li><li><p>中国逐步变成半封建社会的原因：</p><ul><li>外国资本主义用武力打开中国的门户，一方面破坏了自然经济，另一方面为中国资本主义产生造成了客观条件。</li><li>西方列强并不愿意中国成为独立的资本主义国家。</li></ul></li><li><p>半殖民地半封建社会的基本特征：</p><ul><li>资本——帝国主义侵略势力不但逐步操纵了中国的财政和经济命脉，而且逐步控制了中国的政治，日益成为支配中国的决定性力量。</li><li>中国的封建势力日益衰败并同外国侵略势力勾结，成为资本——帝国主义压迫、奴役中国人民的社会基础和统治支柱。</li><li>中国自然经济的基础虽然遭到破坏，但是封建剥削制度的根基即封建地主的土地所有指依然在广大地区内保持着，成为中国走向现代化和民主化的严重障碍。</li><li>中国新兴的民族主义经济虽然已经产生，并在政治、文化生活中起到一定的作用，但是在帝国主义和封建主义的压迫下，它的发展很缓慢，力量很软弱，而且它的大部分与外国资本——帝国主义和本国封建主义都有或多或少的联系。</li><li>由于近代中国处于资本——帝国主义列强的争夺和间接统治之下，加上中国地域广大，以及在地方性的农业性质的基础上形成的地方割据势力的存在，近代中国各地区经济、政治和文化的发展是极不平衡的。后来，帝国主义国家还分别支持不同的政治势力分裂中国，使中国处于不统一状态。</li><li>在资本——帝国主义和封建主义的双重压迫下（后来还加上官僚资本主义），中国的广大人民尤其是农民日益贫困化以至大批地破产，过着饥寒交迫和毫无政治权力的生活。</li></ul></li><li><p>社会阶级关系的变动：</p><ul><li>地主阶级：附股外资企业、入股洋务企业、直接创办或参股民营企业，变为资本家。</li><li>农民阶级：<ul><li>不少自耕农失去土地，变为贫农或雇农</li><li>成为产业工人的后备军，其所形成的新的阶级无产阶级是中国民主革命的主力军。</li></ul></li><li>资产阶级：<ul><li>前身：买办、商人、地主、官僚投资新式产业转化而成</li><li>构成：官僚资产阶级<font color="orange">（革命的敌人）</font>，民族资产阶级<font color="orange">（民主革命的动力之一）</font></li></ul></li><li>无产阶级：深受帝国主义，封建势力，资产阶级三座大山的压迫，受剥削最深，革命性最强，纪律性强、集中、团结、与广大农民有着天然联系的优点。因此是近代中国革命的阶级。</li></ul></li><li><p>认识中国近代一切社会问题和革命问题的最基本依据：</p><p> 认识中国近代社会的性质，就是认识近代中国的基本国情——<font color="red">双半社会</font>。</p></li><li><p>中国社会两个根本性变化：</p><ul><li>独立的中国逐步变为半殖民的中国</li><li>封建的中国逐步变为半封建社会</li></ul></li></ol><h4 id="四、近代中国的主要矛盾和历史任务"><a href="#四、近代中国的主要矛盾和历史任务" class="headerlink" title="四、近代中国的主要矛盾和历史任务"></a>四、近代中国的主要矛盾和历史任务</h4><ol><li>近代中国的主要矛盾<ul><li>帝国主义和中华民族</li><li>封建主义和人民大众</li></ul></li><li>近代中国的历史任务<ul><li>争取民族独立、人民解放<font color="orange">（生产关系）</font>——1949年完成——<font color="red">前提</font></li><li>实现国家富强、人民富裕<font color="orange">（生产力）</font>——还在努力——<font color="red">目的和归宿</font></li></ul></li></ol><h3 id="二、抵御外国侵略、争取独立斗争"><a href="#二、抵御外国侵略、争取独立斗争" class="headerlink" title="二、抵御外国侵略、争取独立斗争"></a>二、抵御外国侵略、争取独立斗争</h3><h4 id="一、反抗外来侵略的斗争历程"><a href="#一、反抗外来侵略的斗争历程" class="headerlink" title="一、反抗外来侵略的斗争历程"></a>一、反抗外来侵略的斗争历程</h4><ol><li>人民群众的反侵略战争：三元里抗英<font color="orange">（中国近代史上第一次大规模的群众反侵略斗争）</font></li><li>爱国官兵的反侵略斗争：<ul><li>冯子材：中法战争大败法军</li><li>邓世昌、林永升：甲午中日战争</li></ul></li></ol><h4 id="二、粉碎瓜分中国的图谋"><a href="#二、粉碎瓜分中国的图谋" class="headerlink" title="二、粉碎瓜分中国的图谋"></a>二、粉碎瓜分中国的图谋</h4><ol><li>边疆危机和瓜分危机</li><li>义和团运动与列强瓜分中国图谋的破产：<ul><li>帝国主义列强矛盾和互相制约</li><li>中华民族不屈不挠的反侵略斗争<font color="red">（最根本原因）</font></li></ul></li></ol><h4 id="三、反侵略战争的失败及其原因"><a href="#三、反侵略战争的失败及其原因" class="headerlink" title="三、反侵略战争的失败及其原因"></a>三、反侵略战争的失败及其原因</h4><ol><li>社会制度的腐败<font color="red">（根本原因）</font></li><li>经济技术的落后</li></ol><h4 id="四、民族意识的觉醒"><a href="#四、民族意识的觉醒" class="headerlink" title="四、民族意识的觉醒"></a>四、民族意识的觉醒</h4><ol><li>林则徐，魏源<font color="orange">《海国图志》</font>——师夷长技以制夷</li><li>王韬、薛福成、郑观应——早期<font color="orange">（只提出，没实践）</font>的维新思想——不仅学习技术、同时学习制度</li><li>共同点：反侵略；反封建</li><li>《盛世危言》——郑观应<ul><li>大力发展民族工商业</li><li>同西方国家进行”商战“</li><li>设立议院</li><li>实行”君民共主“制度</li></ul></li><li>严复<font color="orange">写《救亡决论》、译《天演论》</font>——救亡图存</li><li>孙中山——振兴中华</li></ol><h3 id="三、农民群众斗争风暴的起落——太平天国农民战争"><a href="#三、农民群众斗争风暴的起落——太平天国农民战争" class="headerlink" title="三、农民群众斗争风暴的起落——太平天国农民战争"></a>三、农民群众斗争风暴的起落——太平天国农民战争</h3><ol><li>太平天国农民战争爆发的原因：<ul><li>内忧：农民负担加重</li><li>外环：西方资本主义的入侵</li></ul></li><li>金田起义和太平天国的建立：<ul><li>天王洪秀全</li><li>广西</li></ul></li><li>《天朝田亩制度》：<ul><li>性质：最能体现太平天国社会理想和这次农民起义特色的纲领性文件。</li><li>内容：<ul><li>确立了平均分配土地的方案</li><li>规定了农、副业产品的生产与分配</li></ul></li><li>评价：<ul><li>革命性：<ul><li>一个以解决土地问题为中心的比较完整的社会改革方案</li><li>从根本上否定了封建社会的基础即封建地主土地所有制<font color="orange">（有田同耕）</font></li></ul></li><li>空想制：<ul><li>没有超出农民小生产者的狭隘眼界</li><li>具有不切实际的空想的性质</li></ul></li></ul></li></ul></li><li>《资政新篇》：<ul><li>太平天国后期颁布的社会发展方案</li><li>中国近代历史上第一个比较系统的发展资本主义的方案</li><li>既有先进性又有局限性</li></ul></li><li>天京事变：由盛转衰的分水岭<ul><li>根源：农民阶级的阶级局限性</li></ul></li><li>太平天国起义的历史意义：<ul><li>中国旧式农民战争的最高峰。它把千百年来农民对拥有土地的渴望在《天朝田亩制度》中比较完整的表达了出来。《资政新篇》则是中国近代历史上第一个比较系统的发展资本主义的方案，这反映了太平天国某些领导人在后期试图通过向外国学习来寻求出路的一种努力。因此，太平天国起义具有了不同于以往农民战争的新的历史特点。<ul><li>第一次反封建同时反侵略</li><li>资本主义</li><li>遭到中外势力的联合镇压</li></ul></li><li>沉重打击了封建统治阶级</li><li>冲击了孔子和儒家经典的正统权威</li><li>还有力地打击了外国侵略势力</li><li>冲击了西方殖民主义者在亚洲的统治</li></ul></li><li>太平天国农民战争的局限性和教训<ol><li>失败的原因：<ul><li>根本原因：阶级局限性<font color="orange">（自私、散漫、保守、狭隘）</font><ul><li>无法从根本上提出完整的、正确的政治纲领和社会改革方案</li><li>无法制止和克服领导集团自身腐败现象的滋长</li><li>无法长期保持领导集团的团结</li></ul></li><li>没有科学理论的指导</li><li>未能正确对待儒学</li><li>对资本主义侵略者缺乏理性认识</li></ul></li><li>教训<ul><li>在半殖民地半封建的中国，农民具有巨大的革命潜力；但它自身不能担负起领导反帝反封建斗争取得胜利的重任。</li><li>单纯的农民战争不可能完成争取民族独立和人民解放的历史任务。</li><li>中国革命的实质：无产阶级领导的农民革命</li></ul></li></ol></li></ol><h3 id="四、洋务运动的兴衰"><a href="#四、洋务运动的兴衰" class="headerlink" title="四、洋务运动的兴衰"></a>四、洋务运动的兴衰</h3><h4 id="一、洋务事业的兴办"><a href="#一、洋务事业的兴办" class="headerlink" title="一、洋务事业的兴办"></a>一、洋务事业的兴办</h4><ol><li>洋务运动的兴起：<ul><li>人物：奕䜣、文祥、曾国藩、李鸿章、张之洞、左宗棠</li><li>目的：镇压农民起义，同时也有借此加强海防、边防，并趁机发展本国的政治、经济和军事实力的意图。</li><li>根本目的：挽救清政府统治危机</li><li>指导思想：<font color="red">中学为体，西学为用</font></li><li>洋务事业：<ul><li>兴办近代企业：<ul><li>军用企业<font color="orange">（自强）</font>：<ul><li>最大的兵工厂：上海江南制造总局</li><li>最大的造船厂：福建船政局</li></ul></li><li>民用企业<font color="orange">（求富）</font>：轮船招商局、开平矿局等<font color="orange">（主要方式官督商办）</font></li></ul></li><li>建立新式海陆军：北洋水师、南阳水师、福建水师、广东水师</li><li>创办新式学堂，派遣留学生：翻译学堂；工艺学堂；军事学堂</li></ul></li><li>洋务派与顽固派的论战<ul><li>相同点：都是地主阶级</li><li>不同点：洋务派主张引进西方技术，顽固派反对</li></ul></li></ul></li></ol><h4 id="二、洋务运动的历史作用及其失败"><a href="#二、洋务运动的历史作用及其失败" class="headerlink" title="二、洋务运动的历史作用及其失败"></a>二、洋务运动的历史作用及其失败</h4><ol><li>历史作用：<ul><li>在客观上对资本主义的发展起了某些促进作用。</li><li>给当时的中国带来了新的知识，使人们打开了眼界。</li><li>有利于社会风气的改变。</li></ul></li><li>失败的标志：甲午中日战争的失败标志着洋务运动的破产。</li><li>失败的原因：<ul><li>封建性</li><li>依赖性</li><li>腐朽性</li></ul></li></ol><h3 id="五、维新运动的兴起和夭折"><a href="#五、维新运动的兴起和夭折" class="headerlink" title="五、维新运动的兴起和夭折"></a>五、维新运动的兴起和夭折</h3><h4 id="一、维新运动的兴起"><a href="#一、维新运动的兴起" class="headerlink" title="一、维新运动的兴起"></a>一、维新运动的兴起</h4><ol><li>原因：<ul><li>外患：甲午惨败</li><li>内忧：民族觉醒</li></ul></li><li>准备：<ol><li>向皇帝上书</li><li>著书立说</li><li>介绍外国变法的经验教训<font color="orange">（日俄）</font></li></ol></li><li>维新派与守旧派的论战：<ul><li>要不要变法</li><li>要不要兴民权、设议院、实行君主立宪</li><li>要不要废八股、改科举和兴西学</li><li><font color="red">实质上是资产阶级思想与封建主义思想在中国的第一次正面交锋。</font></li></ul></li><li>百日维新失败，京师大学堂保留下来。</li></ol><h4 id="二、维新运动的意义和教训"><a href="#二、维新运动的意义和教训" class="headerlink" title="二、维新运动的意义和教训"></a>二、维新运动的意义和教训</h4><ol><li>意义：<ul><li><font color="red">爱国救亡运动</font></li><li><font color="red">政治改良运动</font></li><li><font color="red">思想启蒙运动</font></li><li>推动了教育的发展</li><li>移风易俗、开启社会新风</li></ul></li><li>失败的原因：<ul><li>主观：维新派自身的局限<ul><li>不敢否定封建主义<ul><li>政治上不敢根本否定封建君主专制制度</li><li>经济上未触及封建土地所有制</li><li>思想上虽提倡学习西学却”托古改制“</li></ul></li><li>对帝国主义抱有幻想</li><li>惧怕人民群众</li></ul></li><li>客观：守旧势力的反对</li></ul></li><li>教训：<ul><li>民族资产阶级登上政治舞台的第一次表演</li><li>改良根本行不通，必须革命</li></ul></li></ol><h3 id="六、辛亥革命与君主专制制度的终结"><a href="#六、辛亥革命与君主专制制度的终结" class="headerlink" title="六、辛亥革命与君主专制制度的终结"></a>六、辛亥革命与君主专制制度的终结</h3><h4 id="一、举起近代民族民主革命的旗帜"><a href="#一、举起近代民族民主革命的旗帜" class="headerlink" title="一、举起近代民族民主革命的旗帜"></a>一、举起近代民族民主革命的旗帜</h4><ol><li>辛亥革命爆发的历史条件：<ul><li>民族危机加深，社会矛盾激化</li><li>清末“新政”的破产</li><li>资产阶级革命派的阶级基础和骨干力量</li></ul></li><li>资产阶级革命派的活动<ul><li>孙中山与资产阶级民主革命的开始：<ul><li>第一个<font color="red">革命团体</font>：兴中会</li><li>第一个<font color="red">资产阶级全国性政党</font>：同盟会<ul><li>全国性的组织系统</li><li>公认的革命领袖</li><li>完整的革命纲领</li></ul></li></ul></li><li>资产阶级革命派的宣传与组织工作：<ul><li>孙中山：《中国问题的真解决》</li><li>章炳麟：《驳康有为论革命书》</li><li>邹容：《革命军》</li><li>陈天华：《警世钟》、《猛回头》</li></ul></li></ul></li><li>三民主义学说：<ol><li>民族主义：<ul><li>内涵：民族革命</li><li>内容：驱除鞑虏，恢复中华</li><li>评价：<ul><li>没有明确的反帝纲领</li><li>放松了对汉族封建势力的警惕</li></ul></li></ul></li><li>民权主义<font color="orange">（核心）</font>：<ul><li>内涵：政治革命</li><li>内容：<font color="red">创立民国</font>，即推翻封建君主制度，建立资产阶级民主共和国</li><li>评价：资产专政的国家，人民群众的民主权利难以保证。</li></ul></li><li>民生主义：<ul><li>内涵：社会革命</li><li>内容：平均地权</li><li>评价：<ul><li>没有正面触及封建土地所有制</li><li>不能满足广大农民的土地要求</li><li>难以成为发动工农群众的理论武器</li></ul></li></ul></li></ol></li><li>关于革命与改良的辩论：<ul><li><font color="red">要不要以革命手段推翻清王朝</font></li><li>要不要推翻帝制，实行共和</li><li>要不要进行社会革命</li></ul></li></ol><h4 id="二、辛亥革命与建立民国"><a href="#二、辛亥革命与建立民国" class="headerlink" title="二、辛亥革命与建立民国"></a>二、辛亥革命与建立民国</h4><ol><li>武昌起义与封建帝制的覆灭：<ul><li>同盟会成立后发动的第一次武装起义：萍、浏、醴起义</li><li>影响最大的起义：黄花岗起义</li><li>成功的：武昌起义</li></ul></li><li>中华民国的建立：<ul><li>中华民国临时政府宣告成立：资产阶级共和国性质的革命政权。<ul><li>人员组成：以革命派为主体</li><li>政策措施：代表资产阶级，一定程度上代表广大人民利益</li></ul></li><li>中华民国临时约法颁布：中国历史上第一部具有资产阶级共和国性质的法典。<ul><li>主权在民</li><li>责任内阁</li><li>三权分立</li><li>一律平等</li><li>进步性：具有鲜明的革命性、民主性</li><li>局限性：企图承认清政府和列强的不平等条约；没有满足农民对土地的需求</li></ul></li></ul></li><li>辛亥革命的历史意义：<font color="red">比较完全意义上的资产阶级民主革命</font><ul><li>打击了中外反动势力</li><li>民主共和深入人心</li><li>思想上的解放</li><li>社会经济、思想习惯和风俗变化</li><li>推动了民族解放运动高涨</li></ul></li></ol><h4 id="三、辛亥革命的失败"><a href="#三、辛亥革命的失败" class="headerlink" title="三、辛亥革命的失败"></a>三、辛亥革命的失败</h4><ol><li><p>封建军阀专制统治的形成：袁世凯死后，中国陷入了军阀割据的局面。</p><ul><li>中国是地方性的农业经济而没有形成统一的资本主义经济市场。</li><li>帝国主义国家在中国采取划分势力范围的分裂剥削政策。</li></ul></li><li><p>旧民主主义革命的终结：</p><ol><li>挽救共和的势力及其受挫<ul><li>二次革命</li><li>组织中华革命党<font color="orange">（1914年）</font></li><li>护国运动</li><li>护法运动</li></ul></li><li>辛亥革命失败的原因和教训：<ul><li>根本原因：在半殖民地半封建的中国，资本主义的建国方案是行不通的。</li><li>主观原因：<ul><li>没有提出彻底的反帝反封建的革命纲领</li><li>不能充分发动和依靠人民群众</li><li>不能建立坚强的革命政党</li></ul></li></ul></li><li>辛亥革命为中共诞生准备了客观社会条件：<ul><li>为中共成立准备了阶级基础</li><li>为中共成立准备了理论基础</li><li>为中共成立准备了干部条件</li></ul></li></ol></li></ol><h2 id="第二章：新时代奋斗"><a href="#第二章：新时代奋斗" class="headerlink" title="第二章：新时代奋斗"></a>第二章：新时代奋斗</h2><h3 id="一、开天辟地的大事变"><a href="#一、开天辟地的大事变" class="headerlink" title="一、开天辟地的大事变"></a>一、开天辟地的大事变</h3><h4 id="一、新文化运动和五四运动"><a href="#一、新文化运动和五四运动" class="headerlink" title="一、新文化运动和五四运动"></a>一、新文化运动和五四运动</h4><ol><li><p>新文化运动的兴起：</p><ul><li>开端：创办《青年》杂志</li><li>人物：陈独秀、李大钊、胡适</li><li>基本内容：<ul><li>提倡民主和科学，反对专制和迷信盲从</li><li>提倡个性解放，反对封建礼教</li><li>提倡新文学，反对旧文学，实行文学革命</li></ul></li><li>口号：<ul><li>德先生（Democracy）：民主</li><li>赛先生（Science）：科学</li></ul></li><li>主要阵地：北京大学</li></ul></li><li><p>新文化运动的历史意义：</p><ul><li>启蒙运动和空前深刻的思想解放运动</li><li>为马克思主义广泛传播准备了思想和文化条件</li></ul></li><li><p>新文化运动的局限：</p><ul><li>倡导批判孔学，是为了给中国发展资本主义扫清障碍</li><li>把改造国民性作为优先地位</li><li>那时的许多领导人物没有马克思主义的批判精神，看问题片面</li></ul></li><li><p>十月革命对中国的影响：</p><p> 在中国大地上率先举起马克思主义旗帜<font color="orange">（李大钊）</font></p><ul><li>《法俄革命之比较观》</li><li>《庶民的胜利》</li><li>《Bolshevism的胜利》</li><li>《我的马克思主义观》</li></ul></li><li><p>五四运动的发生和发展：</p><ul><li>时代条件和社会历史条件<ul><li>新的社会力量的成长、壮大</li><li>新文化运动掀起的思想解放潮流</li><li>俄国十月革命对中国的影响</li></ul></li><li>直接导火线：巴黎和会中国外交的失败</li><li>特点和意义：<ul><li>五四运动表现了反帝反封建的彻底性</li><li>五四运动是一次真正的群众运动</li><li>五四运动促进了马克思主义在中国的传播及其与中国工人运动的结合</li><li>五四运动发生在俄国十月革命之后，发生在无产阶级社会主义革命的新时代</li></ul></li><li>五四运动是在新的社会历史条件下发生的，它具有以辛亥革命为代表的旧民主主义革命所不具备的一些特点，是<font color="red">新民主主义革命的开端</font>。</li></ul></li></ol><h4 id="二、马克思主义广泛传播与中共诞生"><a href="#二、马克思主义广泛传播与中共诞生" class="headerlink" title="二、马克思主义广泛传播与中共诞生"></a>二、马克思主义广泛传播与中共诞生</h4><ol><li>中国早期马克思主义思想运动：<ul><li>队伍：<ul><li>精神领袖：陈独秀、李大钊</li><li>左翼骨干：毛泽东、周恩来</li><li>活动家：吴玉章</li></ul></li><li>早期马克思主义思想运动：<ul><li>重视对马克思主义基本理论的学习</li><li>注意从中国的实际出发</li><li>知识分子应当同劳动群众相结合</li></ul></li><li>新文化运动的发展：<ul><li>民主和科学的内涵扩大</li><li>从反封建方面的进展：<ul><li>从反对封建思想入手，反对社会制度</li><li>斗争的立足点，从个性解放到社会解放</li><li>斗争方式，从思想批判发展为革命实践</li></ul></li></ul></li></ul></li><li>中国共产党诞生地历史必然性和伟大意义：<ul><li>中国共产党第一次全国代表大会：<ul><li>时间：1921年7月23日</li><li>地点：在上海法租借，后转移到浙江嘉兴南湖</li><li>人物：来自全国12位正式代表，代表全国53名党员</li><li>历史特点：<ul><li>一开始所接受的，是列宁主义<font color="orange">（思想基础好）</font></li><li>实在半殖民地半封建中国的工人运动的基础上产生的<font color="orange">（阶级基础好）</font></li></ul></li><li>伟大意义：<ul><li>坚强的领导力量</li><li>科学的指导思想</li><li>正确的纲领和奋斗目标</li><li>新的革命方法</li></ul></li></ul></li></ul></li></ol><h4 id="三、中国革命的新局面"><a href="#三、中国革命的新局面" class="headerlink" title="三、中国革命的新局面"></a>三、中国革命的新局面</h4><ol><li>制定革命纲领，发动工农运动<ul><li>中共二大：<ul><li>第一次提出了反帝反封建的民主革命纲领</li><li>开始采取群众路线的方法</li></ul></li><li>发动工农群众开展革命斗争</li></ul></li><li>国共合作的形成与大革命的兴起：<ul><li>国共合作的形成：<ul><li>一战后帝国主义卷土重来，国内军阀纷争扩大</li><li>孙中山陷入空前窘境</li><li>1923年中共三大共产党同意党员以个人身份加入国民党与国民党进行合作</li></ul></li><li>国民党一大：<font color="red">标志着第一次国共合作正式形成</font><ul><li>对三民主义作出了新的解释<font color="orange">（政治基础）</font></li><li>确定了联俄、联共、扶助农工三大革命政策</li></ul></li><li>大革命的兴起：<ul><li>创办黄埔陆军军官学校</li><li>以五卅运动为起点，掀起了全国范围的大革命高潮</li></ul></li></ul></li><li>北伐战争的胜利进展：<ul><li>直系军阀吴佩孚</li><li>直系分立出来的孙传芳</li><li>奉系军阀张作霖</li></ul></li><li>大革命：<ul><li>群众动员的程度更为广泛</li><li>斗争的规模更加宏伟</li><li>革命的社会内涵更为深刻</li></ul></li><li>大革命的失败：<ul><li>客观原因：<ul><li>反革命力量强大</li><li>统一战线分化</li><li>蒋汪集团大屠杀</li></ul></li><li>主观原因：<ul><li>中共领导：右倾</li><li>中共党：年轻</li><li>共产国际：瞎指挥</li></ul></li></ul></li><li>大革命失败的经验教训：<ul><li>统一战线</li><li>农民问题</li><li>武装斗争</li><li>党的建设</li></ul></li></ol><h4 id="四、历史选择了马克思主义"><a href="#四、历史选择了马克思主义" class="headerlink" title="四、历史选择了马克思主义"></a>四、历史选择了马克思主义</h4><ol><li><p>为了争取民族独立、人民解放，必须运用新的思想武器。</p></li><li><p>十月革命后，中国先进分子经过比较、探求，选择了马克思主义。</p><ul><li><p>十月革命表明，经济文化落后的国家也可以用社会主义思想指引自己走向解放之路。</p></li><li><p>十月革命的社会主义新俄国号召反对帝国主义，并以新的平等的态度对待中国，更有力地推动了社会主义思想在中国的传播。</p><p>  在中国大地上率先举起马克思旗帜的是<font color="red">李大钊</font>。</p></li></ul></li></ol><h3 id="二、中国革命的新道路"><a href="#二、中国革命的新道路" class="headerlink" title="二、中国革命的新道路"></a>二、中国革命的新道路</h3><h4 id="一、对革命新道路的艰苦探索"><a href="#一、对革命新道路的艰苦探索" class="headerlink" title="一、对革命新道路的艰苦探索"></a>一、对革命新道路的艰苦探索</h4><ol><li><p>国民党在全国统治的建立：</p><ul><li>时间：<ul><li>1927年4月，南京国民政府成立</li><li>1927年9月，宁汉合流</li><li>1928年，张学良改易旗帜</li></ul></li><li>性质：代表地主阶级、买办性的大资产阶级的军事独裁政权</li></ul></li><li><p>土地革命战争的兴起：</p><ul><li>开展武装反抗国民党反动统治的斗争：<ul><li>1927年中共中央临时政治局常委会：<ul><li>准备南昌起义</li><li>组织秋收暴动</li><li>召集中央会议，讨论和决定新时期的方针和政策</li></ul></li><li>八七会议：<ul><li>彻底清算了陈独秀“右”倾机会主义错误</li><li>土地革命和武装反抗国民党反动统治的总方针。毛泽东强调党“须知政权是由枪杆子中取得的”。</li><li>会议选出了以瞿秋白为首的中央临时政治局</li></ul></li><li>三大起义：<ul><li>南昌起义</li><li>秋收起义<ul><li>时间：1927.9.9</li><li>攻取长沙</li><li>9.19 文家市转兵</li><li>9.29 三湾改编</li></ul></li><li>广州起义</li></ul></li></ul></li></ul></li><li><p>农村包围城市、武装夺取政权的道路：</p><ol><li>对中国革命新道路的探索：<ul><li>中国红色政权发生和存在的原因：<ul><li>根本原因：中国是一个半殖民地半封建的大国，经济政治的发展极不平衡。</li><li>客观原因：<ul><li>良好的群众基础</li><li>全国革命形势的继续发展</li></ul></li><li>主观原因：<ul><li>相当力量的正式红军的存在</li><li>共产党组织的有力量和它的政策的不错误</li></ul></li></ul></li><li>工农武装割据：<ul><li>土地革命</li><li>武装斗争</li><li>根据地建设</li></ul></li><li>《星星之火，可以燎原》<ul><li>批评了夸大革命主观力量的盲动主义和看不到革命力量发展的悲观主义</li><li>阐明中国革命之能走与资本主义国家不同的道路</li></ul></li><li>《反对本本主义》<ul><li>为了反对党和红军中的教条主义</li><li>深刻阐明坚持辩证唯物主义的思想路线，坚持理论与实际相结合原则的重要性。没有调查就没有发言权。</li></ul></li></ul></li><li>反“围剿”战争与土地革命：<ul><li>1928年 井冈山土地法：中共历史上第一个土地法，以立法形式，首次肯定广大农民以革命手段获得土地的权利。</li><li>1929年 兴国土地法：将“没收一切土地”改为“没收一切公共土地及地主阶级的土地”。</li><li>1931年 阶级路线和土地分配方法</li></ul></li></ol></li></ol><h4 id="二、中国革命在探索中曲折前进"><a href="#二、中国革命在探索中曲折前进" class="headerlink" title="二、中国革命在探索中曲折前进"></a>二、中国革命在探索中曲折前进</h4><ol><li>土地革命战争的发展及其挫折：<ul><li>农村革命根据地的建设：1931年中华苏维埃共和国</li><li>土地革命战争的严重挫折：<ul><li>第一次：1927.11-1928.4 “左”倾盲动主义<font color="orange">（瞿秋白）</font></li><li>第二次：1930.6-1930.9 “左”倾冒险主义<font color="orange">（李立三）</font></li><li>第三次：1931.1-1935.1 “左”倾教条主义<font color="orange">（王明）</font><ul><li>“左”倾教条主义的表现：<ul><li>革命性质和统一战线问题上，混淆民主革命与社会主义革命的界限，将反帝反封建与反资产阶级并列，将民族资产阶级视为中国革命最危险的敌人，一味排斥和打击中间势力。</li><li>革命道路问题上，继续坚持以城市为中心。</li><li>土地革命问题上，提出坚决打击富农和“地主不分田，富农分坏田”的主张。</li><li>军事斗争问题上，实行进攻中的冒险主义、防御中的保守主义、退却中的逃跑主义。</li><li>党内斗争和组织问题上，推行宗派主义和“残酷斗争，无情打击”的方针。</li></ul></li><li>出现“左”倾错误的原因：<ul><li>“左”倾情绪没有认真清理</li><li>共产国际的错误干预和瞎指挥</li><li>不善于马列主义与中国实际全面、正确地结合起来</li></ul></li></ul></li></ul></li></ul></li><li>遵义会议与中国革命的历史性转折：<ul><li>内容：<ul><li>组织问题：增选毛泽东为中央政治局常务委员</li><li>军事问题：周、毛、王组成的新的三人团</li></ul></li><li>意义：开始确立毛泽东在中共中央的领导地位，挽救了党、挽救了红军、挽救了中国革命。成为党历史上生死攸关的转折点。</li></ul></li><li>红军长征的胜利</li><li>为什么必须使马克思主义中国化？<ul><li>中国革命胜利和失败的反复，说明了实行马克思主义中国化的极端重要性。</li><li>马克思主义中国化。实在党和人民集体奋斗的基础上不断总结经验的过程。</li><li>正确总结党的历史经验，确立实事求是的思想路线。</li></ul></li></ol><h3 id="三、中华民族的抗日战争"><a href="#三、中华民族的抗日战争" class="headerlink" title="三、中华民族的抗日战争"></a>三、中华民族的抗日战争</h3><h4 id="一、日本发动灭亡中国的侵略战争"><a href="#一、日本发动灭亡中国的侵略战争" class="headerlink" title="一、日本发动灭亡中国的侵略战争"></a>一、日本发动灭亡中国的侵略战争</h4><ol><li>日本灭亡中国的计划及其实施：<ul><li>1931年九一八事变</li><li>1935年华北事变</li><li>卢沟桥事变与日本全面侵华战争</li></ul></li></ol><h4 id="二、从局部抗战到全国抗战"><a href="#二、从局部抗战到全国抗战" class="headerlink" title="二、从局部抗战到全国抗战"></a>二、从局部抗战到全国抗战</h4><ol><li>国共合作，共赴国难<ul><li>形成：<ul><li>1935年，瓦窑堡会议确定建立抗日民族统一战线<ul><li>阐明建立抗日民族统一战线的可能性</li><li>批判了“左”倾关门主义错误</li><li>规定了建立广泛的抗日民族统一战线的具体政策</li></ul></li><li>1937年8月，国共两党达成协议</li><li>1937年9月22日，国民党中央通讯社发表《中国共产党为公布国共合作宣言》</li><li>1937年9月23日，蒋介石庐山谈话</li></ul></li><li>与革命统一战线相比，具有新的特点：<ul><li>广泛的民族性和复杂的阶级性</li><li>国共双方有政权有军队的合作</li><li>没有正式的固定地组织形式和协商一致的具体的共同纲领</li></ul></li></ul></li><li>全民同仇敌忾，奋起抗战<ul><li>一二 ·九运动：<ul><li>背景：1935年华北事变</li><li>意义：促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。</li></ul></li><li>西安事变：<ul><li>时间：1936年12月12日</li><li>意义：西安事变和平解决，标志着十年内战基本结束，抗日民族统一战线初步形成。</li></ul></li></ul></li></ol><h4 id="三、国民党与抗日的正面战场"><a href="#三、国民党与抗日的正面战场" class="headerlink" title="三、国民党与抗日的正面战场"></a>三、国民党与抗日的正面战场</h4><ol><li>战略防御阶段的正面战场：<ul><li>时间：1937.7-1938.10</li><li>国民党积极抗战，屡遭失败</li><li>客观原因：中日双方势力悬殊</li><li>主观原因：国民党实行片面抗战</li></ul></li><li>战略相持阶段的正面战场：<ul><li>时间：1938.10-1943.12</li><li>日本政策的变化：政治诱降为主</li><li>国民党消极抗日、积极反共</li><li>1939年，国民党五届五中全会决定“防共、限共、溶共、反共”的方针</li></ul></li></ol><h4 id="四、中国共产党成为抗日战争的中流砥柱"><a href="#四、中国共产党成为抗日战争的中流砥柱" class="headerlink" title="四、中国共产党成为抗日战争的中流砥柱"></a>四、中国共产党成为抗日战争的中流砥柱</h4><ol><li>全面抗战的路线和持久战的方针<ul><li>实行全面的全民族抗战的路线：<font color="red">洛川会议</font><ul><li>全面抗战路线</li><li>《抗日救国十大纲领》</li></ul></li><li>采取持久战的战略方针：《论持久战》<ul><li>背景：速胜论、亡国论</li><li>四个特点：<ul><li>敌强我弱</li><li>敌小我大</li><li>敌退步我进步</li><li>敌寡助我多助</li></ul></li><li>三个阶段：<ul><li>战略防御</li><li>战略相持</li><li>战略反攻</li></ul></li></ul></li></ul></li><li>敌后战场的开辟与游击战争的发展<ul><li>平型关大捷：全民族抗战以来中国军队取得的第一次重大胜利，粉碎了日军不可战胜的神话</li><li>游击战的战略地位和作用<ul><li>战略防御阶段：辅助的</li><li>战略相持阶段：主要的</li><li>战略反攻阶段：准备条件</li></ul></li></ul></li><li>坚持抗战、团结、进步的方针<ul><li>统一战线中的独立自主原则：<ul><li>共产党必须保持在思想上、政治上和组织上的独立性</li><li>必须坚持对人民军队的绝对领导</li><li>必须对国民党采取又团结又斗争、以斗争求团结的方针</li></ul></li><li>独立自主的实质：力争中国共产党对抗日战争的领导权，使自己成为团结全民族抗战的中坚力量。这是把抗日战争引向胜利的中心一环。</li><li>巩固抗日民族统一战线的策略总方针：<ul><li>发展进步势力：工人、农民、城市小资产阶级</li><li>争取中间势力：民族资产阶级、开明绅士和地方实力派<ul><li>共产党要有充足的力量</li><li>尊重他们的利益</li><li>要同顽固派作坚决的斗争，并能一步一步地取得胜利</li></ul></li><li>孤立顽固势力：大地主、大资产阶级</li></ul></li><li>抗日民主根据地的建设：<ul><li>三三制的民主政权建设：<ul><li>共产党员、非党的左派进步分子、中间派各占三分之一</li><li>加强政权建设，是抗日根据地建设的首要的、根本的任务</li></ul></li><li>减租减息，发展生产<font color="orange">（削弱封建剥削）</font></li><li>文化建设与干部教育</li></ul></li><li>新民主主义理论的系统阐述：<ul><li>马克思主义中国化命题的提出：1938年9月至11月，在中国共产党召开的六届六中全会上，毛泽东明确提出了“马克思主义的中国化”这个命题<ul><li>初步形成：农村包围城市理论</li><li>正式形成：新民主主义革命理论</li></ul></li><li>新民主主义理论的系统阐明</li></ul></li><li>延安整风与中共七大<ul><li>延安整风：<ul><li>主要内容：反主观主义、反宗派主义、反党八股</li><li>最主要任务：反主观主义</li><li>主观主义主要表现形式：教条主义和经验主义</li></ul></li><li>中共七大：毛泽东思想</li></ul></li></ul></li></ol><h4 id="五、抗日战争的胜利"><a href="#五、抗日战争的胜利" class="headerlink" title="五、抗日战争的胜利"></a>五、抗日战争的胜利</h4><ol><li>抗战的胜利：<ul><li>《中国对日宣战布告》：日本与中国签订的所有不平等条约<font color="orange">（马关条约）</font>都是非法的</li><li>《开罗宣言》：将日本非法侵占中国的领土归还中国<font color="orange">（明文规定台湾属于中国）</font></li><li>《波兹坦公告》：重申开罗宣言</li><li>《日本投降书》：签字确认</li></ul></li><li>在世界反法西斯战争中的地位：<ul><li>世界反法西斯战争的东方主战场</li><li>世界反法西斯力量对中国的援助</li></ul></li><li>抗战胜利的意义：<ul><li>近代以来中华民族反抗外敌入侵第一次取得完全胜利的民族解放战争</li><li>使中华民族避免了遭受殖民奴役的厄运</li><li>促进了中华民族的觉醒</li><li>促进了中华民族的大团结</li><li>显著提高了中国的国际地位和国际影响</li><li>中国人们抗日战争的胜利，为中国共产党团结带领全国人民继续奋斗，赢得新民主主义革命的胜利、创建中华人民共和国奠定了重要基础，开辟了中华民族复兴的光明前景</li></ul></li><li>抗战胜利的原因：<ul><li>中国共产党起到了中流砥柱的作用<ul><li>毛泽东思想的指导作用</li><li>中国共产党坚持抗战、反对妥协，坚持团结、反对分裂，坚持进步、反对倒退</li><li>中国共产党积极倡导、促成、维护抗日民族统一战线</li><li>中国共产党坚持全面抗战路线，提出持久战的战略总方针</li><li>中国共产党人成为夺取抗战胜利的民族先锋</li></ul></li><li>中国人民巨大的民族觉醒、空前的民族团结和英勇的民族抗争</li><li>国际同情和支持也是分不开的</li></ul></li></ol><h3 id="四、为新中国而奋斗"><a href="#四、为新中国而奋斗" class="headerlink" title="四、为新中国而奋斗"></a>四、为新中国而奋斗</h3><h4 id="一、从争取和平民主到进行自卫战争"><a href="#一、从争取和平民主到进行自卫战争" class="headerlink" title="一、从争取和平民主到进行自卫战争"></a>一、从争取和平民主到进行自卫战争</h4><ol><li>抗战胜利后的国际国内局势：<ul><li>美苏争霸</li><li>美国扶蒋反共</li></ul></li><li>中国共产党争取和平民主的斗争<ul><li>重庆谈判</li><li>参加重庆政协会议</li></ul></li><li>国民党发动内战和解放区军民的自卫战争<ul><li>全面内战爆发：1946年，国民党军队进攻中原解放区</li><li>以革命战争反对反革命战争：人民解放军的所具有的爱国的正义的革命的性质，必然会获得全国人民的拥护。这就是战争蒋介石的政治基础。</li><li>全面进攻</li><li>重点进攻<font color="orange">（山东、陕北解放区）</font></li></ul></li></ol><h4 id="二、国民党政府处于全民包围中"><a href="#二、国民党政府处于全民包围中" class="headerlink" title="二、国民党政府处于全民包围中"></a>二、国民党政府处于全民包围中</h4><ol><li>全国解放战争的胜利发展：1947年刘邓大军千里跃进大别山，揭开了解放军反攻序幕。</li><li>土地改革与农民的发动：<ul><li>《五四指示》：开始由抗日战争时期的削弱封建剥削，向变革封建土地关系、<font color="red">废除</font>封建剥削制度的过渡。</li><li>《中国土地法大纲》：废除</li><li>中共在民主革命时期的土地政策：<ul><li>土地革命：废除封建土地所有制</li><li>抗战时期：减租减息</li><li>解放战争：废除封建土地所有制</li></ul></li></ul></li><li>第一条战线：人民解放军和国民党军队的对决</li><li>第二条战线：国统区的人民民主运动<ul><li>国统区的政治经济危机</li><li>学生运动高涨</li><li>人民民主运动的发展</li></ul></li></ol><h4 id="三、中国共产党与民主党派的合作"><a href="#三、中国共产党与民主党派的合作" class="headerlink" title="三、中国共产党与民主党派的合作"></a>三、中国共产党与民主党派的合作</h4><ol><li>三大政治势力、三种建国方案：<ul><li>地主阶级和买办性的大资产阶级：继续实行大地主、大资产阶级的军事独裁统治。</li><li>民族资产阶级：建立一个名副其实的资产阶级共和国。<ul><li>自身的阶级局限性</li><li>帝国主义不允许</li><li>国民党当局不允许</li></ul></li><li>工人阶级、农民阶级和城市小资产阶级：首先进性一场彻底的反帝反封建的新式资产阶级民主革命，建立一个工人阶级领导的人民共和国，并且经过这个人民共和国，逐步到达社会主义和共产主义。</li></ul></li></ol><h4 id="四、创建人民民主专政的新中国"><a href="#四、创建人民民主专政的新中国" class="headerlink" title="四、创建人民民主专政的新中国"></a>四、创建人民民主专政的新中国</h4><ol><li>人民政协与《共同纲领》：<ul><li>筹建新中国：七届二中全会<ul><li>提出迅速夺取全国胜利的方针及解决剩余国民党军队的方式是天津式<font color="orange">（不投降就消灭）</font>、北平式<font color="orange">（和平）</font>、绥远式<font color="orange">（起义暂缓改编）</font></li><li>党的工作重心由乡村转移到城市<ul><li>文家市决策：城市转移到农村</li><li>1949七届二中全会：乡村转移到城市</li><li>1978十一届三中全会：阶级斗争转移到社会主义现代化建设</li></ul></li><li>规定党在全国胜利后的政治、经济外交基本政策，指出中国由农业国转变为工业国、由新民主主义转变为社会主义的总任务和主要途径。</li><li>提出两个“务必”，务必保持谦虚、谨慎、不骄、不躁的作风，务必保持艰苦奋斗的作风</li></ul></li><li>新中国奠基的三个历史性文件：<ul><li>《中国人民政治协商会议组织法》</li><li>《中华人民共和国中央人民政府组织法》</li><li>《中国人民政治协商会议共同纲领》</li></ul></li><li>《共同纲领》：临时宪法</li></ul></li><li>中国革命胜利的原因和基本经验：<ul><li>原因：<ul><li>工人、农民、城市小资产阶级是民主革命的主要力量</li><li>中国共产党的领导</li><li>国际无产阶级和人民群众的支持</li></ul></li><li>基本经验：<ul><li>统一战线<ul><li>巩固和扩大统一战线的关键，是坚持工人阶级及其政党的<font color="red">领导权</font><ul><li>必须率领同盟者向共同的敌人作坚决的斗争并取得胜利</li><li>必须对被领导者给以物质福利，至少不损害其利益，同时对被领导者给以政治教育</li><li>必须对同工人阶级争夺领导权的资产阶级采取又联合、又斗争的政策</li></ul></li></ul></li><li>武装斗争：实质是工人阶级领导的农民战争</li><li>党的建设</li></ul></li></ul></li></ol><h3 id="五、社会主义基本制度在中国的确立"><a href="#五、社会主义基本制度在中国的确立" class="headerlink" title="五、社会主义基本制度在中国的确立"></a>五、社会主义基本制度在中国的确立</h3><h4 id="一、从新民主主义向社会主义过渡的开始"><a href="#一、从新民主主义向社会主义过渡的开始" class="headerlink" title="一、从新民主主义向社会主义过渡的开始"></a>一、从新民主主义向社会主义过渡的开始</h4><ol><li>中华人民共和国的成立的四个标志：<ul><li>标志新民主主义革命取得基本胜利</li><li>标志半殖民地半封建社会的结束和新民主主义社会的建立</li><li>标志两大历史任务的第一项任务基本完成</li><li>标志社会主义革命阶段开始</li></ul></li><li>新民主主义社会的建立<font color="orange">（1949-1956）</font><ul><li>政治：工人阶级领导的，工农联盟为基础的，各革命阶级联合专政的政治制度</li><li>经济：国营经济领导下的五种经济并存的经济制度：<ul><li>国营经济</li><li>合作社经济<font color="orange">（个体向社会经济过渡）</font></li><li>个体经济</li><li>私人资本主义经济</li><li>国家资本主义经济<font color="orange">（私人向社会过渡）</font></li></ul></li><li>文化纲领：马克思主义指导下的新民主主义文化</li><li>基本矛盾：<ul><li>国际：新中国同帝国主义的矛盾</li><li>国内：工人阶级和资产阶级的矛盾</li></ul></li></ul></li><li>完成民主革命的遗留任务，恢复发展经济<ul><li>新生共和国的两大任务：<ul><li>继续完成民主革命的遗留任务</li><li>恢复国民经济</li></ul></li><li>1950年七届三中全会：<ul><li>中心任务：要在三年左右的时间内，争取国家财政经济状况的基本好转。</li><li>毛泽东提出“不要四面出击”。</li></ul></li><li>按照七届三中全会精神，中央政府四项工作：<ul><li>完成民主革命遗留任务：<ul><li>军事上：继续追缴国民党军事力量</li><li>政治上：建立各级人民政权</li><li>经济上：土地改革（保存富农经济）</li><li>社会风俗：废除封建婚姻制度</li><li>社会秩序：镇压反革命</li></ul></li><li>恢复和发展国民经济</li><li>维护国家主权和安全<ul><li>一边倒</li><li>抗美援朝：打碎美军不可战胜的神话</li></ul></li><li>加强党的自身建设：<ul><li>“三反运动”：反贪污、反浪费、反官僚主义</li><li>“五反运动”：打击不法资本家的行贿、偷税漏税、盗骗国家财产、偷工减料、盗窃经济情报等不法行为</li></ul></li></ul></li></ul></li><li>开始向社会主义过渡：<ul><li>没收官僚资本，确立社会主义国营经济领导地位。<ul><li>从反对外国帝国主义的附庸——中国买办资产阶级——的意义上看：具有民主革命的性质</li><li>从反对中国的大资产阶级的意义上看：具有社会主义革命的性质</li></ul></li><li>开始将资本主义纳入国家资本主义轨道。</li><li>引导个体农民走上互助合作道路。</li></ul></li></ol><h4 id="二、选择社会主义道路"><a href="#二、选择社会主义道路" class="headerlink" title="二、选择社会主义道路"></a>二、选择社会主义道路</h4><ol><li>过渡时期总路线的提出：在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、手工业、资本主义工商业的社会主义改造。<font color="orange">（一化三改造）</font></li><li>实行社会主义改造的必要性和条件：<ul><li>社会主义性质的国营经济比较强大，是实现国家工业化的<font color="red">主要基础</font>。</li><li>资本主义经济力量弱小，不可能成为中国工业起飞的基础。</li><li>对个体农业进行社会主义改造是实现国家工业化的必要条件。</li><li>当时的国际环境也促使中国选择社会主义。</li></ul></li></ol><h4 id="三、有中国特点的向社会主义过渡的道路"><a href="#三、有中国特点的向社会主义过渡的道路" class="headerlink" title="三、有中国特点的向社会主义过渡的道路"></a>三、有中国特点的向社会主义过渡的道路</h4><ol><li>社会主义工业化与社会主义改造<font color="red">同时并举</font>。</li><li>农业、手工业改造：<ul><li>农业改造：<ul><li>组织形式：互助组、初级农业合作社、高级农业合作社</li><li>方针：积极发展、稳步前进、逐步过渡</li><li>原则：自愿和互利</li><li>典型示范、逐步推广</li></ul></li></ul></li><li>对资本主义工商业<font color="red">赎买政策</font></li><li>社会主义基本制度在中国的全面确立及其意义：<ul><li>完成标志：1956年三大改造的完成</li><li>意义：<ul><li>为当代中国一切发展进步奠定了根本政治前提和政治制度。</li><li>是中国历史上最深刻最伟大的社会变革。</li><li>使广大劳动人民真正成为国家的主人。</li></ul></li></ul></li></ol><h3 id="六、社会主义建设在探索中曲折发展"><a href="#六、社会主义建设在探索中曲折发展" class="headerlink" title="六、社会主义建设在探索中曲折发展"></a>六、社会主义建设在探索中曲折发展</h3><h4 id="一、社会主义建设的初步探索"><a href="#一、社会主义建设的初步探索" class="headerlink" title="一、社会主义建设的初步探索"></a>一、社会主义建设的初步探索</h4><ol><li>中共八大：<ul><li>主要矛盾：人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。</li><li>主要任务：发展社会生产力</li><li>经济建设方针：既反保守又反冒进，综合平衡稳步前进</li><li>陈云：三个主体三个补充</li></ul></li><li>探索社会主义建设道路的初步成果：<ul><li>《论十大关系》<ul><li>以毛泽东为代表中共党人<font color="red">开始探索</font>中国自己的社会主义道路。</li><li>围绕一个基本方针，即调动国内外一切积极因素，为社会主义服务。</li></ul></li><li>《关于正确处理人民内部矛盾的问题》<ul><li>社会主义社会两类不同性质的矛盾<ul><li>敌我矛盾——专政解决</li><li>人民内部矛盾——民主、说服教育解决<font color="orange">（国家政治生活的主题）</font><ul><li>政治思想领域：团结——批评——团结</li><li>物质利益分配方面：统筹兼顾、适当安排</li><li>科学文化领域：百花齐放，百家争鸣</li><li>共产党和民主党派的矛盾：长期共存，互相监督</li></ul></li></ul></li><li>关于社会主义社会的基本矛盾</li></ul></li></ul></li><li>1957年整风运动：<ul><li>主要内容：反官僚主义、宗派主义和主观主义</li></ul></li></ol><h4 id="二、探索中的严重曲折"><a href="#二、探索中的严重曲折" class="headerlink" title="二、探索中的严重曲折"></a>二、探索中的严重曲折</h4><ol><li>1961年八字方针：调整、巩固、充实、提高</li><li>1962年七千人大会</li></ol><h4 id="三、建设的成就，探索的成果"><a href="#三、建设的成就，探索的成果" class="headerlink" title="三、建设的成就，探索的成果"></a>三、建设的成就，探索的成果</h4><ol><li><p>国际地位的提高与国际环境的改善：</p><ol><li>建国初期“一边倒”</li><li>20世纪50年代外交成就：<ul><li>1953年“和平共处五项原则”<ul><li>最初是印度</li><li>成为处理国与国关系的准则</li></ul></li><li>1954年日内瓦国际会议：中国第一次以世界五大国身份参加</li><li>1955年万隆会议：周恩来提出“求同存异”</li></ul></li><li>20世纪70年代外交成就<ul><li>1971年26届联合国大会恢复新中国五大常任理事国合法席位</li><li>1972年尼克松访华</li><li>1972年日本首相田中角荣访华，中日建交</li><li>毛泽东“三个世界理论”的提出</li></ul></li></ol></li></ol><h4 id="四、如何全面认识毛泽东领导时期中国社会主义建设在探索中曲折前进的历史"><a href="#四、如何全面认识毛泽东领导时期中国社会主义建设在探索中曲折前进的历史" class="headerlink" title="四、如何全面认识毛泽东领导时期中国社会主义建设在探索中曲折前进的历史"></a>四、如何全面认识毛泽东领导时期中国社会主义建设在探索中曲折前进的历史</h4><ol><li>怎样评价这一时期的建设成就？</li></ol><ul><li>良好的开局<ul><li><font color="red">提出</font>实行马克思主义与中国实际“第二次结合”的任务。</li><li>《论十大关系》开始社会主义建设道路的探索。确立中共八大路线，形成了一批早期探索的积极成果。</li><li>发表《正确处理人民内部矛盾的问题》，创立两类矛盾学说。</li></ul></li><li>大跃进和人民公社化运动的<font color="red">挫折</font></li><li>文化大革命的<font color="red">全局性错误</font></li></ul><ol start="2"><li>建设的成就，探索的成果<ul><li>独立的、比较完整的工业体系和国民经济体系的建立。</li><li>人民生活水平的提高与文化、医疗、科技事业的发展。</li><li>国际地位的提高与国际环境的改善。</li></ul></li></ol><h3 id="七、改革开放与现代化建设新时期"><a href="#七、改革开放与现代化建设新时期" class="headerlink" title="七、改革开放与现代化建设新时期"></a>七、改革开放与现代化建设新时期</h3><ol><li><p>关于真理标准问题的讨论：为党重新确立实事求是思想路线，纠正长期以来的“左”倾错误，实现历史性的转折做了思想准备。</p></li><li><p>十一届三中全会：标志着进入现代化建设的新时期</p><ul><li>彻底否定“两个凡是”的错误方针</li><li>高度评价了关于真理标准问题的讨论</li><li>工作重点转移到社会主义现代化建设</li><li>重新确立马克思主义思想路线</li></ul></li><li><p>科学评价毛泽东和毛泽东思想</p><p> 毛泽东虽然在晚年犯了严重错误，但是就他的一生来看，他的功绩是第一位的，错误是第二位的，他为中华人民共和国的缔造和中国社会主义事业的发展，建立了永远不可磨灭的功勋。毛泽东思想是被实践证明了的关于中国革命和建设的正确理论原则和经验总结，是党必须长期坚持的指导思想。</p></li><li><p>12大到18大</p><ul><li>中共十二大（1982年）<ul><li>“建设有中国特色社会主义”命题的提出</li><li>制定全面开创社会主义现代化建设新局面的纲领</li></ul></li><li>中共十三大（1987年）<ul><li>社会主义初级阶段理论</li><li>社会主义初级阶段基本路线</li><li>制定了经济体制改革和政治体制改革的基本任务和奋斗目标</li><li>三步走的战略</li></ul></li><li>中共十四大（1992年）<ul><li>确立社会主义市场经济体制的改革目标</li><li>确立邓小平建设有中国特色社会主义理论在全党的指导地位</li></ul></li><li>中共十五大（1997年）<ul><li>抓住机遇，开拓进取（3次巨变）</li><li>邓小平理论确立为党的指导思想</li><li>确立社会主义初级阶段的基本纲领</li></ul></li><li>中共十六大（2002年）<ul><li>制定全面<font color="red">建设</font>小康社会的行动纲领</li><li>“三个代表”确立为党的指导思想</li></ul></li><li>中共十七大（2007年）<ul><li>总结改革开放以来取得的巨大成就及其根本原因和主要经验</li></ul></li><li>中共十八大（2012年）<ul><li>制定全面<font color="red">建成</font>小康社会的战略部署</li><li>党和人民九十年奋斗、创造、积累的根本成就：<ul><li>中国特色社会主义道路</li><li>中国特色社会主义理论体系</li><li>中国特色社会主义制度</li></ul></li><li>建成中国特色社会主义新部署<ul><li>总依据：社会主义初级阶段</li><li>总布局：五位一体<ul><li>经济</li><li>政治</li><li>文化</li><li>社会</li><li>生态文明建设</li></ul></li><li>总任务：实现社会主义现代化和中华民族伟大复兴</li></ul></li></ul></li></ul></li><li><p>中国特色社会主义实现中华民族伟大复兴的必由之路：</p><ul><li>党的群众教育实践活动</li><li>两个不能否定</li></ul></li><li><p>坚持和发展中国特色社会主义，努力实现“两个一百年”的奋斗目标：</p><ul><li>中共三件大事：<ul><li>进行新民主主义革命，推翻帝国主义、封建主义、官僚资本主义的反动统治，实现了民族独立和人民解放，建立了人民当家作主的新中国。</li><li>进行社会主义革命，创造性地实现由新民主主义到社会主义的转变，确立了社会主义基本制度；开始全面社会主义，在一穷二白的基础上建立了独立的比较完整的工业体系和国民经济体系，使古老的中国以崭新的姿态屹立在世界的东方。</li><li>进行改革开放和社会主义现代化建设，开创、坚持、发展中国特色社会主义，我国的综合国力和人民生活水平大幅度提高，现代化建设取得举世瞩目的伟大成就。</li></ul></li><li>”两个一百年“奋斗目标：<ul><li>到2020年，即中国共产党成立100年时，国内生产总值和城乡居民人均收入在2010年的基础上翻一番，全面建成惠及十几亿人口的小康社会。</li><li>到本世纪中叶，即中华人民共和国成立100周年时，建成富强民主文明和谐的社会主义现代化国家。</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章、反对外国侵略的斗争&quot;&gt;&lt;a href=&quot;#第一章、反对外国侵略的斗争&quot; class=&quot;headerlink&quot; title=&quot;第一章、反对外国侵略的斗争&quot;&gt;&lt;/a&gt;第一章、反对外国侵略的斗争&lt;/h2&gt;&lt;h3 id=&quot;一、西方列强侵略和社会性质转变&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="政治" scheme="https://www.oliverbryant.cn/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>reading</title>
    <link href="https://www.oliverbryant.cn/2021/01/19/reading/"/>
    <id>https://www.oliverbryant.cn/2021/01/19/reading/</id>
    <published>2021-01-19T11:27:37.000Z</published>
    <updated>2021-01-19T11:27:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><h2 id="1-培养根据上下文语义来推测理解单词的能力"><a href="#1-培养根据上下文语义来推测理解单词的能力" class="headerlink" title="1.培养根据上下文语义来推测理解单词的能力"></a>1.培养根据上下文语义来推测理解单词的能力</h2><ol><li>推测方向：<ul><li>大概含义</li><li>情感色彩：正向，负向</li></ul></li><li>推测方法：<ul><li>词根词缀</li><li>逻辑关系<ul><li>顺接逻辑<ul><li>并列</li><li>递进</li><li>因果</li></ul></li><li>转接逻辑<ul><li>转折</li><li>另起一个话题</li></ul></li></ul></li></ul></li></ol><h2 id="2-学习方法"><a href="#2-学习方法" class="headerlink" title="2.学习方法"></a>2.学习方法</h2><ol><li>精细化学习早年的真题阅读文章（2000～2009）。</li><li>精细化学习方法：<ol><li>生词：结合上下文语义理解，优先记住真题中常考的意思。</li><li>长难句：<ul><li>会断句</li><li>会识别句子中的主干（主语、谓语、宾语）和修饰成分（定语、状语、补语），从而实现句子语义的理解。</li></ul></li><li>段落：学会识别段落中心句。<ul><li>What can we infer from Paragraph 3? 从第三段我们能推断出什么？（优先考虑段落大意）</li></ul></li><li>篇章结构：串读每一段的段落大意去判断哪些段落语义上是一个整体。</li><li>对题目进行分析。<ul><li>正确选项：同义替换</li><li>错误选项：无中生有</li></ul></li></ol></li></ol><h2 id="3-阅读分析"><a href="#3-阅读分析" class="headerlink" title="3.阅读分析"></a>3.阅读分析</h2><ol><li>代词还原方法：<ul><li>就近往前找可能的词或句子。</li></ul></li><li>and前后结构相近，先向后找结构，再往前找相似的结构。</li><li>特殊标点符号<ul><li><pre><code>冒号（:）：冒号后若句子长，则对冒号前进行解释说明。</code></pre></li></ul></li><li>论据的常见形式：<ul><li>今昔对比论证</li><li>数据对比论证</li><li>举例论证</li><li>引用论证：引用第三方的观点来论证自己的观点</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h1&gt;&lt;h2 id=&quot;1-培养根据上下文语义来推测理解单词的能力&quot;&gt;&lt;a href=&quot;#1-培养根据上下文语义来推测理解单词的能力&quot; class=&quot;he</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="英语" scheme="https://www.oliverbryant.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>grammer</title>
    <link href="https://www.oliverbryant.cn/2021/01/18/grammer/"/>
    <id>https://www.oliverbryant.cn/2021/01/18/grammer/</id>
    <published>2021-01-18T11:02:31.000Z</published>
    <updated>2021-01-18T11:02:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h2><ul><li>识别句子结构——应对阅读</li><li>理解句子意思——应对翻译</li><li>积累丰富句型——应对写作</li></ul><h2 id="二、规划"><a href="#二、规划" class="headerlink" title="二、规划"></a>二、规划</h2><ul><li>基础阶段：now——2021.6月<ol><li>知识点</li><li>分析长难句（100句）</li><li>积累句型</li></ol></li></ul><h2 id="三、长难句分析方法"><a href="#三、长难句分析方法" class="headerlink" title="三、长难句分析方法"></a>三、长难句分析方法</h2><h3 id="1-句子成分"><a href="#1-句子成分" class="headerlink" title="1.句子成分"></a>1.句子成分</h3><ol><li>主语 Subject ：名词，代词，非谓语动词（不定式和分词）</li><li><strong>谓语</strong> Verb：</li><li>宾语  Object</li><li>表语 Subject complement：补充说明主语的状态<br> 1-4:主干结构</li><li>定语：修饰限定名词</li><li>状语：修饰除名词之外的所有词</li><li>补语</li><li>同位语：补充解释名词，本身也是一个名词<br> 5-8:修饰成分</li></ol><h3 id="2-简单句结构"><a href="#2-简单句结构" class="headerlink" title="2.简单句结构"></a>2.简单句结构</h3><ol><li>主语+谓语（不及物动词）</li><li>主语+谓语（及物动词）+宾语</li><li>主语+谓语+宾语1（间接宾语——人）+宾语2（直接宾语——物）<ul><li>一般动词带有“给”的意思。</li></ul></li><li>主语+谓语+宾语+宾语补足语(Object Complement)<ul><li>I find Hong Kong exceedingly beautiful/a good place for shopping.</li><li>判定：宾语与后面的词之间构成主表或主谓关系。</li></ul></li><li>主语+系动词（Link Verb——是）+表语<ul><li>系动词：feel、touch、look、taste、become、turn、prove、keep、stand</li></ul></li></ol><h3 id="3-复合句结构"><a href="#3-复合句结构" class="headerlink" title="3.复合句结构"></a>3.复合句结构</h3><ol><li>结构：简单句1+简单句2+简单句3+……</li><li>连接方式：<ul><li>标点符号：“；”</li><li>并列连词：and</li><li>引导词：who，which，where</li></ul></li><li>如何破解长难句：<ol><li>断开：<ol><li>寻找谓语动词（is, were, could do, will do） <font color=red>注意done</font></li><li>寻找并列连词（and, but, or, not only…but also…）</li><li>寻找引导词（wh- ,if, while, how）</li><li>标点辅助</li></ol></li><li>简化：<ol><li>去修饰：介词短语，非谓语，定语，状语</li><li>找核心：句子主干</li></ol></li><li>谓语动词的数量=连词的数量+1（主干的谓语动词）</li></ol></li></ol><h3 id="4-名词性从句"><a href="#4-名词性从句" class="headerlink" title="4.名词性从句"></a>4.名词性从句</h3><ol><li>名词：<ol><li>成分：主语、宾语、表语、同位语。</li></ol></li><li>名词性从句：从句一定是陈述句形势<ol><li>引导词类型：<ul><li>that：本身从句是陈述句。只起连接作用，不充当任何成分。</li><li>whether：“是否”。原本从句是一般疑问句。只起连接作用，不充当任何成分</li><li>特殊疑问词（when, which,where,who……）：从句是特殊疑问句，有具体的意思。在从句中充当成分。</li></ul></li><li>主语从句： <u>What I saw</u> looks attractive.</li><li>宾语从句：I appreciate <u>what his mother said</u>. </li><li>表语从句：Gump is <u>who we should admire</u>. </li><li>同位语从句：I enjoy the part, <u>that a feather is flying in the sky</u>. 同位语从句</li><li>考点：<ol><li>主语从句中的that不可省略。</li><li>形式主语：That she has got divorced seems conspicuous.=It seems conspicuous that she has got divorced.<ul><li>It is 形容词/名词+to do sth</li><li>It is 形容词_名词+that_who/when……</li><li>It is 形容词/名词+doing sth</li></ul></li><li>宾语从句和表语从句的that可以省略。</li><li>形式宾语：I appreciate it what his mother said.</li><li>同位语从句的that不可省略。</li></ol></li></ol></li></ol><h3 id="5-定语从句（形容词性从句）"><a href="#5-定语从句（形容词性从句）" class="headerlink" title="5.定语从句（形容词性从句）"></a>5.定语从句（形容词性从句）</h3><ol><li>定语：<ol><li>用来限定修饰名词</li><li>成分：形容词，介词短语，非谓语动词</li><li>前小后大</li><li>结构：<ul><li>名词+形容词性短语：The lady full of smile is Mary.</li><li>名词+介词短语：The lady in blue is Mary.</li><li>名词+非谓语动词（to do，doing，done）：The lady kissed by me is Mary.</li></ul></li></ol></li><li>定语从句：<ol><li>功能：修饰限定前面的名词、代词、名词性短语或句子。</li><li>构成：先行词+引导词<ul><li>先行词：名词性成分</li><li>引导词：才从句当中充当成分<ul><li>关系代词：充当主语，宾语，表语（充当宾语引导词可以省略）<ul><li>who</li><li>whom</li><li>whose</li><li>that</li><li>which</li></ul></li><li>关系副词：充当状语<ul><li>when=on which</li><li>where=in which</li><li>why=for which</li><li>whereby=by which</li></ul></li></ul></li></ul></li><li>分类：<ul><li>限定性定语从句：定语从句与先行词的关系特别紧密，去掉之后意思不完整。<br>  He will wear no clothes which will make him different from his fellow men.</li><li>非限定性定语从句：定语从句与先行词的关系并不紧密，可以去掉。<ul><li>，+which：放在先行词后</li><li>as-：可前可中可后<br>  He will wear no clothes, which will make him different from his fellow men.他不穿衣服，这使得他和他的同伴截然不同。</li></ul></li></ul></li><li>多对一定语从句：<br> 名词+::定语从句1+定语从句2+定语从句3::</li><li>先后嵌套性定语从句：<br> 名词+::定语从句1::+定语从句2+定语从句3</li></ol></li></ol><h3 id="6-状语从句"><a href="#6-状语从句" class="headerlink" title="6.状语从句"></a>6.状语从句</h3><ol><li>状语：<ol><li>功能：修饰动词，副词，形容词，句子。</li><li>位置：随便放<br> China ,frankly speaking/in effect, will catch up with the developed countries .</li><li>成分：副词，介词短语，非谓语动词，从句。</li></ol></li><li>状语从句：<ol><li>实质：用一个从句修饰主句来体现两句之间的某种逻辑关系。</li><li>类别：<ul><li>时间状语从句：<ul><li>when,while,as：当……的时候</li><li>not … until：直到……才</li><li>before,after：……前，……后</li><li>before long：不久之后</li><li>long before：很久之前</li><li>As soon as,hardly… when,no sooner … than,the moment,the minute：一……就</li></ul></li><li>地点状语从句：<ul><li>where,everywhere,no matter where=wherever</li><li>like;as;just as;as if-好像=as though：就像……一样；正如；按照……的方式</li><li>The way：按照……的方式</li></ul></li><li>原因状语从句：<ul><li>由于：because,for+句子,since,in that,now that</li><li>考虑到……：considering that,given that,seeing that</li><li>because of,due to,owing to,thanks to+名词短语</li></ul></li><li>方式状语从句：</li><li>条件状语从句：<ul><li>如果：if,assuming that,supposing_supposed that,providing_provide that</li><li>除非：unless,if not</li><li>……条件下：on condition that</li><li>只有，只要：as long as,only if</li><li>要是……就好了：if only</li></ul></li><li>结果状语从句：<ul><li>结果，因此：so,(thus,therefore,hence)——副词，不能连接句子</li><li>因此……以致于：so… that… ,such… that… </li><li>为了：in order that… ;so that（情态动词can,could,might,must,should）</li><li>以防：in case,lest,for fear that</li></ul></li><li>目的状语从句：</li><li>让步状语从句：<ul><li>虽然，尽管，即使，不管：although=though=even though=even if</li><li>while</li><li>no matter who=whoever,no matter how=however,no matter when=whenever</li><li>as<br>  Although he is a king, he is unhappy.<br>  King as he is, he is unhappy.<br>  Although it is simple, the cartoon is thought-provoking.<br>  Simple as it is, the cartoon is thought-provoking. </li></ul></li><li>条件状语从句：</li></ul></li><li>状语从句省略：如果状语从句的主语与主句的主语保持一致，而且状语从句的谓语动词有系动词的话，那么，状语从句的主语和系动词可以省略。</li></ol></li></ol><h3 id="7-插入语"><a href="#7-插入语" class="headerlink" title="7.插入语"></a>7.插入语</h3><ol><li>类型：<ul><li>——XXX——：一定是插入语</li><li>，XXX，：可能是插入语，要看第一个逗号前语义是否完整。若语义不完整，则为插入语；若语义完整，则为自然断句。</li><li>短语且较短，没有标点，也能称为插入语。</li></ul></li><li>分析方法：<ul><li>先看两边，再看中间。把插入语前后连接起来，是一个完整的句子。中间的插入语部分是对句子的补充说明。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;h2 id=&quot;一、目标&quot;&gt;&lt;a href=&quot;#一、目标&quot; class=&quot;headerlink&quot; title=&quot;一、目标&quot;&gt;&lt;/a&gt;一、目标&lt;/h</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="英语" scheme="https://www.oliverbryant.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Advanced_Mathematics</title>
    <link href="https://www.oliverbryant.cn/2021/01/16/Advanced-Mathematics/"/>
    <id>https://www.oliverbryant.cn/2021/01/16/Advanced-Mathematics/</id>
    <published>2021-01-16T11:56:37.000Z</published>
    <updated>2021-01-16T11:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="第一章-函数、极限与连续性"><a href="#第一章-函数、极限与连续性" class="headerlink" title="第一章 函数、极限与连续性"></a>第一章 函数、极限与连续性</h2><h3 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h3><ol><li><p>概念：</p><ul><li><p>定义：设x，y是两个变量，D是实数集的某个子集，若对于D中的每个值x，按照一定的法则有唯一确定的值y与之对应，则称变量y为变量x的函数，记作y=f(x)，数集D称为函数的定义域，由函数对应法则或实际问题的要求来确定，相应的函数值的集合称为函数的值域。</p></li><li><p>函数的两要素：</p><ul><li><p>定义域<br>  $$<br>  \frac1{f\left(x\right)},f\left(x\right)\neq0;\sqrt[2n]{f\left(x\right)},f(x)\geq0;\ln f(x),\log_af(x),f(x)&gt;0;arc\sin f(s),arc\cos f(x),\left|f(x)\right|\leq1<br>  $$</p></li><li><p>对应法则</p></li></ul></li></ul></li><li><p>几何特性：</p><ol><li><p>奇偶性：</p><ul><li><p>定义：</p><ul><li><p>奇函数：<br>  $$<br>  f(-x)=-f(x)<br>  $$</p></li><li><p>偶函数：<br>  $$<br>  f(-x)=f(x)<br>  $$</p></li></ul></li><li><p>常见的奇偶函数：</p><ul><li><p>奇函数：<br>  $$<br>  x^{2n},\left|x\right|,\cos(x),sec(x),e^x+e^{-x}<br>  $$</p></li><li><p>偶函数：<br>  $$<br>  x^{2n+1},\sin x,\tan x,arc\sin x,arc\tan x,e^x-e^{-x},\ln(x+\sqrt{1+x^2})<br>  $$</p></li></ul></li><li><p>注：</p><ul><li>奇函数+奇函数=奇函数；奇函数+偶函数=不一定；偶函数+偶函数=偶函数</li><li>偶函数关于y轴对称。</li><li>奇函数关于原点对称；若在原点有定义，f(0)=0.</li></ul></li></ul></li><li><p>周期性：</p><ul><li><p>定义：<br>  $$<br>  f(x+T)=f(x)<br>  $$</p></li><li><p>常见函数：<br>  $$<br>  \sin x,\cos x,\tan x,cotx,secx,cscx,C(\mathrm{常数函数})<br>  $$</p></li></ul></li><li><p>单调性：</p><ul><li><p>定义：</p><ul><li><p>单调递增：<br>  $$<br>  \forall x_1&lt;x_2\in I,f(x_1)&lt;f(x_2)<br>  $$</p></li><li><p>单调递减：<br>  $$<br>  \forall x_1&lt;x_2\in I,f(x_1)&gt;f(x_2)<br>  $$</p></li></ul></li><li><p>判定：</p><ul><li>若f’(x)&gt;0，则f(x)单调递增，反之递减。</li><li>f’(x)&gt;=0且等号仅在有限个点成立，则f(x)单调递增，反之递减。</li></ul></li></ul></li><li><p>有界性：</p><ul><li><p>定义：<br>  $$<br>  \forall x\in I,\exists M&gt;0,使\left|f(x)\right|\leq M,则I上f(x)\mathrm{有界}<br>  $$</p></li><li><p>常见函数：<br>  $$<br>  sinx,cosx,arctanx,C<br>  $$</p></li><li><p>判定：</p><ul><li>f(x)在</li></ul></li></ul></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高等数学&quot;&gt;&lt;a href=&quot;#高等数学&quot; class=&quot;headerlink&quot; title=&quot;高等数学&quot;&gt;&lt;/a&gt;高等数学&lt;/h1&gt;&lt;h2 id=&quot;第一章-函数、极限与连续性&quot;&gt;&lt;a href=&quot;#第一章-函数、极限与连续性&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="数学" scheme="https://www.oliverbryant.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Marxism</title>
    <link href="https://www.oliverbryant.cn/2021/01/11/Marxism/"/>
    <id>https://www.oliverbryant.cn/2021/01/11/Marxism/</id>
    <published>2021-01-11T12:51:58.000Z</published>
    <updated>2021-07-01T09:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：马克思主义是关于无产阶级和人类解放的科学"><a href="#第一章：马克思主义是关于无产阶级和人类解放的科学" class="headerlink" title="第一章：马克思主义是关于无产阶级和人类解放的科学"></a>第一章：马克思主义是关于无产阶级和人类解放的科学</h2><h3 id="一、马克思主义的主要含义"><a href="#一、马克思主义的主要含义" class="headerlink" title="一、马克思主义的主要含义"></a>一、马克思主义的主要含义</h3><ol><li>马克思主义是由马克思和恩格斯创立并为后继者不断发展的科学理论体系。</li><li>马克思主义是：<ol><li>研究自然、人类社会、思维规律的学说。</li><li>研究无产阶级解放，每个人自由全面发展的学说。</li><li>社会主义必然代替资本主义最终实现共产主义的学说。</li></ol></li><li>马克思主义包括：<ol><li>马克思主义哲学：德国古典哲学<ul><li>黑格尔：<font color=red>辩证</font>的唯心</li><li>费尔巴哈：形而上学的<font color=red>唯物</font></li></ul></li><li>马克思主义政治经济学：英国古典政治经济学<ul><li>大卫李嘉图</li><li>亚当斯密</li></ul></li><li>科学社会主义：英法两国空想社会主义学说（没实践，没道路）<font color=orange>列宁找到了道路</font><ul><li>圣西门</li><li>傅立叶</li><li>欧文</li></ul></li></ol></li></ol><h3 id="二、马克思主义的特点"><a href="#二、马克思主义的特点" class="headerlink" title="二、马克思主义的特点"></a>二、马克思主义的特点</h3><ol><li>科学性：马克思主义是对自然、社会和人类思维发展本质和规律的正确反映。</li><li>革命性：马克思主义集中表现了彻底的批判精神和鲜明的无产阶级立场。</li><li><font color=red>实践性</font>：马克思主义是从实践中来，到时间中去，在实践中接受检验，并随实践而不断发展的学说。（改造世界）</li><li>发展<u>开放</u>性：<ol><li>发展性：马克思主义是不断发展的学说，具有与时俱进的理论品质。</li><li>开放性：马克思主义不断吸收人类历史上一切优秀思想文化成果而不断丰富自己。</li></ol></li><li>人民性：阶级性，人民至上。</li></ol><h3 id="三、马克思主义产生的前提"><a href="#三、马克思主义产生的前提" class="headerlink" title="三、马克思主义产生的前提"></a>三、马克思主义产生的前提</h3><ol><li>科学前提：<ol><li>细胞学说的提出</li><li>能量守恒和转化定律</li><li>生物进化论</li></ol></li><li>社会前提：<ol><li>法国里昂工人起义</li><li>德国西里西亚纺织工人起义</li><li>英国宪章运动</li></ol></li></ol><h3 id="四、马克思主义的当代价值"><a href="#四、马克思主义的当代价值" class="headerlink" title="四、马克思主义的当代价值"></a>四、马克思主义的当代价值</h3><ol><li>观察当代世界变化的认识工具。</li><li>指引当代中国发展的行动指南。</li><li>引领人类社会进步的科学真理。</li></ol><h3 id="五、马克思主义产生的条件"><a href="#五、马克思主义产生的条件" class="headerlink" title="五、马克思主义产生的条件"></a>五、马克思主义产生的条件</h3><p>​    经济条件、社会条件、思想条件</p><ol><li>资本主义经济的发展为马克思主义的产生提供了经济、社会历史条件。</li><li>无产阶级在反抗资产阶级剥削和压迫的斗争中，逐步走向自觉，并迫切渴望科学的理论指导。</li><li>马克思恩格斯的革命实践和对人类文明成果的继承与创新。</li></ol><h2 id="第二章：世界的物质性及发展规律"><a href="#第二章：世界的物质性及发展规律" class="headerlink" title="第二章：世界的物质性及发展规律"></a>第二章：世界的物质性及发展规律</h2><h3 id="一、哲学"><a href="#一、哲学" class="headerlink" title="一、哲学"></a>一、哲学</h3><ol><li>哲学是关于<font color=red>世界观</font>的学说，是对各门具体科学知识的概括和总结，是理论化，系统化的世界观和方法论的统一。</li><li>两个方面的内容：<ol><li>存在和思维究竟谁是世界的本原，即物质和精神何者是第一性、何者是第二性的问题。</li><li>思维能否正确认识存在，即思维和存在有无同一性的问题。</li></ol></li><li>马克思主义哲学是科学的世界观和方法论的统一。</li></ol><h3 id="二、世界观"><a href="#二、世界观" class="headerlink" title="二、世界观"></a>二、世界观</h3><ol><li>人们对整个世界及任何世界关系的根本观点和总体看法。</li><li>特点：<ul><li>朴素性</li><li>零散性</li></ul></li></ol><h3 id="三、哲学与具体科学间的关系"><a href="#三、哲学与具体科学间的关系" class="headerlink" title="三、哲学与具体科学间的关系"></a>三、哲学与具体科学间的关系</h3><ol><li>哲学研究一般规律。</li><li>具体科学研究具体知识。</li><li>哲学为具体科学提供指导作用。</li><li>具体科学是哲学的前提和基础。</li><li>关系：<ul><li>一般与个别</li><li>共性与个性</li><li>普遍与特殊</li><li>抽象与具体</li></ul></li></ol><h3 id="四、哲学的派别"><a href="#四、哲学的派别" class="headerlink" title="四、哲学的派别"></a>四、哲学的派别</h3><ol><li><p>唯物论：<font color=red>物质决定意识</font></p><ol><li><p>古代朴素唯物主义：概括为某种或某几种“实物”<font color=orange>（“水”、“五行”、“气”）</font></p></li><li><p><span id="旧唯物主义">近代形而上学唯物主义</span><font color=orange>（机械唯物主义、半截子唯物主义）</font>：“原子”、原初物质</p><p>缺陷：</p><ul><li>机械性：把所有运动归为机械运动</li><li>形而上学性：<ul><li>片面：只见树木不见森林</li><li>孤立：一叶障目不见泰山</li><li>静止：刻舟求剑</li></ul></li><li>不彻底性：自然方面是唯物主义，历史方面是唯心主义</li></ul></li><li><p><span id="辩证唯物主义">辩证历史唯物主义</span><font color=orange>（马克思主义）</font>：客观实在性。</p><ul><li>辩证性：<ul><li>全面</li><li>联系</li><li>发展</li></ul></li></ul></li></ol></li><li><p>唯心论：<font color=red>意识决定物质</font></p><ol><li><span id="主观唯心主义">主观唯心主义</span>：<ul><li>心外无物，心外无理</li><li>存在即被感知</li><li>非风动，非幡动，仁者心动</li><li>我思故我在</li><li>人有多大胆，地有多大产</li></ul></li><li><span id="客观唯心主义">客观唯心主义</span>：<font color=red>精神载体</font><ul><li>神</li><li>上帝</li><li>鬼</li><li>命</li><li>道</li><li>绝对精神（黑格尔）</li><li>未有此事，已有此理，理在事先</li></ul></li></ol></li></ol><h3 id="五、意识对物质的作用"><a href="#五、意识对物质的作用" class="headerlink" title="五、意识对物质的作用"></a>五、意识对物质的作用</h3><ol><li>可知论<font color=orange>（有作用）</font>：世界是可以被认识的，思维和存在具有同一性</li><li>不可知论<font color=orange>（没作用）</font>：世界是不能被人所认识或不能被完全认识的，否认思维和存在的同一性。</li></ol><h3 id="六、物质"><a href="#六、物质" class="headerlink" title="六、物质"></a>六、物质</h3><p>​    列宁提出物质：不依赖于人的意识并能为人的意识所反映的客观实在。</p><h3 id="七、马克思物质观的理论意义"><a href="#七、马克思物质观的理论意义" class="headerlink" title="七、马克思物质观的理论意义"></a>七、马克思物质观的理论意义</h3><ol><li>坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。</li><li>坚持了能动的反映论和可知论，有力地批判了不可知论。</li><li>体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷。</li><li>体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了理论基础。</li></ol><h3 id="八、物质的根本属性和物质运动的存在形式"><a href="#八、物质的根本属性和物质运动的存在形式" class="headerlink" title="八、物质的根本属性和物质运动的存在形式"></a>八、物质的根本属性和物质运动的存在形式</h3><ol><li>物质的根本属性：运动。</li><li><font color=orange>（绝对）</font>运动<ol><li>标志着一切事物和现象的变化及其过程的哲学范畴。</li><li>时间：<ul><li>事物运动过程的持续性和顺序性</li><li>特点：一维性（不可逆性）</li></ul></li><li>空间：<ul><li>事物运动过程的广延性和伸张性</li><li>特点：三维性</li></ul></li><li>是物质的存在方式和根本属性。</li><li>物质是一切运动变化和发展过程的实在基础和承担者。</li></ol></li><li><font color=orange>（相对）</font>静止<ol><li>没有位移/没有质变</li><li>静止是物质运动在一定条件下的稳定状态。</li></ol></li></ol><h3 id="九、实践"><a href="#九、实践" class="headerlink" title="九、实践"></a>九、实践</h3><ol><li>定义：是自然存在与社会存在区分的统一的基础。</li><li>实践是自然存在与社会存在区分和统一的基础。<ul><li>实践是使物质世界分化为自然界与人类社会的历史前提，又是使自然界与人类社会统一起来的显示基础。</li><li>实践是人类社会的基础，是理解和解释一切社会现象的钥匙。</li></ul></li><li>社会生活的实践性主要表现在：<ol><li>实践是社会关系形成的基础。</li><li>实践形成了社会生活的基本领域。</li><li>实践构成了社会发展的动力。</li></ol></li></ol><h3 id="十、意识"><a href="#十、意识" class="headerlink" title="十、意识"></a>十、意识</h3><ol><li>客观存在于大脑中所形成的主观映像。</li><li>意识是人脑的<font color=red>特有机能</font>，是客观世界的主观映像。</li></ol><h3 id="十一、物质和意识的辩证关系"><a href="#十一、物质和意识的辩证关系" class="headerlink" title="十一、物质和意识的辩证关系"></a>十一、物质和意识的辩证关系</h3><ol><li>物质决定意识。</li><li>意识依赖于物质并反作用于物质。</li><li>意识的起源：<ul><li>自然界发展的产物<ul><li>低等生物的应急性</li><li>高等动物的感觉和心理</li><li>人类的意识</li></ul></li><li>社会历史发展的产物：社会实践&rarr;<font color=orange>劳动</font></li></ul></li><li>意识的本质：是客观内容和主观形式的统一。<ul><li>内容：<font color=orange>客观</font></li><li>形式：<font color=orange>主观</font></li></ul></li><li>意识对物质具有反作用（能动作用）：<ol><li>意识活动具有目的性，计划性。</li><li>意识活动具有创造性。</li><li>意识活动指导实践改造客观世界的作用。</li><li>意识活动控制人的行为和生理活动的作用。</li></ol></li></ol><h3 id="十二、主观能动性和客观规律性的统一"><a href="#十二、主观能动性和客观规律性的统一" class="headerlink" title="十二、主观能动性和客观规律性的统一"></a>十二、主观能动性和客观规律性的统一</h3><ol><li>主观能动性和客观规律性的关系：<ul><li>尊重客观规律是正确发挥主观能动性的前提。</li><li>只有正确发挥主观能动性，才能正确认识和利用客观规律。</li></ul></li><li>正确发挥主观能动性的途径：<ul><li>从实际出发，努力认识和把握事物的发展规律。</li><li>实践是坚持人的主观能动性的基本途径。</li><li>主观能动性的发挥还依赖一定的物质条件和物质手段。<font color=orange>”巧妇难为无米之炊“</font></li></ul></li></ol><h3 id="十三、世界的物质性统一原理"><a href="#十三、世界的物质性统一原理" class="headerlink" title="十三、世界的物质性统一原理"></a>十三、世界的物质性统一原理</h3><ol><li><p>物质性：</p><ul><li>世界是统一的。<font color=orange>（世界的本原是唯一的）</font></li><li>世界的统一性在于其物质性。</li><li>物质世界的统一性又是多样性的统一，而不是单一无差别的统一。</li></ul></li><li><p>生产方式：</p><ul><li><p>生产力：人们改造自然的能力。<font color=orange>（人与自然）</font></p><ul><li>实体性因素：<ul><li>劳动者</li><li>劳动工具</li><li>劳动资料（对象）</li></ul></li><li>非实体性因素<font color=orange>（非独立的附着的渗透形因素）</font>：<ul><li>管理</li><li>科技</li></ul></li></ul></li><li><p>生产关系：在社会生活中所形成的人与人之间的关系。<font color=orange>（人与人/社会）</font>&rarr;<font color=#FF00D4>经济关系</font></p><ul><li>生产资料的归属</li><li>产品消费品如何分配</li><li>人们在社会生活中的地位及其关系如何</li></ul></li></ul></li><li><p>理论意义：是马克思主义哲学的基石。</p></li><li><p>实践意义：是我们一切工作地立足点，要求我们一切从实际出发，实事求是。</p></li></ol><h3 id="十四、联系"><a href="#十四、联系" class="headerlink" title="十四、联系"></a>十四、联系</h3><ol><li>事物与事物之间，事物内部各要素之间相互作用、相互依存、相互制约的关系。</li><li>特点：<ul><li>普遍性：<ul><li>内在结构性。</li><li>同<font color=red>周围</font>其他事物联系，不能孤立存在。</li><li>整个世界是相互联系的统一整体。&rarr;<font color=#FF00D4>（物质）</font><font color=#3ACCE2>经济关系</font></li></ul></li><li>客观性：防止主观臆断。<font color=orange>“乌鸦叫丧，喜鹊叫喜”</font></li><li>多样性：<ul><li>直接联系/间接联系</li><li>内部联系/外部联系</li><li>必然联系/偶然联系</li><li>现象联系/本质联系</li><li>…………</li></ul></li><li>条件性：条件：对事物存在和发展发生作用的诸要素的总和。<ul><li>条件对事物的发展起促进（支持）或制约作用。</li><li>条件可以改变。人们经过努力可以制造出事物发展所需要的条件。</li><li>改变和制造条件不是任意的，必须要遵循事物发展的客观规律。</li></ul></li></ul></li></ol><h3 id="十五、发展"><a href="#十五、发展" class="headerlink" title="十五、发展"></a>十五、发展</h3><ol><li>发展是前进的上升的运动。</li><li>发展的实质是新事物的产生，旧事物的消亡。新事物代替旧事物的过程。</li><li>新事物：合乎历史前进方向，具有远大前途的东西。<font color=red>新事物是不可战胜的</font></li><li>旧事物：丧失历史必然性，日趋灭亡的东西。</li></ol><h3 id="十六、联系和发展的普遍性"><a href="#十六、联系和发展的普遍性" class="headerlink" title="十六、联系和发展的普遍性"></a>十六、联系和发展的普遍性</h3><p>​    联系的观点和发展的观点是唯物辩证法的总特征，总观点。</p><h3 id="十七、事物普遍联系原理的方法论意义"><a href="#十七、事物普遍联系原理的方法论意义" class="headerlink" title="十七、事物普遍联系原理的方法论意义"></a>十七、事物普遍联系原理的方法论意义</h3><p>​    要求人们善于分析事物的具体联系，确立整体性，开放性的观念，从动态当中考察事物的普遍联系。</p><h3 id="十八、整体和部分的关系"><a href="#十八、整体和部分的关系" class="headerlink" title="十八、整体和部分的关系"></a>十八、整体和部分的关系</h3><ol><li>整体：事物发展的全局或全过程。</li><li>部分：事物发展的局部和各阶段。</li><li>整体为“一”、部分为“多”。</li><li>整体&gt;各部分功能之和。</li><li>整体具有部分不具有的功能。</li></ol><h3 id="十九、事物发展的过程性"><a href="#十九、事物发展的过程性" class="headerlink" title="十九、事物发展的过程性"></a>十九、事物发展的过程性</h3><ol><li>过程：一切事物都有其产生、发展和转化为其他事物的历史，都有其过去，现在和将来。</li><li>发展的过程性：自然界，人类社会，人的思维领域中的一切现象作为过程而存在的，作为过程而发展的。</li><li>恩格斯说：“世界不是既成事物的集合体，而是过程的集合体。”</li><li>事物发展的过程性原理的方法论：用历史的眼光看问题，把一切事物如实地看作是变化、发展过程。既要了解它们的过去，观察它们的现在，又要预见它们的未来。<font color=red>发展的眼光看问题</font>&rarr;<font color=orange>“士别三日当刮目相看”</font></li></ol><h3 id="二十、辩证法"><a href="#二十、辩证法" class="headerlink" title="二十、辩证法"></a>二十、辩证法</h3><h4 id="一、一个核心"><a href="#一、一个核心" class="headerlink" title="一、一个核心"></a>一、一个核心</h4><p>​    对立统一规律：是唯物辩证法的实质和核心。</p><ol><li>揭示了两大总特征<font color=orange>(联系和发展)</font></li><li>贯穿其他规律的范畴</li><li>提供了<font color=red>矛盾分析法</font></li><li>是唯物辩证法和形而上学法对立的实质<font color=red>(矛盾)</font></li></ol><h4 id="二、两大总特征"><a href="#二、两大总特征" class="headerlink" title="二、两大总特征"></a>二、两大总特征</h4><ol><li>联系</li><li>发展</li></ol><h4 id="三、三大规律"><a href="#三、三大规律" class="headerlink" title="三、三大规律"></a>三、三大规律</h4><ol><li><p>矛盾</p><ol><li><p>马克思主义哲学的矛盾是辩证矛盾，是一种客观的存在，不可以避免．</p></li><li><p>矛盾即对立统一：</p><ol><li><p>矛盾同一性和斗争性辩证关系原理：</p><ul><li>同一性：相互依存，相互贯通</li><li>斗争性：相互分离，相互排斥</li></ul></li><li><p>区别：</p><ol><li>同一性相对的有条件的</li><li>斗争性绝对的无条件的</li></ol></li><li><p>联系<font color=orange>（相互依存）</font>：</p><ol><li>斗争性离不开同一性，斗争性寓于同一性之中．</li><li>同一性离不开斗争性，同一性以斗争性为前提和基础．</li></ol></li><li><p>方法论意义：</p><p> 在对立中把握同一，从同一中把握对立，<font color=red>运用一分为二的观点看问题</font>。</p></li></ol></li><li><p>矛盾的普遍性和特殊性：</p><ol><li>矛盾普遍性和特殊性辩证关系原理：<ul><li>共性：无处不在，无时不有——承认矛盾、分析矛盾、解决矛盾</li><li>个性：各有特点——具体问题具体分析<font color=orange>（马克思主义活的灵魂）</font></li></ul></li><li>区别：<ul><li>共性是绝对的无条件的</li><li>个性是相对的有条件的</li></ul></li><li>联系<font color=orange>（相互依存）</font>：<ul><li>共性寓于个性之中，并通过个性表现出来</li><li>个性都包含着共性，没有脱离共性的纯粹个性</li></ul></li><li>方法论意义：<ol><li>矛盾共性于个性的道理是唯物辩证法关于矛盾问题的精髓。</li><li>认识事物：从个别——一般——个别。</li><li>马克思主义普遍真理与中国具体实际相结合的哲学基础。</li></ol></li></ol></li><li><p>矛盾不平衡性原理：</p><ol><li>诸多矛盾：<font color=red>主要矛盾</font>、次要矛盾</li><li>同一矛盾：<font color=red>主要方面</font>、次要方面</li><li>内外矛盾：<font color=red>内部原因</font>、外部原因</li><li>方法论：两点论<font color=orange>（全面的观点）</font>、重点论相结合。</li></ol></li><li><p><font color=red>矛盾分析法——最根本的认识方法</font>：</p><ul><li><font color=red>同一性和斗争性</font>：对立中把握同一，同一中把握对立</li><li>普遍性：承认、分析、解决矛盾</li><li>特殊性：具体问题具体分析</li><li><font color=red>普遍性和特殊性</font>：个别——一般——个别</li><li>不平衡性：两点论、重点论相结合</li></ul></li></ol></li><li><p>质量互变规律</p><ol><li>概念：<ul><li>质：事物区别于其他事物的内在规定性。<font color=orange>（质与事物具有直接的同一性）</font></li><li>量：事物的规模、程度、速度等可以用数量关系表示的规定性。<font color=orange>（精确化）</font></li><li>度：保持事物质的稳定性的数量界限，即事物的范围、幅度和限度。</li></ul></li><li>质变量变辩证关系：<ul><li>量变是质变的<font color=red>必要准备</font>。</li><li>质变是量变的<font color=red>必然结果</font>。</li><li>量变与质变是<font color=red>相互渗透</font>。<ul><li>部分质变</li><li>阶段性质变</li></ul></li><li>量变和质变是<font color=red>贯通发展</font>。<font color=orange>（相互转化）</font></li></ul></li><li>方法论：<ul><li>重视量的积累，不失时机促进质的飞跃。</li><li>坚持<font color=red>适度</font>原则、防止“过”或“不及”。</li></ul></li></ol></li><li><p>否定之否定规律：</p><ol><li>概念：<ul><li>肯定因素：维持现存事物存在的因素</li><li>否定因素：促使事物灭亡的因素</li><li><font color=red>否定因素</font>代表事物的发展方向。</li></ul></li><li>辩证否定观与形而上学否定观：<ol><li>辩证法和形而上学的区别：是否坚持联系、发展、全面</li><li>辩证否定观和形而上学否定观的区别：<ul><li>是否坚持联系、发展</li><li>是否坚持全面</li><li>辩证否定观认为事物发展是由于事物的内因，而形而上学否定观认为事物发展是由于事物的外因。</li></ul></li><li>辩证否定观的方法论：<ul><li>坚持全面的观点看问题</li><li>反对肯定一切</li><li>反对否定一切</li></ul></li></ol></li><li>两次否定：肯定——否定——否定之否定<font color=orange>（肯定）</font></li><li>方法论意义：<ul><li>事物发展前进性<font color=orange>（方向）</font>和曲折性<font color=orange>（道路）</font>的统一。</li><li>每一次否定都是质变，都把事物推到新阶段。</li><li>其中有暂时的停顿或倒退，经过曲折终将为事物的发展开辟道路。<font color=red>坚信前途是光明的</font>，<font color=red>准备好走曲折的道路</font>。</li></ul></li></ol></li></ol><h4 id="四、四对方法"><a href="#四、四对方法" class="headerlink" title="四、四对方法"></a>四、四对方法</h4><h4 id="五、五对范畴"><a href="#五、五对范畴" class="headerlink" title="五、五对范畴"></a>五、五对范畴</h4><ol><li>原因与结果<ul><li>含义：揭示事物的<font color=red>前后相继，彼此制约的关系</font>范畴。</li><li>原因：引起某种现象的现象</li><li>结果：被某种现象引起的现象</li><li>关系：<ul><li>对立：二者的区分是确定的<font color=orange>（绝对性，无条件性）</font></li><li>统一：区分是不确定的，<font color=red>互为因果，互相渗透，复杂多样。</font></li></ul></li><li>方法论：<ul><li>凡事预则立，不预则废</li><li>增强活动自觉性、预见性、调控性</li><li>有因必有果——未雨绸缪<font color=orange>（多种善因）</font></li><li>有果必有因——对症下药</li></ul></li></ul></li><li>必然与偶然<ul><li>含义：揭示客观事物<font color=red>发生、发展和灭亡的不同趋势</font>的范畴。</li><li>必然：一定会发生，确定不移的趋势</li><li>偶然：并非确定发生，不确定的趋势</li><li>关系：<ul><li>对立：<ul><li>必然产生于事物内部的根本矛盾，而偶然产生于外部因素。</li><li>必然在事物发展中占支配地位，起决定性作用；偶然占从属地位，不起决定性作用。</li></ul></li><li>统一：<ul><li>必然存在于偶然中，大量的偶然之后隐藏着必然性。</li><li>二者在一定条件下可以相互转化。</li></ul></li></ul></li><li>方法论：<ul><li>重视事物发展的必然</li><li>把握事物发展的总趋势</li><li>善于从偶然中发现必然，把握有利于事物发展的机遇</li></ul></li></ul></li><li>现实与可能<ul><li>含义：揭示事物的<font color=red>过去、现在和将来的相互关系</font>的范畴。</li><li>现实：相互联系着的实际存在的事物的综合。</li><li>可能：包含在事物中并预示事物发展前途的种种趋势。</li><li>关系：<ul><li>对立：可能不等于现实，现实已经不是可能。</li><li>统一：相互依存<font color=orange>（前提）</font>、相互渗透<font color=orange>（包含）</font>、相互转化<font color=orange>（一定条件下）</font></li></ul></li><li>方法论：<ul><li>立足现实，展望未来</li><li>分析事物发展的各种可能，发挥主观能动性</li></ul></li></ul></li><li>本质与现象<ul><li>含义：揭示客观事物的<font color=red>内在联系和外部表现相互关系</font>的范畴。</li><li>假象：错误歪曲的反映本质——客观范畴——与人无关</li><li>错觉：感官获得认识但与事实有偏差——主观范畴——与人有关</li><li>关系：<ul><li>对立：<ul><li>本质是事物的根本性质，现象是事物的外部联系和表面特征。</li><li>本质是一般的、普遍的，现象是个别的，具体的</li></ul></li><li>统一：相互依存</li></ul></li><li>方法论：透过现象看本质</li></ul></li><li>内容与形式<ul><li>含义：揭示事物<font color=red>内在要素同这些要素的结构和表现方式的关系</font>范畴。</li><li>内容：构成事物一切要素的总和，是事物存在的基础</li><li>形式：内容诸要素相互结合的结构和表现方式</li><li>关系：<ul><li>对立：内容决定形式，形式反作用于内容</li><li>统一：<ul><li>相互依赖、不可分割</li><li>相互作用、相互影响</li></ul></li></ul></li></ul></li></ol><h2 id="第三章：实践与认识及其发展规律"><a href="#第三章：实践与认识及其发展规律" class="headerlink" title="第三章：实践与认识及其发展规律"></a>第三章：实践与认识及其发展规律</h2><h3 id="一、实践"><a href="#一、实践" class="headerlink" title="一、实践"></a>一、实践</h3><ol><li>本质：<font color=red>人类</font>能动地改造<font color=red>世界</font>的社会性的<font color=red>物质</font>活动。</li><li>基本结构：<ul><li>主体：主体能力、从事现实社会实践的人。<font color=orange>（要有一定的能动性，有意识，有目的）</font></li><li>客体：实践活动所指向的对象。<font color=orange>（不仅仅指物）</font></li><li>中介：工具、手段以及运用、操作这些工作的<font color=red>程序和方法</font>。<font color=orange>（中介不唯一）</font></li></ul></li><li>主体通过中介作用于客体时的三种关系：<ul><li>实践关系<font color=red>（最根本）</font>：改造与被改造的关系。</li><li>认识关系：反映与被反映的关系。</li><li>价值关系：客体对主体有用。</li></ul></li><li>实践的基本特征：<ul><li>直接现实性：区别于意识、认识、理论。<font color=red>（做）</font></li><li>自觉能动性：区别于自然物质运动与动物本能。<font color=red>（想）</font></li><li>社会历史性：不断变化发展的。<font color=red>（变）</font></li></ul></li><li>基本类型：<ul><li>物质生产实践<font color=red>（最基本）</font>：粮食生产</li><li>社会政治实践：选举</li><li>科学文化实践：打磨石器</li><li><font color=blue>虚拟实践</font></li></ul></li></ol><h3 id="二、实践在认识中的决定作用"><a href="#二、实践在认识中的决定作用" class="headerlink" title="二、实践在认识中的决定作用"></a>二、实践在认识中的决定作用</h3><ol><li>实践是认识的基础，对认识具有决定作用<ul><li>实践是认识的来源：实践出真知</li><li>实践是认识的动力：一旦社会上有了关于技术的需要，比十所大学更能推动科技前进。——恩格斯</li><li>实践是认识的检验标准</li><li>实践是认识的目的</li></ul></li><li>认识对实践的反作用：<ul><li>正确的认识带来成功的实践。</li><li>错误的认识带来失败的实践。</li></ul></li></ol><h3 id="三、认识的本质和过程"><a href="#三、认识的本质和过程" class="headerlink" title="三、认识的本质和过程"></a>三、认识的本质和过程</h3><ol><li>认识的本质：<ul><li>唯物主义：<ul><li>从物到感觉、思想</li><li>坚持反映论，认为认识是主体对客观的反映</li><li><a href="#%E6%97%A7%E5%94%AF%E7%89%A9%E4%B8%BB%E4%B9%89">旧唯物主义直接反映论</a>：<font color=orange>（机械性）</font><ul><li>离开实践考察认识问题</li><li>离开辩证法来考察认识问题</li></ul></li><li><a href="#%E8%BE%A9%E8%AF%81%E5%94%AF%E7%89%A9%E4%B8%BB%E4%B9%89">辩证唯物主义能动反映论</a>：<font color=orange>（有目的，辩证法）</font><ul><li>把实践的观点引入到认识论</li><li>把辩证法应用于反映论</li></ul></li></ul></li><li>唯心主义：<ul><li>从感觉、思想到物</li><li>坚持先验论，否认认识是人脑对客观世界的反映</li><li><a href="#%E4%B8%BB%E8%A7%82%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89">主观唯心主义</a>：主观自生，“内心反省”的结果，心灵的自由创造物。</li><li><a href="#%E5%AE%A2%E8%A7%82%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89">客观唯心主义</a>：上帝的启示或绝对精神的产物。</li></ul></li><li>认识的本质：认识是主体在实践基础上对客体的能动反映。</li></ul></li><li>认识的过程：<ol><li>从实践到认识（感性认识到理性认识）<ul><li>含义：<ul><li>感性认识：运用<font color=red>感官</font>对事物的<font color=red>外部联系和表面特征</font>的认识。</li><li>理性认识：运用抽象思维能力，对事物的<font color=red>内部联系和本质规律</font>的认识。</li></ul></li><li>辩证关系：<ul><li>相互依存：感性认识有待于发展和深化为理性认识；理性认识依赖于感性认识。</li><li>相互渗透</li></ul></li><li>感性认识到理性认识飞跃的条件：<ul><li><font color=red>用于实践，深入调查</font>，获取感性材料。</li><li>必须经过理性思考的作用，将感性材料加工制作，<font color=red>去粗取精、去伪存真、由此及彼、由表及里</font>。</li></ul></li><li>认识过程中的理性因素和非理性因素<ul><li>理性因素：人的理性直观、理性思维等能力，具有<font color=red>指导、解释和预见</font>作用。</li><li>非理性因素：主体的情感和意志。还包括认识能力中具有不自觉、非逻辑性特点的认识形式。具有<font color=red>激活、驱动和控制</font>作用。</li></ul></li></ul></li><li>从认识到实践（从理性认识到实践）<font color=red>更重要</font><ul><li>必要性：<ul><li>认识世界的目的是改造世界。</li><li>认识的真理性只有在实践中才能得到检验和发展。</li></ul></li><li>实现的条件：<ul><li>中介环节：<ul><li>确定实践目的</li><li>形成实践理念</li><li>制定实践方案</li><li>进行中间实验</li><li>运用科学实践方法</li></ul></li><li>条件：<ul><li>必须从实际出发，坚持理论和实践相结合。</li><li>理论为群众所掌握，转化为改造社会、改造自然的物质力量。</li></ul></li></ul></li></ul></li><li>实践与认识的辩证运动及其规律：<ul><li>含义：是一个由感性认识到理性认识，又有理性认识到实践的飞跃，是实践、认识、再实践、再认识，循环往复以至无穷的辩证发展过程。<ul><li>“完成了”：具体的事情完成了</li><li>“又没有完成”：人类趋势来看没有完成</li></ul></li><li>基本规律：从实践到认识、从认识到实践，实践、认识、再实践、再认识，认识运动不断反复和无限发展。</li><li>认识和实践的统一：<ul><li>具体的：主观认识要同<font color=red>一定时间、地点、条件</font>下的<font color=red>客观实践</font>相符合。</li><li>历史的：主观认识要同<font color=red>特定历史发展阶段</font>的<font color=red>客观实践</font>相适应。</li></ul></li><li>方法论：实事求是，一切从实际出发。</li></ul></li></ol></li></ol><h3 id="四、真理与价值"><a href="#四、真理与价值" class="headerlink" title="四、真理与价值"></a>四、真理与价值</h3><ol><li>真理：<ul><li>含义：正确认识</li><li>特性：<ul><li>客观性：<font color=red>内容、检验标准</font>是客观的。</li><li>一元性：对于特定的<font color=red>认识客体</font>来说，真理只有一个。</li><li>主观真理论<font color=orange>（错误的）</font>：马赫主义、实用主义</li></ul></li></ul></li><li>真理的绝对性和相对性：<ol><li>绝对性：<ul><li>含义：<ul><li>就客观性而言，与客观内容相符合。</li><li>就认识的本性来说，无限接近物质世界。</li></ul></li></ul></li><li>相对性：<ul><li>含义：<ul><li>反映的对象是有条件的、有限的</li><li>反映正确程度也是有条件的、有限的</li></ul></li></ul></li><li>辩证关系：<ul><li>相互依存</li><li>相互包含</li><li>相对向绝对转化</li></ul></li><li>方法论：既反对绝对主义又反对相对主义</li></ol></li><li>真理与谬误：<ul><li>关系：<ul><li>相互依存</li><li>相互包含</li><li>相互转化：改变条件</li></ul></li><li>方法论<ul><li>坚持和发展真理，敢于同谬误作斗争</li><li>善于总结经验教训，不断从失败走向成功</li></ul></li></ul></li><li>真理的检验标准：<font color=red>实践</font><ol><li>原因：<ul><li>真理的本性：主观和客观的一致、符合</li><li>实践的特点：主观见之于客观的物质活动，具有直接现实性。</li></ul></li><li>实践标准的确定性与不确定性<ol><li>确定性：<ul><li>实践是检验真理的唯一标准，再无别的标准</li><li>凡经过实践证明了的一切认识，都具有不可推翻的性质</li><li>实践能够检验一切认识</li></ul></li><li>不确定性：<ul><li>一定历史阶段上的具体实践具有局限性，它往往不能充分证明或驳倒某一认识的真理性。</li><li>实践检验真理是一个过程，不是一次完成的。</li><li>已被实践检验过的真理还要继续经受实践的检验。</li></ul></li></ol></li></ol></li><li>价值：<ul><li>含义：在实践基础上形成的主体和客体之间的关系。<font color=orange>（客体有用，主体有需）</font></li><li>特性：<ul><li>主体性：以主体需要为中心</li><li>客观性：客体存在作用，主体需要客体</li><li>多样性：一个客体满足主体的不同需要</li><li>社会历史性：变</li></ul></li></ul></li><li>价值评价及其特点：<ul><li>含义：主体对客体的价值以及价值大小所做的评判或判断。</li><li>基本特点：<ul><li>以主、客体价值关系为对象</li><li>与评价主体直接相关</li><li>结果正确与否依赖于客体</li></ul></li></ul></li><li>真理和价值的辩证统一：<ol><li>真理尺度<font color=red>（对不对）</font>：必须遵循正确反映客观事物本质和规律的真理。</li><li>价值尺度<font color=red>（有没有用）</font>：都是按照自己的尺度和需要去认识世界和改造世界</li><li>真理尺度和价值尺度的辩证统一关系：<ul><li>成功实践都是真理尺度和价值尺度的统一</li><li>价值尺度必须以真理为前提</li><li>人类自身需要的内在尺度，推动着热嫩不断发现新的真理</li></ul></li></ol></li></ol><h2 id="第四章：人类社会及其发展规律"><a href="#第四章：人类社会及其发展规律" class="headerlink" title="第四章：人类社会及其发展规律"></a>第四章：人类社会及其发展规律</h2><h3 id="一、社会存在与社会意识"><a href="#一、社会存在与社会意识" class="headerlink" title="一、社会存在与社会意识"></a>一、社会存在与社会意识</h3><ol><li><p>社会历史观的基本问题：<font color=red>社会存在与社会意识的关系</font></p></li><li><p>两种根本对立的历史观：</p><table><thead><tr><th align="center"></th><th align="center">决定力量</th><th align="center">历史发展动力</th><th align="center">历史的创造者</th></tr></thead><tbody><tr><td align="center">唯物史观</td><td align="center">社会存在</td><td align="center">社会基本矛盾</td><td align="center">人民群众</td></tr><tr><td align="center">唯心史观</td><td align="center">社会意识</td><td align="center">主观精神</td><td align="center">英雄人物</td></tr></tbody></table></li><li><p>社会存在和社会意识及其辩证关系：</p><ol><li>社会存在：<ul><li>含义：社会存在属于社会生活的物质方面：<ul><li>物质生活资料的生产和生产方式</li><li>地理环境和人口因素：<font color=orange>起到加速或延缓的作用，但不是社会存在的绝对因素</font></li></ul></li></ul></li><li>物质生产方式：<ul><li>含义：生产方式=生产力+生产关系</li><li>地位：生产方式是社会历史发展的决定力量。<ul><li>它是人类社会赖以存在和发展的基础。</li><li>它决定着社会的结构、性质和面貌。</li><li>起变化发展决定整个社会历史的变化发展。</li></ul></li><li><font color=red>物质生产方式集中<font color=orange>（最）</font>体现了人类社会的物质性</font>。</li></ul></li><li>社会意识：<ul><li>含义：社会意识是社会生活的精神方面，是社会存在的反映。</li><li>包括：<ul><li>上层建筑的意识形式——社会意识形态<font color=orange>（阶级性）</font><ul><li>政治法律思想</li><li>道德、艺术</li><li>宗教、哲学</li></ul></li><li>非上层建筑的意识形式</li></ul></li></ul></li><li>辩证关系：<ol><li>社会存在决定社会意识：<ul><li>社会存在是社会意识内容的客观来源。</li><li>社会意识是人们进行社会物质交往的产物。</li><li>随着社会存在的发展，社会意识也相应的或迟或早地发生变化和发展。</li></ul></li><li>社会意识具有相对独立性：<ul><li>社会意识与社会存在发展的不完全同步性和不平衡性。</li><li>社会意识内部各种形式之间的相互影响及各具有的历史的继承性。</li><li>社会意识对社会存在的能动的反作用。<font color=orange>（突出表现）</font></li></ul></li></ol></li></ol></li></ol><h3 id="二、生产力与生产关系矛盾运动的规律"><a href="#二、生产力与生产关系矛盾运动的规律" class="headerlink" title="二、生产力与生产关系矛盾运动的规律"></a>二、生产力与生产关系矛盾运动的规律</h3><ol><li>生产力：<ul><li>含义：生产力是人类改造和影响自然以使其适合社会需要的<font color=red>物质力量</font>，体现<font color=red>人与自然</font>的关系。</li><li>结构：<ul><li>实体性要素：<ul><li>劳动资料：生产工具——<font color=orange>区分<font color=red>经济时代</font>的物质标志</font></li><li>劳动对象：<font color=red>生产力发展状况</font>的标志</li><li>劳动者：<font color=red>最活跃的因素</font></li></ul></li><li>渗透性要素：<font color=red>科学技术</font>是第一生产力</li></ul></li></ul></li><li>生产关系：<ul><li>含义：人们在物质生产过程中形成的不以人的意志为转移的<font color=red>经济关系</font>。</li><li>结构：<ul><li>狭义：<ul><li>生产资料所有制关系——<font color=red>最基本的；区分生产方式、判定经济结构、性质客观依据</font></li><li>生产中人与人的关系</li><li>产品分配关系</li></ul></li><li>广义：<ul><li>生产</li><li>分配</li><li>交换</li><li>消费</li></ul></li></ul></li></ul></li><li>辩证关系：<ul><li>生产力决定生产关系：性质、变革</li><li>生产关系反作用于生产力：推动、阻碍</li></ul></li></ol><h3 id="三、经济基础与上层建筑矛盾运动的规律"><a href="#三、经济基础与上层建筑矛盾运动的规律" class="headerlink" title="三、经济基础与上层建筑矛盾运动的规律"></a>三、经济基础与上层建筑矛盾运动的规律</h3><ol><li>经济基础：<ul><li>含义：由社会一定发展阶段的生产力所决定的生产关系的总和。</li></ul></li><li>上层建筑：<ul><li>含义：建立在一定经济基础之上的<font color=red>意识形态</font>以及相应的制度、组织和设施。</li><li>结构：<ul><li>观念上层建筑<ul><li>政治法律思想</li><li>道德、艺术</li><li>宗教、哲学</li></ul></li><li>政治上层建筑<ul><li>政治法律制度</li><li>国家政权</li><li>政治法律设施</li></ul></li></ul></li></ul></li><li>国家的起源和性质<ul><li>起源：国家是阶级矛盾不可调和的产物。</li><li>性质：是一个阶级统治另一个阶级的工具。</li></ul></li><li>辩证关系：<ul><li>经济基础决定上层建筑：产生、性质、发展</li><li>上层建筑对经济基础具有反作用：促进、阻碍</li></ul></li></ol><h3 id="四、社会形态更替的一般规律及特殊形式"><a href="#四、社会形态更替的一般规律及特殊形式" class="headerlink" title="四、社会形态更替的一般规律及特殊形式"></a>四、社会形态更替的一般规律及特殊形式</h3><ol><li>社会形态：<ul><li>含义：同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。<font color=red>社会形态=经济基础<font color=orange>（骨骼系统）</font>+上层建筑<font color=orange>（血肉系统）</font></font></li></ul></li><li>社会形态更替的统一性和多样性：<ol><li>纵向看：<ul><li>统一性：人类的总体历史过程表现为物种社会形态的依次更替。</li><li>多样性：不同的民族可以超越一种或多种社会形态。</li></ul></li><li>横向看：<ul><li>统一性：同类社会形态具有共同的本质</li><li>多样性：同类社会形态又有各自的特点</li></ul></li></ol></li><li>社会形态更替的必然性与人们的历史选择性：<ul><li>社会形态更替的必然性：社会形态依次更替的<font color=red>过程和规律是客观的，发展的基本趋势是确定不移的</font>。</li><li>人们的历史选择性：<ul><li>社会发展的客观必然性造成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间。</li><li>社会形态更替的过程也是一个合目的性与合规律性相统一的过程。</li><li>人们的历史选择性，归根到底是人民群众的选择性。</li></ul></li></ul></li><li>社会形态更替的前进性与曲折性：<ul><li>前进性：五种社会形态依次演进的基本趋势。<font color=red>（前途是光明的）</font></li><li>曲折性：社会前进过程中所出现的反复、停滞和倒退现象。<font color=red>（道路是曲折的）</font></li></ul></li></ol><h3 id="五、社会基本矛盾是社会发展的根本动力"><a href="#五、社会基本矛盾是社会发展的根本动力" class="headerlink" title="五、社会基本矛盾是社会发展的根本动力"></a>五、社会基本矛盾是社会发展的根本动力</h3><ol><li>社会基本矛盾的内容：<ul><li>生产力和生产关系的矛盾</li><li>经济基础和上层建筑的矛盾</li></ul></li><li>社会基本矛盾在社会发展中的作用<font color=red>（根本作用）</font>：<ul><li>生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的<font color=red>最终决定力量</font>。</li><li>社会基本矛盾特别是生产力和上产关系的矛盾，是”一切历史冲突的根源“，决定着社会中其他矛盾的存在和发展。</li><li>社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。</li></ul></li></ol><h3 id="六、改革在社会发展中的作用"><a href="#六、改革在社会发展中的作用" class="headerlink" title="六、改革在社会发展中的作用"></a>六、改革在社会发展中的作用</h3><ol><li>作用：推动社会发展的<font color=red>重要动力</font>。</li><li>性质：是社会主义的<font color=red>自我完善和自我发展</font>。</li></ol><h3 id="七、科学技术在社会发展中的作用"><a href="#七、科学技术在社会发展中的作用" class="headerlink" title="七、科学技术在社会发展中的作用"></a>七、科学技术在社会发展中的作用</h3><ol><li>科技革命是推动经济和社会发展的强大杠杆：<ul><li>对<font color=red>生产方式</font>产生了深刻影响</li><li>对<font color=red>生活方式</font>产生了巨大影响</li><li>促进了<font color=red>思维方式</font>的变革</li></ul></li><li>正确把握科学技术的社会作用：<ul><li>科学技术是一把<font color=red>双刃剑</font></li><li>科技消极作用产生的原因：<ul><li>由于对自然规律和人与自然关系认识不够</li><li>缺乏对科技消极后果的强有力的控制手段</li><li>与一定的社会制度有关</li></ul></li></ul></li><li>正确认识和运用科学技术：<ul><li>有合理的社会制度保障科学技术的正确运用</li><li>始终坚持使科学技术为人类的健康发展服务，让科技为人类造福</li></ul></li></ol><h3 id="八、人民群众是历史的创造者"><a href="#八、人民群众是历史的创造者" class="headerlink" title="八、人民群众是历史的创造者"></a>八、人民群众是历史的创造者</h3><ol><li>唯物史观考察历史创造者的原则：<ol><li>立足于现实的人及其本质来把握历史的创造者<ul><li>基于自身需要和社会需要</li><li>从事一定实践活动</li><li>处于一定社会关系中</li><li>具有能动性</li></ul></li><li>立足于整体的<font color=red>社会历史</font>过程来探究谁是历史的创造者<ul><li>人民群众是历史的创造者</li></ul></li><li>从社会历史发展的必要性入手来考察和说明谁是历史的创造者</li><li>从人与历史关系的不同层次上考察谁是历史的创造者</li></ol></li><li>人的本质：<ol><li>人与动物的区别——<font color=red>劳动<font color=orange>（自然属性）</font></font></li><li>人与人的区别——<font color=red>社会关系<font color=orange>（社会属性）</font></font></li><li>马克思的定义：人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。</li><li>人的本质属性表现在各种社会关系中，不断变化，不断发展。</li></ol></li><li>人民群众在创造历史过程中的决定作用：<ul><li>含义：<ul><li>质上：一切对社会历史发展起<font color=red>推动</font>作用的人们</li><li>量上：社会人口中的<font color=red>绝大多数</font></li><li>人民群众是一个<font color=red>历史范畴</font><font color=orange>（变化）</font></li><li><font color=red>最稳定的主体部分</font>是从事物质资料的生产的劳动群众及其知识分子。</li></ul></li><li>作用：<ul><li>物质财富的创造者</li><li>社会精神财富的创造者</li><li>社会变革的决定力量</li></ul></li><li>人民群众创造历史的活动要受到一定社会历史条件的制约。</li></ul></li><li>方法论：群众观点和群众路线：<ul><li>群众观点：坚持人民群众自己解放自己的观点，全心全意为人民服务的观点，一切向人民群众负责的观点，虚心向群众学习的观点。</li><li>群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去。</li></ul></li></ol><h3 id="九、个人在社会历史中的作用"><a href="#九、个人在社会历史中的作用" class="headerlink" title="九、个人在社会历史中的作用"></a>九、个人在社会历史中的作用</h3><ol><li>个人：<ul><li>普通个人：属于人民群众范畴</li><li>历史人物：一定历史事件的主要倡导者、组织领导者或思想理论、科学文化的重要代表人物。<ul><li>反面人物：<font color=orange>阻碍作用</font></li><li>杰出人物：历史人物中对推动历史社会发展作出重要贡献或起重要作用的人。<font color=orange>促进作用</font></li></ul></li></ul></li><li>作用：<ul><li>在历史发展进程中，新的历史任务往往是由具有进步意义的历史人物<font color=orange>（杰出人物）</font>首先发现或提出的。</li><li>不管什么历史人物，在历史上发挥什么样的作用，都要受到社会发展客观规律的制约，而不能决定和改变历史发展的总进程和总方向。</li></ul></li><li>辩证地理解和评价个人的历史作用：<ul><li>任何历史人物的出现都体现了必然性与偶然性的统一</li><li>评价历史人物时，应坚持运用历史分析方法和阶级分析方法</li></ul></li></ol><h2 id="第五章：资本主义的本质及规律"><a href="#第五章：资本主义的本质及规律" class="headerlink" title="第五章：资本主义的本质及规律"></a>第五章：资本主义的本质及规律</h2><h3 id="一、商品经济"><a href="#一、商品经济" class="headerlink" title="一、商品经济"></a>一、商品经济</h3><ol><li>自然经济：<ul><li>含义：自给自足的经济</li><li>特点：生产力水平低，排斥社会分工</li></ul></li><li>商品经济：<ul><li>含义：以交换为目的而进行生产的经济形式</li><li>产生条件：<ul><li>社会分工的存在</li><li>生产资料和劳动产品属于不同的所有者<font color=orange>（私有制）</font></li></ul></li></ul></li></ol><h3 id="二、劳动价值论"><a href="#二、劳动价值论" class="headerlink" title="二、劳动价值论"></a>二、劳动价值论</h3><ol><li><p>商品：</p><ul><li><p>含义：<font color=red>用来交换</font>的能<font color=red>满足人们某种需要</font>的<font color=red>劳动产品</font></p></li><li><p>商品二要素：</p><ul><li>使用价值：商品能<font color=red>满足人们某种需要</font>的属性</li><li>价值：凝结在商品中的<font color=red>无差别的一般人类劳动</font></li><li><font color=blue>交换价值：使用价值同另一种使用价值相交换的量的关系或比例</font></li></ul><table><thead><tr><th align="center">类别</th><th align="center">内涵</th><th align="center">属性</th><th align="center">关系</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">使用价值</td><td align="center">商品有用性</td><td align="center">自然属性、共有属性</td><td align="center">人与自然关系</td><td align="center">构成社会财富的物质内容</td></tr><tr><td align="center">价值</td><td align="center">一般人类劳动</td><td align="center">社会属性、本质属性</td><td align="center">人与人的关系</td><td align="center">本质和唯一来源是劳动</td></tr></tbody></table></li><li><p>商品二要素的关系：</p><ul><li>相对于交换价值：<ul><li>使用价值是交换价值的物质承担者</li><li>价值是交换价值的基础，交换价值是价值的表现形式</li></ul></li><li>辩证关系：<ul><li>对立：相互排斥，不可兼得</li><li>统一：同时具备，缺一不可</li></ul></li></ul></li><li><p>劳动二重性：</p><ul><li>具体劳动：生产一定使用价值的具体形式的劳动，即有用劳动——<font color=orange>使用价值</font></li><li>抽象劳动：撇开一切具体形式的、无差别的一般人类劳动，即人的体力和脑力消耗——<font color=orange>价值</font></li></ul></li><li><p>劳动二重性的关系：</p><ul><li>统一：是同一劳动过程的两个方面</li><li>对立：<ul><li>具体劳动反映人与自然关系，自然属性</li><li>抽象劳动反映生产者社会关系，社会属性</li></ul></li></ul></li></ul></li><li><p>商品价值量：</p><ol><li><p>商品价值量的决定：</p><ul><li><p>劳动量按照劳动时间计量</p></li><li><p>价值量由生产商品的社会必要劳动时间决定</p><ul><li>现有的社会正常的生产条件下</li><li>社会平均的劳动熟练程度和劳动强度下</li></ul></li><li><p>与生产商品所耗费的劳动时间成正比，与<font color=red>劳动生产率成反比</font></p><p>  影响劳动生产率的因素：</p><ul><li>劳动者的平均熟练程度</li><li>科学技术的发展程度及其在生产中的应用</li><li>生产过程的社会结合</li><li>生产资料的规模和效能以及自然条件</li></ul></li></ul></li><li><p>商品价值量的衡量：以简单劳动为尺度</p></li></ol></li><li><p>价值形式的发展与货币：</p><ol><li>价值形式的发展：<ul><li>简单的或偶然的价值形式</li><li>总和的或扩大的价值形式</li><li>一般价值形式</li><li>货币形式</li></ul></li><li>货币：<ul><li>含义：在长期交换过程中形成的固定地充当一般等价物的商品</li><li>本质：一般等价物</li></ul></li><li>货币的基本职能：<ul><li>价值尺度：衡量其他商品价值</li><li>流通手段：商品交换媒介</li><li>贮藏手段：调节货币流通量</li><li>支付手段：清偿<font color=red>债务</font>、支付赋税、租金、工资</li><li>世界货币：在世界市场发挥作用</li></ul></li><li>货币产生的影响：<ul><li>使整个商品世界分为两极<ul><li>一极是<font color=red>具体商品</font>，代表不同的<font color=red>使用价值</font></li><li>一极是<font color=red>价值</font>，只代表商品的<font color=red>价值</font></li></ul></li><li>有利于解决商品交换的困难，促进了商品经济的发展</li></ul></li></ol></li><li><p>商品经济的基本规律与基本矛盾</p><ol><li>价值规律：<ul><li>内容<ul><li>商品价值量由生产商品的社会必要劳动时间决定</li><li>商品交换以价值量为基础，按等价交换原则进行</li></ul></li><li>表现形式：商品的价格围绕价值自发波动<font color=orange>（价值决定价格，价格受供求关系影响）</font></li><li>积极作用：<ul><li>自发调节资源在各部门的分配比例</li><li>自发刺激社会生产力发展</li><li>自发地调节社会收入分配</li></ul></li></ul></li><li>商品经济的基本矛盾：私人劳动和社会劳动<ul><li>社会劳动：社会分工决定</li><li>私人劳动：生产资料私有制决定</li><li>决定着商品经济的本质及其发展过程</li><li>是商品经济的其他一切矛盾的基础</li><li>决定着商品生产者的命运</li></ul></li></ol></li></ol><h3 id="三、马克思劳动价值论的意义与深化认识"><a href="#三、马克思劳动价值论的意义与深化认识" class="headerlink" title="三、马克思劳动价值论的意义与深化认识"></a>三、马克思劳动价值论的意义与深化认识</h3><ol><li>劳动价值论的理论和实践意义：<ul><li>扬弃了英国古典政治经济学的观点，创立劳动二重性理论，为剩余价值论的创立奠定了基础。</li><li>揭示了商品经济的一般规律，为社会主义市场经济的发展提供了理论指导。</li></ul></li><li>深化对马克思劳动价值论的认识：<ul><li>深化对创造价值的劳动的认识，对生产性劳动作出新的界定。</li><li>深化对科技人员、经营管理人员在社会生产和价值创造中所起作用的认识。</li><li>深化对价值创造与价值分配关系的认识。</li></ul></li></ol><h3 id="四、资本主义经济制度的产生"><a href="#四、资本主义经济制度的产生" class="headerlink" title="四、资本主义经济制度的产生"></a>四、资本主义经济制度的产生</h3><ol><li>资本主义生产关系的产生：<ul><li>萌芽：14世纪末15世纪初地中海沿岸城市——<font color=orange>雇佣关系</font></li><li>途径：<ul><li>从小商品经济分化出来</li><li>从商人和高利贷者转化而成</li></ul></li></ul></li><li>资本的原始积累：<ul><li>背景：15世纪末新航路开辟，世界市场迅速扩大</li><li>含义：生产者与生产资料分离，货币资本集中于少数人手中</li><li>时间：15世纪后30年——16世纪高潮——19世纪初</li><li>途径：<ul><li>暴力手段剥夺农民土地</li><li>暴力手段掠夺货币财富</li></ul></li><li>意义：<ul><li>大大促进了资本主义的发展</li><li>一部罪恶的掠夺史</li></ul></li></ul></li><li>资本主义生产方式的确立<ol><li>上层建筑变革——英法资产阶级革命</li><li>生产力发展——产业革命</li></ol></li></ol><h3 id="五、劳动力成为商品与资本主义所有制"><a href="#五、劳动力成为商品与资本主义所有制" class="headerlink" title="五、劳动力成为商品与资本主义所有制"></a>五、劳动力成为商品与资本主义所有制</h3><p>一、劳动力成为商品</p><ol><li>劳动力：指人的<font color=red>劳动能力</font><ul><li>劳动者：具有劳动能力的人</li><li>劳动：劳动力的使用或使用价值</li></ul></li><li>劳动成为商品的基本条件：<ul><li>劳动者是自由人</li><li>自由的“一无所有”</li></ul></li><li>劳动力商品的特点：<ul><li>劳动力商品的价值——<font color=orange>工资</font><ul><li>维持本人生存所需生活资料价值</li><li>维持家属生存所需生活资料价值</li><li>接受教育和训练的支出</li></ul></li><li>劳动力商品的使用价值——<font color=orange>劳动</font><ul><li>是价值的源泉，能够创造新价值</li><li>新价值比劳动力本身的价值更大</li><li>货币转化为资本的前提</li></ul></li></ul></li></ol><p>二、资本主义所有制</p><ol><li>所有制和所有权：<ul><li>含义：<ul><li>所有制：经济意义上的占有关系——<font color=red>经济基础</font></li><li>所有权：法律意义上的排他性权力——<font color=red>上层建筑</font></li></ul></li><li>关系：<ul><li>所有制是所有权的基础，决定所有权</li><li>所有权是所有制的法律形态，反映经济关系</li></ul></li></ul></li><li>资本主义所有制实质：<ul><li>资本家与劳动者是资本雇佣劳动关系</li><li>所有制实质：资本家凭借对生产资料的占有，在等价交换原则掩盖下雇佣工人从事劳动，占有雇佣工人的剩余价值。</li></ul></li></ol><h3 id="六、生产剩余价值是资本主义生产方式的绝对规律"><a href="#六、生产剩余价值是资本主义生产方式的绝对规律" class="headerlink" title="六、生产剩余价值是资本主义生产方式的绝对规律"></a>六、生产剩余价值是资本主义生产方式的绝对规律</h3><h4 id="一、资本主义生产过程的两重性"><a href="#一、资本主义生产过程的两重性" class="headerlink" title="一、资本主义生产过程的两重性"></a>一、资本主义生产过程的两重性</h4><ol><li>劳动过程：<ul><li>生产使用价值的过程</li><li>工人劳动隶属于资本家</li><li>劳动成果或产品全部归资本家所有</li></ul></li><li>价值增殖过程：<ul><li>资本主义过程的<font color=red>主要方面</font></li><li>超过<font color=red>劳动力价值的补偿</font>这个一定点而<font color=red>延长价值形成</font>过程</li></ul></li></ol><h4 id="二、剩余价值的实质"><a href="#二、剩余价值的实质" class="headerlink" title="二、剩余价值的实质"></a>二、剩余价值的实质</h4><ol><li>必要劳动：再生产劳动价值</li><li>剩余劳动：无偿为资本家生产剩余价值</li><li>剩余价值M：<ul><li>含义：雇佣工人创造并被资本家无偿占有的超过劳动力价值的那部分价值</li><li>意义：<ul><li>工人剩余劳动的凝结</li><li>体现了资本家与雇佣工人的剥削与被剥削关系</li></ul></li></ul></li></ol><h4 id="三、资本的本质"><a href="#三、资本的本质" class="headerlink" title="三、资本的本质"></a>三、资本的本质</h4><ol><li>资本：<ul><li>含义：能够带来剩余价值的价值</li><li>本质：一定的历史社会形态下的生产关系</li></ul></li></ol><h4 id="四、不变资本与可变资本，剩余价值率"><a href="#四、不变资本与可变资本，剩余价值率" class="headerlink" title="四、不变资本与可变资本，剩余价值率"></a>四、不变资本与可变资本，剩余价值率</h4><ol><li><p>不变资本C：</p><ul><li>生产资料</li><li>通过具体劳动转移到新产品中</li><li>价值量不变</li></ul></li><li><p>可变资本V：</p><ul><li>劳动力</li><li>通过工人抽象劳动创造更多新价值</li><li>价值量可变</li></ul></li><li><p>不变资本与可变资本区分的意义：</p><ul><li>揭示了剩余价值产生的源泉——<font color=red>雇佣工人的剩余劳动</font></li><li>为确定资本家对工人的剥削程度提供了依据</li></ul></li><li><p>剩余价值率：剩余劳动/必要劳动</p><p> m‘=m/v</p></li></ol><h4 id="五、绝对、相对、超额剩余价值"><a href="#五、绝对、相对、超额剩余价值" class="headerlink" title="五、绝对、相对、超额剩余价值"></a>五、绝对、相对、超额剩余价值</h4><ol><li>资本家提高剩余价值率的方法：<ul><li>绝对剩余价值：<ul><li>必要劳动时间不变</li><li>延长工作日长度或提高劳动强度</li></ul></li><li>相对剩余价值<ul><li>工作日长度不变</li><li>缩短必要劳动时间而相对延长劳动时间</li><li>通过<font color=red>提高全社会的劳动生产率</font>实现</li></ul></li><li>超额剩余价值<ul><li>企业提高个别劳动生产率</li><li>商品个别价值低于社会价值</li><li>后果是全社会生产率提高，普遍获得相对M</li></ul></li></ul></li></ol><h4 id="六、生产自动化条件下剩余价值的源泉"><a href="#六、生产自动化条件下剩余价值的源泉" class="headerlink" title="六、生产自动化条件下剩余价值的源泉"></a>六、生产自动化条件下剩余价值的源泉</h4><ol><li>资本主义条件下的生产自动化：<ul><li>生产自动化是资本家获取<font color=red>超额剩余价值</font>的手段</li><li>雇佣工人的剩余劳动是剩余价值的唯一源泉</li></ul></li></ol><h3 id="七、资本积累"><a href="#七、资本积累" class="headerlink" title="七、资本积累"></a>七、资本积累</h3><ol><li>资本积累：<ul><li>含义：把<font color=red>剩余价值</font>转化为<font color=red>资本</font></li><li>本质：资本家利用剩余价值进一步扩大加强剥削</li><li>源泉：<ul><li>资本积累源泉是剩余价值</li><li>影响资本积累规模的因素</li></ul></li><li>后果：两极分化</li></ul></li><li>简单再生产：<ul><li>生产在原有规模基础上重复进行</li><li>是物质资料再生产和生产关系再生产的统一</li></ul></li><li>扩大再生产：<ul><li>剩余价值转化为资本，生产扩大规模</li><li>资本积累是扩大再生产的源泉</li></ul></li><li>资本构成：<ul><li>资本技术构成</li><li>资本价值构成</li><li>资本有机构成<ul><li>含义：由<font color=red>技术构成决定</font>并反映其变化的价值构成</li><li>公式：c/v</li></ul></li></ul></li><li>相对过剩人口：<ul><li>原因：资本有机构成提高，可变资本相对减少</li><li>形式：<ul><li>流动的过剩人口</li><li>潜伏的过剩人口</li><li>停滞的过剩人口</li></ul></li></ul></li><li>资本积累的历史趋势：<ul><li>资本主义制度的必然灭亡</li><li>社会主义制度的必然胜利</li><li>原因：<ul><li>生产越来越具有社会性——生产力</li><li>资本越来越集中到少数人手中——生产关系</li><li>生产的社会性和资本主义私人占有形式的矛盾</li></ul></li></ul></li></ol><h3 id="八、资本的循环周转与再生产"><a href="#八、资本的循环周转与再生产" class="headerlink" title="八、资本的循环周转与再生产"></a>八、资本的循环周转与再生产</h3><h4 id="一、资本循环"><a href="#一、资本循环" class="headerlink" title="一、资本循环"></a>一、资本循环</h4><ol><li>定义：资本从一种形式出发，经过一系列形式的变化，又回到原来的出发点的运动。</li><li>阶段：<ol><li>购买阶段：货币资本</li><li>生产阶段：生产资本</li><li>售卖阶段：商品资本</li></ol></li><li>资本循环顺利执行的条件：<ul><li>三种职能形式必须在空间上同时并存</li><li>三种职能形式必须在时间上继起</li></ul></li></ol><h4 id="二、资本周转"><a href="#二、资本周转" class="headerlink" title="二、资本周转"></a>二、资本周转</h4><ol><li>定义：资本周而复始、不断反复的过程。</li><li>影响：资本周转越快，在一定时期内，带来的剩余价值就越多</li><li>影响资本周转速度的因素：<ul><li>资本周转时间</li><li>固定资本和流动资本的构成：根据资本的周转方式划分<font color=orange>（固定资本：一次投入，逐渐回收；流动资本：一次投入，一次回收）</font></li></ul></li></ol><h4 id="三、社会再生产"><a href="#三、社会再生产" class="headerlink" title="三、社会再生产"></a>三、社会再生产</h4><ol><li>核心问题：社会总产品的实现问题<ul><li>价值补偿</li><li>实物补偿</li></ul></li><li>实现条件：要求两大部类<font color=orange>（生产不同产品的，生产生产资料的是第一部类，生产消费资料的是第二部类）</font>各个产业部门之间和两大部类之间保持一定的比例关系<font color=red>（以市场调节为主，以宏观调控为辅）</font>。</li></ol><h3 id="九、工资与剩余价值的分配"><a href="#九、工资与剩余价值的分配" class="headerlink" title="九、工资与剩余价值的分配"></a>九、工资与剩余价值的分配</h3><h4 id="一、资本主义工资"><a href="#一、资本主义工资" class="headerlink" title="一、资本主义工资"></a>一、资本主义工资</h4><ol><li>本质：劳动力的价值或价格。</li><li>表现：“劳动的价格”或全部劳动的报酬</li><li>形式：<ul><li>计时工资</li><li>计件工资</li></ul></li></ol><h4 id="二、平均利润"><a href="#二、平均利润" class="headerlink" title="二、平均利润"></a>二、平均利润</h4><ol><li><p>剩余价值是可变资本的产物：<br> $$<br> m’=\frac{m}{v}<br> $$</p></li><li><p>利润是全部预付资本的产物：<br> $$<br> P’=\frac{m}{c+v}<br> $$</p></li><li><p>关系：</p><ul><li>剩余价值是利润的本质</li><li>利润是剩余价值的转化形式</li></ul></li><li><p>利润转化为平均利润：</p><ul><li>部门之间的竞争导致利润率趋于平均化</li><li>不同部门按照等量资本获得等量利润原则瓜分</li><li>平均利润率与平均利润</li></ul></li><li><p>生产价格：成本价格+<font color=red>平均利润</font></p><p> 生产价格是价值的转化形式，不违背价值规律</p></li><li><p>剩余价值的分配：</p><ul><li>产业资本家——产业利润</li><li>商业资本家——商业利润</li><li>银行资本家——银行利润</li><li>农业资本家——农业利润</li><li>资本家之间有竞争，但在剥削工人这一点<font color=red>有共同的阶级利益</font></li></ul></li></ol><h3 id="十、资本主义的基本矛盾与经济危机"><a href="#十、资本主义的基本矛盾与经济危机" class="headerlink" title="十、资本主义的基本矛盾与经济危机"></a>十、资本主义的基本矛盾与经济危机</h3><h4 id="一、资本主义基本矛盾"><a href="#一、资本主义基本矛盾" class="headerlink" title="一、资本主义基本矛盾"></a>一、资本主义基本矛盾</h4><ol><li>内容：生产资料资本主义私人占有和生产社会化之间的矛盾。</li><li>意义：是生产力和生产关系之间的矛盾在资本主义社会的具体体现。</li></ol><h4 id="二、资本主义经济危机"><a href="#二、资本主义经济危机" class="headerlink" title="二、资本主义经济危机"></a>二、资本主义经济危机</h4><ol><li>本质特征：生产相对过剩<ul><li>相对于劳动人民有支付能力的需求来说社会生产的商品显得过剩。</li><li>不是与劳动人民的世纪需求相比的绝对过剩。</li></ul></li><li>根本原因：<ul><li>可能性是由货币作为支付手段和流通手段引起的</li><li>根本原因是<font color=red>资本主义的基本矛盾</font><ul><li>表现为生产无限扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾。</li><li>表现为个别企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾。</li></ul></li></ul></li><li>特点：周期性<ul><li>由资本主义基本矛盾运动的阶段性决定。</li><li>使社会资本再生产也呈现出周期性特点。<font color=orange>（四个阶段：危机、萧条、复苏和高涨）</font></li></ul></li></ol><h3 id="十一、资本主义国家的职能和本质"><a href="#十一、资本主义国家的职能和本质" class="headerlink" title="十一、资本主义国家的职能和本质"></a>十一、资本主义国家的职能和本质</h3><h4 id="一、资本主义国家的职能"><a href="#一、资本主义国家的职能" class="headerlink" title="一、资本主义国家的职能"></a>一、资本主义国家的职能</h4><ol><li>根本内容：服务于资本主义制度和资产阶级利益</li><li>两个方面：<ul><li>对内职能：政治统治<font color=orange>（阶级统治）</font>和社会管理<font color=orange>（非阶级统治）</font></li><li>对外职能：国际交往和维护国家安全及利益</li></ul></li></ol><h4 id="二、资本主义国家的本质"><a href="#二、资本主义国家的本质" class="headerlink" title="二、资本主义国家的本质"></a>二、资本主义国家的本质</h4><p>​    剥削阶级对人民群众进行阶级统治和阶级压迫的工具。</p><h3 id="十二、资本主义的政治制度"><a href="#十二、资本主义的政治制度" class="headerlink" title="十二、资本主义的政治制度"></a>十二、资本主义的政治制度</h3><h4 id="一、政治制度及其本质"><a href="#一、政治制度及其本质" class="headerlink" title="一、政治制度及其本质"></a>一、政治制度及其本质</h4><ol><li>内容：<ol><li>资本主义民主制度：资产阶级民主制国家</li><li>资本主义法治：<ul><li>宪法是资本主义国家<font color=red>法律制度的核心</font></li><li>宪法基本原则：私有制原则、“主权在民”、分权与制衡原则、人权原则</li></ul></li><li>资本主义国家政权组织形式<font color=orange>（政体）</font>：分权制衡<font color=orange>（三权分立）</font></li><li>资本主义国家的选举：<ul><li>从形式上看，是公民参与国家事务的重要形式</li><li>从作用上看，是协调统治阶级内部利益关系和矛盾的重要措施</li></ul></li><li>政党制度：<ul><li>政党是<font color=red>特定阶级利益</font>的集中代表</li><li>当代资本主义国家实行的基本上是政党制</li><li>政党制度类型，大致有两党制和多党制等形式</li></ul></li></ol></li><li>资本主义政治制度的进步作用和局限性：<ol><li>本质：是为资产阶级服务的，是服从于资产阶级进行统治和压迫需要的政治工具。</li><li>进步作用：其形成和发展在人类社会历史的发展进程中曾起过重要的进步作用</li><li>局限性：<ul><li>资本主义的民主是金钱操纵下的民主，实际是资产阶级精英统治下的民主。</li><li>法律名义上的平等掩盖着事实上的不平等。</li><li>其政党制是维护资产阶级统治的政治制度。</li><li>政党恶斗相互挚肘，决策效率低下，激化社会矛盾。</li></ul></li></ol></li></ol><h3 id="十三、资本主义意识形态"><a href="#十三、资本主义意识形态" class="headerlink" title="十三、资本主义意识形态"></a>十三、资本主义意识形态</h3><h4 id="一、形成及本质"><a href="#一、形成及本质" class="headerlink" title="一、形成及本质"></a>一、形成及本质</h4><ol><li>内涵：实在资本主义国家中占统治地位的、反映了作为统治阶级的资产阶级的利益和要求的各种思想理论和观念的总和。</li><li>形成：是资产阶级在长期的反对封建专制主义和宗教神学的斗争中逐步形成和发展起来的。</li><li>本质：<ul><li>是资本主义社会条件下的<font color=red>观念上层建筑</font>，是为资本主义社会形态的经济基础服务的。</li><li>是资产阶级的阶级意识的集中体现。</li></ul></li></ol><h4 id="二、辩证分析意识形态"><a href="#二、辩证分析意识形态" class="headerlink" title="二、辩证分析意识形态"></a>二、辩证分析意识形态</h4><ol><li>积极：其思想文化成果是人类文明进步的成就</li><li>消极：其社会作用逐渐与历史发展方向背道而驰<ul><li>主要起着巩固资产阶级的政治统治，维护资本主义的政治制度、为资产阶级的阶级剥削和阶级压迫做论证的作用。</li></ul></li></ol><h2 id="第六章：资本主义的发展及趋势"><a href="#第六章：资本主义的发展及趋势" class="headerlink" title="第六章：资本主义的发展及趋势"></a>第六章：资本主义的发展及趋势</h2><h3 id="一、资本主义从自由竞争到垄断"><a href="#一、资本主义从自由竞争到垄断" class="headerlink" title="一、资本主义从自由竞争到垄断"></a>一、资本主义从自由竞争到垄断</h3><ol><li><p>资本主义发展的两个阶段：</p><ol><li>19世纪70年代前：自由竞争资本主义</li><li>19世纪70年代到19世纪末20世纪初：过渡时期</li><li>19世纪末20世纪初：垄断资本主义</li></ol></li><li><p>生产集中：指生产资料、劳动力和商品的生产日益集中于少数大企业的过程。</p></li><li><p>资本集中：指大资本吞并小资本，或由许多小资本合并而成大资本的过程。</p></li><li><p>垄断：</p><ul><li><p>含义：少数资本主义大企业，为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵与控制。</p></li><li><p>产生原因：</p><ul><li>当生产集中发展到相当高的程度</li><li>企业规模巨大，形成对竞争的限制</li><li>为了避免竞争中两败俱伤，实行垄断</li></ul></li><li><p>垄断组织：</p><ul><li>指在一个经济部门或几个经济部门中，占据垄断地位的大企业联合。</li><li>垄断组织形式多样，在本质上都是通过联合实现独占和瓜分商品生产和销售市场，操纵垄断价格，以撰取高额垄断利润。</li></ul></li><li><p>垄断与竞争</p><ul><li><p>垄断并不能消除竞争</p><ul><li>垄断没有消除产生竞争的经济条件</li><li>垄断必须通过竞争来维持</li><li>任何垄断组织都不可能把包罗万象的社会生产都包下来</li></ul></li><li><p>垄断条件下的竞争同自由竞争的新特点：</p><table><thead><tr><th align="center"></th><th align="center">自由竞争条件</th><th align="center">垄断条件</th></tr></thead><tbody><tr><td align="center">竞争目的</td><td align="center">利润或超额利润</td><td align="center">高额垄断利润</td></tr><tr><td align="center">竞争手段</td><td align="center">经济手段</td><td align="center">经济手段、非经济手段</td></tr><tr><td align="center">竞争范围</td><td align="center">经济领域、国内市场</td><td align="center">各个领域和部门由国内扩展到国外</td></tr></tbody></table></li></ul></li></ul></li><li><p>金融资本与金融寡头</p><ol><li>金融资本：<ul><li>含义：是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。</li><li>主要途径：金融联系、资本参与和人事参与</li></ul></li><li>金融寡头：<ul><li>含义：是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或资本家集团。</li><li>统治方式：<ul><li>经济上：通过”参与制“来实现</li><li>政治上：通过同政府的”个人联合“来实现</li><li>内外政策上：通过建立政策咨询机构等方式</li></ul></li></ul></li></ol></li><li><p>垄断利润</p><ul><li>是垄断资本家凭借其在社会生产和流通中的垄断地位而获得的<font color=red>超过平均利润</font>的高额利润。</li><li>归根到底来自无产阶级和其他劳动人民创造的剩余价值。</li><li>具体来源：<ul><li>来自加强本国无产阶级和其他劳动人民剥削</li><li>控制市场获得其他企业特别是非垄断企业利润</li><li>通过加强其他国家劳动人民的剥削和掠夺</li><li>通过国家在分配将国民收入的一部分变成垄断资本的收入</li></ul></li></ul></li><li><p>垄断价格：</p><ul><li>垄断利润通过垄断组织制定的垄断价格实现</li><li>公式：垄断价格=成本价格+平均利润+垄断利润</li><li>包括垄断高价和垄断低价两种形式</li><li>没有否定价值规律，是价值规律在垄断资本主义阶段作用的具体体现</li></ul></li></ol><h3 id="二、垄断资本主义的发展"><a href="#二、垄断资本主义的发展" class="headerlink" title="二、垄断资本主义的发展"></a>二、垄断资本主义的发展</h3><h4 id="一、国家垄断资本主义"><a href="#一、国家垄断资本主义" class="headerlink" title="一、国家垄断资本主义"></a>一、国家垄断资本主义</h4><ol><li>内容：国家政权和私人垄断资本融合在一起的垄断资本主义</li><li>形成：是垄断资本主义生产关系在自身范围内的部分质变，标志着资本主义发展进入了新的阶段</li><li>原因：是科技进步和生产社会化程度进一步提高的产物，是资本主义基本矛盾进一步尖锐化的结果<ul><li>社会生产力的发展，要求资本主义生产资料在更大范围内被支配</li><li>经济波动和经济危机的深化</li><li>缓和社会矛盾、协调利益关系</li></ul></li><li>主要形式<ul><li>国家所有并直接经营的企业</li><li>国家与私人共有、合营企业</li><li>国家参与私人垄断资本的再生产过程</li><li>宏观调节，国家运用财政政策、货币经济手段，对社会总供求进行调节</li><li>微观规制，主要是国家运用法律手段规范市场秩序，维护社会公众的合法权益</li></ul></li><li>作用：<ul><li>在一定程度上有利于社会生产力的发展</li><li>在一定范围内突破了私人垄断资本的狭隘界限，适应了社会化大生产的要求</li><li>是劳动人民生活水平有所改善和提高</li><li>加快了资本主义国家的现代化进程</li></ul></li><li>实质：<ul><li>没有改变垄断资本主义的性质</li><li>没有从根本上消除资本主义的基本矛盾</li><li>实质是私人垄断资本利用国家机器来为其服务的手段</li></ul></li></ol><h4 id="二、金融垄断资本"><a href="#二、金融垄断资本" class="headerlink" title="二、金融垄断资本"></a>二、金融垄断资本</h4><ol><li>原因：金融自由化与金融创新是金融垄断资本得以形成和壮大的重要制度条件。</li><li>金融化程度提高表现：<ul><li>金融业在国民经济中的地位大幅上升</li><li>实体经济的资本利润率下降，金融资本急剧膨胀</li><li>以金融为和新的服务业就业人数逐步增加</li><li>虚拟经济越来越脱离实体经济</li></ul></li><li>影响：<ul><li>积极：促进了资本主义的发展</li><li>消极：造成了经济过度虚拟化，导致金融危机频繁发生</li></ul></li></ol><h4 id="三、垄断资本在世界范围的扩展及其后果"><a href="#三、垄断资本在世界范围的扩展及其后果" class="headerlink" title="三、垄断资本在世界范围的扩展及其后果"></a>三、垄断资本在世界范围的扩展及其后果</h4><ol><li>经济动因：<ul><li>将国内过剩的资本输出，在别国谋求高额利润</li><li>将部分非要害技术转移，以取得别国垄断优势</li><li>争夺商品销售市场</li><li>确保原材料和能源的可靠来源</li></ul></li><li>基本形式：<ul><li>借贷资本输出</li><li>生产资本输出</li><li>商品资本输出</li></ul></li><li>社会经济后果：<ol><li>对于资本输出国来讲：<ul><li>带来了巨额利润</li><li>带动和扩大了商品输出</li><li>大大改善了国际收支状况</li><li>对发展中国家的经济命脉形成控制</li></ul></li><li>对于资本输入国主要是发展中国家：<ol><li>积极作用：<ul><li>吸收了资金</li><li>引进了较先进的机器设备和工艺技术</li><li>培训了技术和管理人员</li><li>促进经济发展</li><li>增加了就业</li><li>扩大了外贸</li><li>……</li></ul></li><li>消极后果：<ul><li>付出了较大的经济代价和环境资源代价</li><li>冲击本国民族工业</li><li>债务加重</li><li>对国际资本依赖性增强</li><li>……</li></ul></li></ol></li></ol></li></ol><h4 id="四、垄断资本国际化条件下的垄断组织"><a href="#四、垄断资本国际化条件下的垄断组织" class="headerlink" title="四、垄断资本国际化条件下的垄断组织"></a>四、垄断资本国际化条件下的垄断组织</h4><ol><li>国际垄断同盟：<ul><li>各资本主义国家的垄断组织，通过订立协议建立起国际垄断资本的联盟，即国际垄断同盟</li><li>当代国际垄断同盟的形式以国家垄断资本主义的国际联盟为主</li></ul></li><li>作用：<ul><li>联盟中各国经济中的一体化程度大大增强</li><li>在一定程度上促进了生产和资本的集中</li><li>刺激了生产的发展</li><li>使各国间有可能保持和平与稳定的关系</li></ul></li><li>国际经济协调<ul><li>包括各种国际经济组织、国际经济协议以及地区性的经济组织和集团等</li><li>国际性协调组织主要有三个：国际货币基金组织、世界银行和世界贸易组织</li><li>作用：<ul><li>在一定程度上促进了经济全球化的发展</li><li>根本上是为了维护资产阶级的利益、为他们撰取高额垄断利润服务的</li><li>难以对全球性经济波动和经济危机发挥有效的协调作用</li></ul></li></ul></li></ol><h4 id="五、垄断资本主义的基本特征和实质"><a href="#五、垄断资本主义的基本特征和实质" class="headerlink" title="五、垄断资本主义的基本特征和实质"></a>五、垄断资本主义的基本特征和实质</h4><ol><li>垄断资本主义的基本特征：<ul><li>垄断组织在经济生活中起决定作用</li><li>在金融资本的基础上形成金融寡头的统治</li><li>资本输出有了特别重要的意义</li><li>瓜分世界资本家国际垄断同盟已经形成</li><li>资本主义列强已把世界上的领土分割完毕</li></ul></li><li>垄断资本主义的实质：垄断资本凭借垄断地位，获取高额垄断利润。</li></ol><h3 id="三、经济全球化及其后果"><a href="#三、经济全球化及其后果" class="headerlink" title="三、经济全球化及其后果"></a>三、经济全球化及其后果</h3><ol><li>经济全球化含义：指在生产不断发展、科技加速进步、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出一国和地区的范围而相互联系、相互依赖的一体化过程。</li><li>经济全球化表现：<ul><li>国际分工进一步深化</li><li>贸易的全球化</li><li>金融的全球化</li><li>企业经营的全球化</li></ul></li><li>经济全球化的动因：<ul><li>科学技术的进步和生产力的发展，为经济全球化提供了坚实的物质基础和根本的推动力</li><li>跨国公司的发展为经济全球化提供了适宜的企业组织形式</li><li>各国经济体制的变革，提供了适宜的体制环境和政策条件</li></ul></li><li>经济全球化的影响<ol><li>对发展中国家的积极作用：<ul><li>提贡献先进的技术和管理经验</li><li>提供更多的就业机会</li><li>推动国际贸易发展</li><li>促进跨国公司发展</li></ul></li><li>负面影响：<ul><li>发达国家与发展中国家在经济全球化过程中的地位和收益不平等、不平衡</li><li>加剧了发展中国家资源短缺和环境污染恶化</li><li>一定程度上增加经济风险</li></ul></li></ol></li><li>对经济全球化的态度：要适应和引导好经济全球化，消解经济全球化的负面影响，让它更好惠及每个国家、每个民族。——习近平</li></ol><h3 id="四、正确认识当代资本主义的新变化"><a href="#四、正确认识当代资本主义的新变化" class="headerlink" title="四、正确认识当代资本主义的新变化"></a>四、正确认识当代资本主义的新变化</h3><h4 id="一、当代资本主义政治新变化的表现和特点"><a href="#一、当代资本主义政治新变化的表现和特点" class="headerlink" title="一、当代资本主义政治新变化的表现和特点"></a>一、当代资本主义政治新变化的表现和特点</h4><ol><li>生产资料所有制的变化：<ul><li>国家资本所有制形式形成并发挥重要作用<font color=orange>（性质仍然是资本主义）</font></li><li>法人资本所有制崛起并成为居主导地位的资本所有制形式<font color=orange>（性质是基于资本雇佣劳动的垄断资本集体所有制）</font></li></ul></li><li>劳资关系和分配关系的变化：<ul><li>劳动从进入生产过程开始已经隶属于资本<ul><li>资本主义初期，劳动只是形式上隶属于资本</li><li>随着机器大工业生产体系的建立，劳动对资本就称为实质上的隶属</li></ul></li><li>缓和劳资关系的激励制度<ul><li>职工参与决策</li><li>终身雇佣</li><li>职工持股</li><li>社会福利制度的健全</li></ul></li></ul></li><li>社会阶层、阶级结构的变化：<ul><li>资本家的地位和作用发生很大的变化</li><li>高级职业经理成为经营活动的实际控制者</li><li>知识型和服务型劳动者的数量不断增加</li></ul></li><li>经济调节机制和经济危机形态的变化<ul><li>经济调节机制<ul><li>二战后，开始对经济进行全面干预</li><li>从20世纪70年代起，西方国家普遍走上强化市场机制，弱化政府干预的道路</li></ul></li><li>经济危机呈现新的特点<ul><li>去工业化和产业空心化日趋严重，产业竞争力下降</li><li>经济高度金融化，虚拟经济与实体经济严重脱节</li><li>财政严重债务化，债务危机频繁爆发</li><li>两极分化和社会对立加剧</li><li>经济增长乏力，发展活力不足，周期性危机与结构性危机交织在一起</li><li>金融危机频发，全球经济屡受打击</li></ul></li></ul></li><li>政治制度的变化：<ul><li>政治制度出现多元化的趋势，公民权利有所扩大</li><li>法制建设得到重视和加强，以协调社会各阶级、阶层之间的利益</li><li>改良主义政党<font color=orange>（选择改良资本主义制度而不是推翻它进入社会主义的政党）</font>在政治舞台上的影响日益扩大</li></ul></li></ol><h4 id="二、当代资本主义新变化的原因和实质"><a href="#二、当代资本主义新变化的原因和实质" class="headerlink" title="二、当代资本主义新变化的原因和实质"></a>二、当代资本主义新变化的原因和实质</h4><ol><li>当代资本主义新变化的原因：<ul><li>科学技术革命和生产力的发展：<font color=red>根本推动力量</font></li><li>工人阶级争取权力和利益的斗争：<font color=red>重要力量</font></li><li>社会主义制度显示的优越性：<font color=red>重要影响</font></li><li>主张改良主义的政党的改革：<font color=red>重要作用</font></li></ul></li><li>当代资本主义新变化的实质：<ul><li>根本上说是人类社会发展一般规律和资本主义经济规律作用的结果</li><li>是资本主义制度基本框架内的变化，资本主义生产关系的根本性质未发生变化</li></ul></li></ol><h4 id="三、2008年金融危机以来资本主义的矛盾和冲突"><a href="#三、2008年金融危机以来资本主义的矛盾和冲突" class="headerlink" title="三、2008年金融危机以来资本主义的矛盾和冲突"></a>三、2008年金融危机以来资本主义的矛盾和冲突</h4><ol><li>表现：<ul><li>经济发展“失调”</li><li>政治体制“失灵”</li><li>社会融合机制“失效”</li></ul></li><li>深层次原因和根源：归根结底还在于资本主义制度本身在于资本主义的基本矛盾。</li></ol><h3 id="五、资本主义的历史地位和发展趋势"><a href="#五、资本主义的历史地位和发展趋势" class="headerlink" title="五、资本主义的历史地位和发展趋势"></a>五、资本主义的历史地位和发展趋势</h3><h4 id="一、资本主义的历史地位"><a href="#一、资本主义的历史地位" class="headerlink" title="一、资本主义的历史地位"></a>一、资本主义的历史地位</h4><ol><li>进步性：<font color=orange>（强大的创富能力）</font><ul><li>资本主义将科学技术转变为强大的生产力</li><li>资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展</li><li>资本主义的意识形态和政治制度作为上层建筑推动了社会生产力的迅速发展，促进了社会进步</li></ul></li><li>局限性：<ul><li>资本主义基本矛盾阻碍社会生产力的发展</li><li>财富占有两极分化，引起经济危机</li><li>资本家阶级支配和控制资本主义经济和政治的发展和运行，不断激化社会矛盾和冲突</li></ul></li></ol><h4 id="二、资本主义为社会主义所代替的历史必然性"><a href="#二、资本主义为社会主义所代替的历史必然性" class="headerlink" title="二、资本主义为社会主义所代替的历史必然性"></a>二、资本主义为社会主义所代替的历史必然性</h4><p>​    资本主义的内在矛盾决定了必然被代替：</p><ul><li>资本主义基本矛盾“包含着现代的一切冲突的萌芽”</li><li>资本积累推动基本矛盾激化并最终否定资本主义自身</li><li>国家垄断资本主义将成为社会主义的前奏</li><li>存在着资产阶级和无产阶级两大阶级之间的矛盾斗争</li></ul><h4 id="三、社会主义代替资本主义是一个长期的历史过程"><a href="#三、社会主义代替资本主义是一个长期的历史过程" class="headerlink" title="三、社会主义代替资本主义是一个长期的历史过程"></a>三、社会主义代替资本主义是一个长期的历史过程</h4><ol><li>原因：<ul><li>任何社会形态的存在都有相对稳定性，从产生到衰亡都要经过相当长的时间跨度</li><li>资本主义发展的不平衡性决定了过度的长期性</li><li>当代资本主义的发展还显示出生产关系对生产力容纳的空间</li></ul></li></ol><h2 id="第七章：社会主义社会的发展及其规律"><a href="#第七章：社会主义社会的发展及其规律" class="headerlink" title="第七章：社会主义社会的发展及其规律"></a>第七章：社会主义社会的发展及其规律</h2><h3 id="一、社会主义五百年的历史进程"><a href="#一、社会主义五百年的历史进程" class="headerlink" title="一、社会主义五百年的历史进程"></a>一、社会主义五百年的历史进程</h3><h4 id="一、社会主义从空想到科学的飞跃"><a href="#一、社会主义从空想到科学的飞跃" class="headerlink" title="一、社会主义从空想到科学的飞跃"></a>一、社会主义从空想到科学的飞跃</h4><ol><li><p>空想社会主义的产生和发展</p><ul><li>空想社会主义产生于16世纪初期</li><li>三个历史发展阶段<ul><li>16-17世纪的早期空想社会主义</li><li>18世纪的空想平均共产主义</li><li>19世纪初期批判的空想社会主义</li></ul></li><li>19世纪初期以圣西门、傅立叶、欧文为代表的空想社会主义是科学社会主义的直接思想来源</li></ul></li><li><p>空想社会主义的局限性</p><ul><li>只看到了资本主义必然灭亡的命运，却未能揭示资本主义必然灭亡的经济根源</li><li>要求埋葬资本主义，却看不到埋葬资本主义的力量</li><li>憧憬取代资本主义的理想社会，却找不到通往理想社会的现实道路</li></ul></li><li><p>科学社会主义的创立</p><p> 马克思创立了<font color=red>唯物史观和剩余价值学说</font>，为实现社会主义从空想到科学的飞跃奠定了坚实的<font color=red>理论基础</font></p></li></ol><h4 id="二、社会主义从理想到现实的飞跃"><a href="#二、社会主义从理想到现实的飞跃" class="headerlink" title="二、社会主义从理想到现实的飞跃"></a>二、社会主义从理想到现实的飞跃</h4><ol><li>第一国际和巴黎公社<ul><li>1864年，国际工人协会（第一国际）<ul><li>促进了马克思主义传播和与国际工人运动的结合</li><li>初步确立了马克思主义在工人运动中的指导地位</li></ul></li><li>1871年，巴黎公社革命<ul><li>是无产阶级夺取政权的第一次伟大尝试</li><li>为无产阶级革命和工人运动留下了宝贵经验</li><li>丰富和发展了关于阶级斗争和社会主义的学说</li></ul></li></ul></li><li>十月革命胜利与第一个社会主义国家的建立<ul><li>十月革命<ul><li>列宁领导了俄国十月革命，1917年11月7日取得了十月社会主义革命的胜利</li><li>十月革命实现了社会主义从理想到现实的伟大飞跃，开辟了人类历史的新纪元</li></ul></li></ul></li></ol><h4 id="三、社会主义从一国到多国的发展"><a href="#三、社会主义从一国到多国的发展" class="headerlink" title="三、社会主义从一国到多国的发展"></a>三、社会主义从一国到多国的发展</h4><ol><li>社会主义在苏联一国的实践<ul><li>列宁社会主义探索的精辟论述<ul><li>把建设社会主义作为长期探索、不断实践的过程</li><li>把大力发展生产力、提高劳动生产率放在首要地位</li><li>在多种经济成分并存的条件下，利用商品、货币和市场发展经济</li><li>利用资本主义，建成社会主义</li></ul></li><li>列宁最宝贵的思想遗产：把马克思主义基本原理同俄国的具体世纪相结合，探索出一条适合俄国国情的社会主义道路</li><li>苏联模式<ul><li>促进了社会主义制度的巩固和发展，为苏联社会主义建设奠定了物质基础</li><li>苏联模式并不是社会主义的唯一模式</li></ul></li></ul></li><li>社会主义发展到多个国家<ul><li>二战后，社会主义在世界范围内获得大发展<ul><li>从1944年到1949年的五年间，欧洲和亚洲有11个国家走上了社会主义道路</li></ul></li><li>在发展中也出现过曲折<ul><li>东欧剧变、苏联解体</li><li>最根本原因：放弃了社会主义道路，放弃了无产阶级专政，放弃了共产党的领导地位，放弃了马克思列宁主义</li></ul></li></ul></li></ol><h4 id="四、社会主义在中国焕发出强大生机活力"><a href="#四、社会主义在中国焕发出强大生机活力" class="headerlink" title="四、社会主义在中国焕发出强大生机活力"></a>四、社会主义在中国焕发出强大生机活力</h4><ol><li>中国特色社会主义：<ul><li>中国特色社会主义的成功，不仅在中华人民共和国发展史上和中华民族发展史上具有重大意义，而且在世界社会主义发展史上和人类社会发展史上也具有重大意义。</li></ul></li></ol><h3 id="二、科学社会主义一般原则"><a href="#二、科学社会主义一般原则" class="headerlink" title="二、科学社会主义一般原则"></a>二、科学社会主义一般原则</h3><h4 id="一、科学社会主义一般原则"><a href="#一、科学社会主义一般原则" class="headerlink" title="一、科学社会主义一般原则"></a>一、科学社会主义一般原则</h4><ul><li>人类社会发展规律和资本主义基本矛盾</li><li>无产阶级是最先进最革命的阶级</li><li>无产阶级革命是无产阶级进行斗争的最高形式</li><li>生产资料公有制</li><li>对生产进行有计划的指导和调节，实行按劳分配原则</li><li>实现人与自然的和谐共生</li><li>大力发展社会主义先进文化</li><li>必须始终坚持无产阶级政党的领导</li><li>解放和发展生产力，实现共同富裕和社会全面进步</li></ul><h4 id="二、正确把握科学社会主义一般原则"><a href="#二、正确把握科学社会主义一般原则" class="headerlink" title="二、正确把握科学社会主义一般原则"></a>二、正确把握科学社会主义一般原则</h4><ul><li>必须始终坚持科学社会主义一般原则，反对任何背离科学社会主义一般原则的错误倾向</li><li>要善于把科学社会主义一般原则与本国实际相结合，创造性地回答和解决革命、建设、改革中的重大问题</li><li>紧跟时代和实践的发展，在不断总结新鲜经验中进一步丰富和发展科学社会主义一般原则</li></ul><h3 id="三、在实践中探索现实社会主义的发展规律"><a href="#三、在实践中探索现实社会主义的发展规律" class="headerlink" title="三、在实践中探索现实社会主义的发展规律"></a>三、在实践中探索现实社会主义的发展规律</h3><h4 id="一、落后国家建设社会主义的长期性"><a href="#一、落后国家建设社会主义的长期性" class="headerlink" title="一、落后国家建设社会主义的长期性"></a>一、落后国家建设社会主义的长期性</h4><ol><li>原因<ul><li>生产力发展状况的制约</li><li>经济基础和上层建筑发展状况的制约</li><li>国际环境的严峻挑战</li><li>马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程</li></ul></li></ol><h4 id="二、社会主义发展道路多样性的原因"><a href="#二、社会主义发展道路多样性的原因" class="headerlink" title="二、社会主义发展道路多样性的原因"></a>二、社会主义发展道路多样性的原因</h4><ol><li>原因<ul><li>各个国家的生产力发展状况和社会发展阶段决定了社会主义发展道路具有不同的特点</li><li>历史文化传统的差异性是造成社会主义发展道路多样性的重要条件</li><li>时代和实践的不断发展，是造成社会主义发展道路多样性的现实原因</li></ul></li></ol><h4 id="三、探索适合本国国情的社会主义发展道路"><a href="#三、探索适合本国国情的社会主义发展道路" class="headerlink" title="三、探索适合本国国情的社会主义发展道路"></a>三、探索适合本国国情的社会主义发展道路</h4><ol><li>要求<ul><li>必须坚持对待马克思主义的科学态度</li><li>必须从当时当地的历史条件出发，坚持“走自己的路”</li><li>必须充分吸收人类一切文明成果</li></ul></li></ol><h4 id="四、社会主义在实践探索中开拓前进"><a href="#四、社会主义在实践探索中开拓前进" class="headerlink" title="四、社会主义在实践探索中开拓前进"></a>四、社会主义在实践探索中开拓前进</h4><ol><li>原因：在实践中开拓前进是社会主义事业发展的必然要求</li><li>要求：以自信担当开拓奋进的姿态走向社会主义光明未来</li></ol><h2 id="第八章：共产主义崇高理想及其最终实现"><a href="#第八章：共产主义崇高理想及其最终实现" class="headerlink" title="第八章：共产主义崇高理想及其最终实现"></a>第八章：共产主义崇高理想及其最终实现</h2><h3 id="一、展望未来共产主义新社会"><a href="#一、展望未来共产主义新社会" class="headerlink" title="一、展望未来共产主义新社会"></a>一、展望未来共产主义新社会</h3><h4 id="一、展望未来社会的科学立场和方法"><a href="#一、展望未来社会的科学立场和方法" class="headerlink" title="一、展望未来社会的科学立场和方法"></a>一、展望未来社会的科学立场和方法</h4><ol><li>科学方法论原则<ul><li>在揭示社会发展一般规律的基础上指明社会发展方向</li><li>在剖析资本主义社会旧世界中阐发未来新世界的特点</li><li>在社会主义社会发展中不断深化对共产主义社会的认识</li><li>立足于揭示未来社会的一般特征，而不作细节描绘</li></ul></li></ol><h4 id="二、共产主义社会的基本特征"><a href="#二、共产主义社会的基本特征" class="headerlink" title="二、共产主义社会的基本特征"></a>二、共产主义社会的基本特征</h4><ul><li>物质财富极大丰富，消费资料按需分配<ul><li>社会生产力高度发展，产品极大丰富，是必要条件和重要特征</li><li>将彻底废除私有制，实行普遍的生产关系公有制</li><li>将按照资源情况和社会需要，对生产进行有计划的组织和管理</li><li>个人消费品的分配方式是“各尽所能，按需分配”</li></ul></li><li>社会关系高度和谐，人们精神境界极大提高<ul><li>阶级将会消亡</li><li>国家也将消亡</li><li>“三大差别”<font color=orange>（工业与农业、城市与乡村、脑力劳动与体力劳动）</font>必然归于消失</li><li>社会与自然之间也达成了和谐</li><li>人们的精神境界得到极大提高</li></ul></li><li>实现每个人自由而全面的发展，人类从必然王国向自由王国的飞跃<ul><li>实现人的自由而全面的发展<font color=red>（根本价值目标和根本特征）</font></li><li>人的发展是自由的发展，建立在个体高度自由自觉基础上</li><li>是人类解放的实现，实现从必然王国向自由王国的飞跃</li></ul></li></ul><h3 id="二、实现共产主义是历史发展的必然趋势"><a href="#二、实现共产主义是历史发展的必然趋势" class="headerlink" title="二、实现共产主义是历史发展的必然趋势"></a>二、实现共产主义是历史发展的必然趋势</h3><h4 id="一、实现共产主义是历史发展的必然"><a href="#一、实现共产主义是历史发展的必然" class="headerlink" title="一、实现共产主义是历史发展的必然"></a>一、实现共产主义是历史发展的必然</h4><ol><li>共产主义一定能实现，是由社会发展规律决定的<ul><li>共产主义理想是在对人类社会发展规律认识的基础上建立的社会发展目标</li><li>共产主义理想一定会实现是以人类社会发展规律以及社会主义社会的基本矛盾发展为依据的</li><li>社会主义运动的实践，已经并正在用事实证明者共产主义理想实现的必然性</li></ul></li></ol><h4 id="二、实现共产主义是长期的历史过程"><a href="#二、实现共产主义是长期的历史过程" class="headerlink" title="二、实现共产主义是长期的历史过程"></a>二、实现共产主义是长期的历史过程</h4><ol><li>原因<ul><li>资本主义的灭亡和向社会主义的转变是一个长期的过程</li><li>社会主义社会的充分发展和最终向共产主义过渡需要很长的历史时期</li></ul></li></ol><h4 id="三、远大理想与共同理想"><a href="#三、远大理想与共同理想" class="headerlink" title="三、远大理想与共同理想"></a>三、远大理想与共同理想</h4><ol><li>坚持远大理想与共同理想的辩证统一<ul><li>坚持发展中国特色社会主义是通向共产主义的必由之路</li><li>正确认识和把握共产主义远大理想与中国特色社会主义共同理想的关系</li></ul></li><li>坚定理想信念，投身新时代中国特色社会主义事业<ul><li>理想信念是鼓舞人们前进和奋斗的强大精神动力</li><li>要积极投身新时代中国特色社会主义事业</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章：马克思主义是关于无产阶级和人类解放的科学&quot;&gt;&lt;a href=&quot;#第一章：马克思主义是关于无产阶级和人类解放的科学&quot; class=&quot;headerlink&quot; title=&quot;第一章：马克思主义是关于无产阶级和人类解放的科学&quot;&gt;&lt;/a&gt;第一章：马克思主义是关于无产</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="政治" scheme="https://www.oliverbryant.cn/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>politics</title>
    <link href="https://www.oliverbryant.cn/2021/01/11/politics/"/>
    <id>https://www.oliverbryant.cn/2021/01/11/politics/</id>
    <published>2021-01-11T10:52:00.000Z</published>
    <updated>2021-07-01T09:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分：考研政治"><a href="#第一部分：考研政治" class="headerlink" title="第一部分：考研政治"></a>第一部分：考研政治</h2><h3 id="一、命题结构："><a href="#一、命题结构：" class="headerlink" title="一、命题结构："></a>一、命题结构：</h3><table><thead><tr><th align="center">科目</th><th align="center">分值</th><th align="center">方法</th></tr></thead><tbody><tr><td align="center">马克思主义基本原理</td><td align="center">24</td><td align="center">背诵</td></tr><tr><td align="center">毛泽东思想中国特色社会主义理论体系</td><td align="center">30</td><td align="center">背诵</td></tr><tr><td align="center">中国近现代史纲要</td><td align="center">14</td><td align="center">八位一体（时间-地点-人物-事件-原因-结果-意义-局限）</td></tr><tr><td align="center">思想道德修养与法律基础</td><td align="center">16</td><td align="center">践行</td></tr><tr><td align="center">形式与政策以及当代世界经济与政治</td><td align="center">16</td><td align="center">多看多听多记</td></tr></tbody></table><h3 id="二、马克思主义基本原理"><a href="#二、马克思主义基本原理" class="headerlink" title="二、马克思主义基本原理"></a>二、马克思主义基本原理</h3><ol><li>马克思主义哲学：马克思主义基本原理的基础（16分，单选、多选、材料）<ol><li>直观式考察：直接问</li><li>名言警句古诗词</li><li>领袖人物的讲话</li></ol></li><li>马克思主义政治经济学：马克思主义基本原理的重点（6分，单选x2、多选x2）</li><li>科学社会主义：马克思主义基本原理的结论（1-2分，单选/多选）</li></ol><h2 id="第二部分：零散知识"><a href="#第二部分：零散知识" class="headerlink" title="第二部分：零散知识"></a>第二部分：零散知识</h2><h3 id="1-中国的国体和政体"><a href="#1-中国的国体和政体" class="headerlink" title="1.中国的国体和政体"></a>1.中国的国体和政体</h3><ol><li>中国的国体：人民民主专政</li><li>中国的政体：人民代表大会制度</li></ol><h3 id="2-中国的矛盾"><a href="#2-中国的矛盾" class="headerlink" title="2.中国的矛盾"></a>2.中国的矛盾</h3><ol><li>1840年前：封建主义（地主）与人民大众（农民）的矛盾。</li><li>1840年后：帝国主义与中华民族的矛盾。<font color=red>近代中国贫穷的总根源</font></li></ol><h3 id="3-中国共产党的宗旨和初心使命"><a href="#3-中国共产党的宗旨和初心使命" class="headerlink" title="3.中国共产党的宗旨和初心使命"></a>3.中国共产党的宗旨和初心使命</h3><ol><li>宗旨：全心全意为人民服务</li><li>初心使命：<ul><li>为中国人民谋幸福</li><li>为中华民族谋复兴</li></ul></li></ol><h3 id="4-人大代表和全国人大的职权"><a href="#4-人大代表和全国人大的职权" class="headerlink" title="4.人大代表和全国人大的职权"></a>4.人大代表和全国人大的职权</h3><ol><li>人大代表：<ul><li>提案权</li><li>审议权</li><li>表决权</li><li>质询权</li></ul></li><li>全国人大：最高权力机关<ul><li>立法权</li><li>决定权</li><li>任免权：正部级以上</li><li>监督权：一府两院监察委<ul><li>中国人民政府（国务院）</li><li>最高人民法院</li><li>最高人民检察院</li></ul></li></ul></li></ol><h3 id="5-市场"><a href="#5-市场" class="headerlink" title="5.市场"></a>5.市场</h3><ol><li>十八届三中全会之前：市场&rarr;基础性</li><li>十八界三中全会之后：市场&rarr;决定性</li><li>市场具有自发调节机制。</li><li>市场调节的缺陷：<ul><li>自发性</li><li>盲目性</li><li>滞后性</li></ul></li><li>宏观调控：<ul><li>经济手段</li><li>法律手段</li><li>行政手段：命令</li></ul></li></ol><h3 id="6-社会形态的划分"><a href="#6-社会形态的划分" class="headerlink" title="6.社会形态的划分"></a>6.社会形态的划分</h3><ol><li><p>原始社会</p></li><li><p>奴隶社会</p><ul><li>奴隶主</li><li>奴隶<font color=orange>（人身全依附）</font></li></ul></li><li><p>封建社会</p><ul><li>地主</li><li>农民</li></ul></li><li><p>资本主义社会</p><ul><li>资产阶级</li><li>无产阶级</li></ul></li><li><p>共产主义社会（社会主义社会是其第一阶段）</p><p><font color=blue>1949-1956中国处于新民主主义社会</font><font color=orange>属于社会主义社会</font></p></li></ol><h3 id="7-资本主义社会矛盾"><a href="#7-资本主义社会矛盾" class="headerlink" title="7.资本主义社会矛盾"></a>7.资本主义社会矛盾</h3><p>​    生产社会化同生产资料资本主义私有制之间的矛盾</p><h3 id="8-中国的矛盾"><a href="#8-中国的矛盾" class="headerlink" title="8.中国的矛盾"></a>8.中国的矛盾</h3><ol><li>1981年十一届六中全会之前：人民日益增长的物质文化需要与落后的社会生产之间的矛盾。</li><li>2017年十九大以来：人民日益增长的美好生活需要与<u>不平衡不充分</u>的发展之间的矛盾。<ul><li>公平</li><li>正义</li><li>民主</li><li>法治</li><li>环境</li><li>安全</li></ul></li></ol><h3 id="9-哲学的两个对子"><a href="#9-哲学的两个对子" class="headerlink" title="9.哲学的两个对子"></a>9.哲学的两个对子</h3><ol><li>唯物主义和唯心主义</li><li>辩证法和形而上学</li></ol><h3 id="10-宇宙"><a href="#10-宇宙" class="headerlink" title="10.宇宙"></a>10.宇宙</h3><ul><li>时间：无始无终</li><li>空间：无边无际</li></ul><h3 id="11-实践"><a href="#11-实践" class="headerlink" title="11.实践"></a>11.实践</h3><p>​    是自然存在与社会存在区分和统一的基础。</p><h3 id="12-意识的外壳"><a href="#12-意识的外壳" class="headerlink" title="12.意识的外壳"></a>12.意识的外壳</h3><p>​    语言是意识的外壳。</p><h3 id="13-庸俗唯物主义"><a href="#13-庸俗唯物主义" class="headerlink" title="13.庸俗唯物主义"></a>13.庸俗唯物主义</h3><p>​    意识是人脑的分泌物。<font color=red>是错的</font></p><h3 id="14-人类社会存在和发展的基础"><a href="#14-人类社会存在和发展的基础" class="headerlink" title="14.人类社会存在和发展的基础"></a>14.人类社会存在和发展的基础</h3><p>​    物质资料的生产方式是人类社会存在和发展的基础，集中体现者人类社会的物质性。</p><h3 id="15-衡量社会进步与否的根本标准"><a href="#15-衡量社会进步与否的根本标准" class="headerlink" title="15.衡量社会进步与否的根本标准"></a>15.衡量社会进步与否的根本标准</h3><p>​    生产工具是衡量社会进步与否的根本标准。</p><h3 id="16-能动性"><a href="#16-能动性" class="headerlink" title="16.能动性"></a>16.能动性</h3><p>​    有目的的，有想法的</p><h3 id="17-唯物与唯心"><a href="#17-唯物与唯心" class="headerlink" title="17.唯物与唯心"></a>17.唯物与唯心</h3><p>​    在第二章，出发点是世界来自于哪里</p><p>​    第三章出发点是认识来自于哪里</p><h3 id="18-资本"><a href="#18-资本" class="headerlink" title="18.资本"></a>18.资本</h3><ol><li>按周转方式分：固定资本、流动资本</li><li>按能否增值分：不变资本、可变资本</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一部分：考研政治&quot;&gt;&lt;a href=&quot;#第一部分：考研政治&quot; class=&quot;headerlink&quot; title=&quot;第一部分：考研政治&quot;&gt;&lt;/a&gt;第一部分：考研政治&lt;/h2&gt;&lt;h3 id=&quot;一、命题结构：&quot;&gt;&lt;a href=&quot;#一、命题结构：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="考研" scheme="https://www.oliverbryant.cn/categories/Postgraduate/"/>
    
    
    <category term="政治" scheme="https://www.oliverbryant.cn/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>无线网导论笔记</title>
    <link href="https://www.oliverbryant.cn/2020/12/23/%E2%95%AC%E2%96%90%E2%95%A7%E2%96%80%E2%95%90%C2%B0%E2%95%A1%E2%95%9D%E2%94%AC%E2%96%88%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/"/>
    <id>https://www.oliverbryant.cn/2020/12/23/%E2%95%AC%E2%96%90%E2%95%A7%E2%96%80%E2%95%90%C2%B0%E2%95%A1%E2%95%9D%E2%94%AC%E2%96%88%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/</id>
    <published>2020-12-23T11:18:42.000Z</published>
    <updated>2021-07-01T09:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-无线网络按覆盖范围分为几类？从应用角度看，无线网络分为几类？"><a href="#1-无线网络按覆盖范围分为几类？从应用角度看，无线网络分为几类？" class="headerlink" title="1.无线网络按覆盖范围分为几类？从应用角度看，无线网络分为几类？"></a>1.无线网络按覆盖范围分为几类？从应用角度看，无线网络分为几类？</h3><ol><li><p>按覆盖范围：系统内部互联/无线个域网；无线局域网；无线城域网/无线广域网</p><ol><li>无线广域网（WWAN）：<ul><li>指全国范围或全球范围的通信，通信速率不高。</li><li>典型的例子：GSM移动通信系统、卫星通信系统。</li><li>通常采用大蜂窝或宏蜂窝结构。</li></ul></li><li>无线城域网（WMAN）：<ul><li>覆盖范围几千米到几十千米。</li><li>典型的例子：IEEE802.16无线城域网系统、多信道多点分配系统。</li><li>通常采用大蜂窝或宏蜂窝结构。</li></ul></li><li>无线局域网（WLAN）：<ul><li>覆盖范围几十米到几千米。</li><li>典型的例子：IEEE802.11系列标准、HiperLAN系列标准。</li><li>通常采用微蜂窝或微微蜂窝结构，也可采用非蜂窝结构。</li></ul></li><li>无线个域网（WPAN）：<ul><li>通过短距离的无线电，将计算机各部件连接起来。</li><li>典型的例子：蓝牙技术、ZigBee技术、NFC技术。</li><li>采用主——从模式。</li></ul></li></ol></li><li><p>从应用角度看：无线传感器网络、无线Mesh网路、无线穿戴网络、无线体域网</p><ol><li><p>无线传感器网络：</p><p>最少的成本和最高的灵活性，通过各类集成化的传感器协作完成。</p></li><li><p>无线Mesh网络：</p><p>称为“多条”网络，典型的例子：Internet，无限版本的Internet。无线Mesh网络省掉了节点间的布线需求，仍具有冗余机制和重新路由功能。</p></li><li><p>无线穿戴网络：</p><p>基于短距离无线电和可穿戴式计算机技术，穿戴在人体上，智能地收集人体和周围环境信息的新型个域网。</p></li><li><p>无线体域网：</p><p>依靠身体上的各类传感器网络。</p></li></ol></li></ol><h3 id="2-无线网络的协议模型有哪些特点？"><a href="#2-无线网络的协议模型有哪些特点？" class="headerlink" title="2. 无线网络的协议模型有哪些特点？"></a>2. 无线网络的协议模型有哪些特点？</h3><ol><li>无线网络的协议模型是基于分层体系结构的，不同类型的无线网络所重点关注的协议层是不相同的。</li><li>无线局域网、无线个域网和无线城域网一般不存在路由器问题，所以没有网络层协议，主要采用传统的网络层IP。</li><li>无线广域网、移动Ad Hoc网络、无线传感器网络和无线Mesh网络，它们存在路由问题，不仅要关注物理层和MAC层，网络层协议也是重要的组成部分。</li><li>无线传输链路是高度不可靠的，它们总是丢失分组。处理丢失分组的正确方法是重新发送这些分组。</li><li>无线网络对应用层的协议不是无线网络的重点，只要支持传统的应用层协议就可以了。</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-无线网络的传输主要使用哪三类电磁波？各有什么特点？"><a href="#1-无线网络的传输主要使用哪三类电磁波？各有什么特点？" class="headerlink" title="1.无线网络的传输主要使用哪三类电磁波？各有什么特点？"></a>1.无线网络的传输主要使用哪三类电磁波？各有什么特点？</h3><ol><li>微波：<ul><li>频率在1GHz~100GHz</li><li>具有高方向性</li><li>用于长途电信服务，也适用于点对点传输</li></ul></li><li>无线电广播：<ul><li>频率在30MHz~1GHz</li><li>无线电广播的损伤主要是多路径干扰</li></ul></li><li>红外线：<ul><li>频率在$3<em>10^{11}$~$2</em>10^{14}$Hz</li><li>无法穿透墙壁</li><li>优点：不需要申请频段，花费较小；在微波系统中遇到的安全性和干扰问题在红外传输都不存在。</li><li>缺点：收发器和收发器之间的距离不能超过视线范围。</li></ul></li></ol><h3 id="2-天线的增益是什么？比较分析从天线辐射出去的信号有几种传播方式？"><a href="#2-天线的增益是什么？比较分析从天线辐射出去的信号有几种传播方式？" class="headerlink" title="2.天线的增益是什么？比较分析从天线辐射出去的信号有几种传播方式？"></a>2.天线的增益是什么？比较分析从天线辐射出去的信号有几种传播方式？</h3><ul><li>天线的增益是天线定向性的度量。它不是为了获得比输入功率更高的输出功率，主要是为了定向性。要改善天线增益可以增大有效面积或提高无线电波频率。</li></ul><p>$$<br>G=\frac{4{\mathrm{πA}}<em>{\mathrm e}}{\lambda^2}=\frac{4\mathrm{πf}^2{\mathrm A}</em>{\mathrm e}}{c^2}<br>$$</p><ul><li>传播方式<ol><li>地波：<ul><li>或多或少沿着地球的轮廓前行，且可以传播相当远的距离。</li><li>频率低于2MHz。</li><li>典型的例子：调幅（AM）无线电</li></ul></li><li>天波：<ul><li>基于地球天线的信号从被电离的上层大气反射回地球，实际由于折射引起。</li><li>频率范围：2MHz~30Mhz</li></ul></li><li>直线传播：<ul><li>发送天线和接收天线之间直线传播。</li><li>频率范围：30MHz以上</li></ul></li></ol></li></ul><h3 id="3-对于无线网络，需要考虑的直线传输中的损伤主要有哪些？"><a href="#3-对于无线网络，需要考虑的直线传输中的损伤主要有哪些？" class="headerlink" title="3.对于无线网络，需要考虑的直线传输中的损伤主要有哪些？"></a>3.对于无线网络，需要考虑的直线传输中的损伤主要有哪些？</h3><ol><li>衰减：一个信号的强度会随所跨越的任何传输媒介的距离而降低。</li><li>衰减失真：高频下的衰减会引起失真，即衰减失真。由于衰减的变化是频率的一个函数，接收信号失真会导致信号的可理解性降低。</li><li>自由空间损耗：信号随距离的增加会在越来越大的面积范围内散布。</li></ol><p>$$<br>\frac{P_t}{P_r}=\frac{\left(4\mathrm\pi\right)^2d^2}{G_rG_t\lambda^2}=\frac{\left(\lambda d\right)^2}{A_rA_t}=\frac{cd^2}{f^2A_rA_t}<br>$$</p><ol start="4"><li>噪声：<ul><li>热噪声、互调噪声、串扰、脉冲噪声</li><li>其中热噪声无法消除称为白噪声</li></ul></li><li>大气吸收：<ul><li>水蒸气和氧气是造成这种衰减的主要因素</li><li>水蒸气衰减峰值：22GHz；低于15GHz影响减弱。</li><li>氧气衰减峰值：60GHz；低于30GHz影响减弱。</li></ul></li><li>多径：在直线传播中，两点通信通常会有许多障碍物，信号被障碍物反射叠加，从而造成多路径损伤。</li><li>折射：由信号高度的变化引起信号速度的变化或大气条件下其他控件的改变都会引起折射。引起折射则会有一部分直线波没有到达天线，从而造成折射损伤。</li></ol><h3 id="4-扩频技术主要有哪些？"><a href="#4-扩频技术主要有哪些？" class="headerlink" title="4.扩频技术主要有哪些？"></a>4.扩频技术主要有哪些？</h3><ol><li>直接序列扩频（DSSS）：原始信号中的每一位在传输信号中以多个位表示，此技术使用了扩展编码，这种扩展编码将信号扩展到更宽的频段上，而这个频段范围与使用的位数成正比。</li><li>跳频扩频（FHSS）：直接用输入数据流调制射频载波，扩频函数用来在一定的频隙范围内控制载波的特定频隙，从而扩展传输频段的宽度。</li><li>跳时扩频（THSS）：是一种直接用输入数据流调制射频载波的技术，载波通过脉冲传输，扩频函数控制每个数据脉冲的传输时间。</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="1-比较说明无线局域网的拓扑结构。"><a href="#1-比较说明无线局域网的拓扑结构。" class="headerlink" title="1.比较说明无线局域网的拓扑结构。"></a>1.比较说明无线局域网的拓扑结构。</h3><ol><li><p>分布对等式拓扑：</p><ol><li>至少有两个站，没有AP，自发方式构成的单区网。</li><li>工作模式为自组织网络（Ad Hoc）：随时需要随时组建，不需要预先计划。</li></ol></li><li><p>基础架构设计式拓扑：</p><ol><li>组成：分布式系统媒体、AP和端口实体。</li><li>至少有一个AP，AP是BSS的中心控制站。</li><li>在此拓扑结构中，一个站想要向同一个BSS内的另一个站通信，必须通过AP进行转接。即宿源—&gt;AP—&gt;宿站。</li></ol></li><li><p>ESS拓扑：</p><ol><li>ESA是由多个BSA通过DS联结形成的一个扩展区域，覆盖范围可达数千米。</li><li>同属于一个ESA的所有站组成ESS。</li><li>ESS是一种由多个BSS组成的多区网，其中每个BSS都有一个BSSID。</li><li>一个站从BSA移动到另一个BSA称为散布或越区切换（数据链路层的移动）。</li><li>一个站从一个ESA到另一个ESA称为漫游（网络层的移动）。</li></ol></li><li><p>中继或桥接型网络拓扑：</p><p>两个或者多个网络后者网段可以通过无线中继器、无线网桥或无线路由器等无线网络互联设备连接起来。</p></li></ol><h3 id="2-阐述WiFi的特点。"><a href="#2-阐述WiFi的特点。" class="headerlink" title="2.阐述WiFi的特点。"></a>2.阐述WiFi的特点。</h3><ul><li>WiFi联盟：在无线局域网标准的采纳和市场推进中，WiFi联盟起到了主导作用。</li><li>IEEE802.11标准：<ol><li>有物理层和MAC层。</li><li>物理层进一步划分：物理层会聚过程子层、物理媒体依赖子层、物理管理子层。</li><li>MAC层支持的物理层：IEEE802.11b在2.4GHz频段上提供1~11Mb/s的传输速率。</li><li>MAC层划分为：MAC子层和MAC管理子层。</li><li>MAC层的覆盖的功能区：可靠的数据传送、接入控制以及安全。</li></ol></li></ul><h3 id="3-描述IEEE802-11标准中的CSMA-CA的工作原理。"><a href="#3-描述IEEE802-11标准中的CSMA-CA的工作原理。" class="headerlink" title="3.描述IEEE802.11标准中的CSMA/CA的工作原理。"></a>3.描述IEEE802.11标准中的CSMA/CA的工作原理。</h3><ol><li><p>CSMA接入规则：</p><ol><li>要发送帧的站点，感知媒体状况。如果媒体空闲，它等待一段与IFS相等的时间，查看媒体是否仍保持空闲。如果是，该站点可以立即传输。</li><li>如果媒体正忙（或由于该站点一开始就发现媒体正忙或者由于媒体在IFS空闲时段内变忙），该站点延迟传输，并继续监控媒体，直至当前传输结束。</li><li>一旦传输结束，站点延迟另一个IFS。如果媒体在这个时期内保持空闲，那么站点在退后一个随机长度的时间后再次感知媒体状况。如果媒体仍空闲，站点可以传输。在退避的时间内，如果媒体变忙，暂停计数器将停止，并在媒体空闲时重新开始。</li><li>如果传输不成功，这可以通过没有确认来确定，则断定发生了冲突。</li></ol></li><li><p>CTS和RTS：</p><ol><li>RTS（请求发送帧）：发送方在消息发送之前广播发送RTS，警告位于源站点接受范围之内的站点：一个交换正在进行中，为避免同时发送帧产生冲突，这些站点会抑制帧的发送。</li><li>CTS（清除发送帧）：接收方在收到RTS后会广播发送CTS，警告位于目的帧接受范围内的站点：一个交换正在进行。</li></ol></li><li><p>隐藏节点和暴露节点：</p><ol><li><p>隐藏节点：AB在同一个无线局域网BSS1，BC在同一个无线局域网BSS2当A和C都要给B发送消息时，A和C不在同一个BSS中，A检测不到C 要发送消息，C也检测不到A要发送消息，此时A、C会发生冲突，A、C称之为隐藏节点但是使用CSMA/CA协议，会避免冲突A先向B发送RTS即A在BSS1中发送RTS，B收到RTS后，B在BSS1和BSS2中同时发送CTS，抑制其它站点帧的发送，此时就会避免同时发送帧的冲突。</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/hide.jpg?Expires=1608730952&OSSAccessKeyId=TMP.3Kf4gdteZnkWeefDbNmocdFhnETyNZiSRY1kMLuPAbo863LxKYxUsywqmSBojApbbcR32s1ZY7KPMzfMPxYosQTocV1pHV&Signature=KpfkMDK4PQMcbpLWWBptcN2L98w=" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/hide.jpg?Expires=1608730952&OSSAccessKeyId=TMP.3Kf4gdteZnkWeefDbNmocdFhnETyNZiSRY1kMLuPAbo863LxKYxUsywqmSBojApbbcR32s1ZY7KPMzfMPxYosQTocV1pHV&Signature=KpfkMDK4PQMcbpLWWBptcN2L98w=" srcset="data:image/png;base64,666"></p></li><li><p>暴露节点：B、C在同一个BSS1中，C、D是同一个BSS2。假设C要给D发送消息，A要给B发送一个消息，C给D发送消息时，会在BSS1和BSS2中同时广播发送RTS，D收到C发来的RTS后会在BSS2发送一个CTS。当A要给B发送时，检测到C发送的RTS，此时会认为C要给BSS1中的站点发送消息，从而停止发送，避免冲突。其中B是暴露节点。</p><p><img src="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/explore.jpg?Expires=1608731013&OSSAccessKeyId=TMP.3Kf4gdteZnkWeefDbNmocdFhnETyNZiSRY1kMLuPAbo863LxKYxUsywqmSBojApbbcR32s1ZY7KPMzfMPxYosQTocV1pHV&Signature=HIud3DCLjs7fBqR8zatNXG1f+UA=" class="lazyload" data-srcset="https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/explore.jpg?Expires=1608731013&OSSAccessKeyId=TMP.3Kf4gdteZnkWeefDbNmocdFhnETyNZiSRY1kMLuPAbo863LxKYxUsywqmSBojApbbcR32s1ZY7KPMzfMPxYosQTocV1pHV&Signature=HIud3DCLjs7fBqR8zatNXG1f+UA=" srcset="data:image/png;base64,666"></p></li></ol></li></ol><h3 id="4-IEEE802-11标准中如何实现可靠的数据传输？"><a href="#4-IEEE802-11标准中如何实现可靠的数据传输？" class="headerlink" title="4.IEEE802.11标准中如何实现可靠的数据传输？"></a>4.IEEE802.11标准中如何实现可靠的数据传输？</h3><p>​    通过四帧交换来实现可靠的数据传输。</p><pre><code>1.    源站点向目的站点发布一个请求发送（RTS）帧。2.    目的站点用一个清除发送（CTS）帧响应。3.    收到CTS后，源站点发送数据帧。4.    目的站点以一个确认（ACK）帧响应。</code></pre><h3 id="5-IEEE802-11MAC层的服务包括哪些？"><a href="#5-IEEE802-11MAC层的服务包括哪些？" class="headerlink" title="5.IEEE802.11MAC层的服务包括哪些？"></a>5.IEEE802.11MAC层的服务包括哪些？</h3><ol><li>可靠的数据传送：IEEE802.11包括帧交换协议。四帧交换的出现保障了可靠的数据传输。</li><li>接入控制：IEEE802.11的MAC层分为两部分：分布接入协议和集中接入协议。MAC层的较低子层是分布协调功能（DCF）。DCF使用一个竞争算法为所有通信提供接入。普通的非同步算法直接使用DCF。点协调功能（PCF）是一个集中的MAC算法，被用于提供自由竞争服务。PCF建立于DCF之上，并利用DCF的特征保证用户的接入。</li><li>安全：IEEE802.11li着重在三个主要的安全性领域：认证、密钥管理和数据传递的保密性。WiFi联盟发布了WiFi保护接入，并将它作为一个WiFi标准。</li></ol><h3 id="6-IEEE802-11标准定义了几种帧间隔？分别有什么作用？"><a href="#6-IEEE802-11标准定义了几种帧间隔？分别有什么作用？" class="headerlink" title="6.IEEE802.11标准定义了几种帧间隔？分别有什么作用？"></a>6.IEEE802.11标准定义了几种帧间隔？分别有什么作用？</h3><p>​    帧间间隔：相当于优先级模式的时延，实现IEEE802.11MAC层的控制接入，灵活使用DCF，PCF。</p><ol><li>SIFS：短帧间间隔，用于所有的立即响应动作中。</li><li>PIFS：一个中间长度的帧间间隔，在发布轮询时，被中央控制器用于PCF模式。</li><li>DIFS：最长的IFS，作为一个最小的实验，用于非同步帧的接入竞争。</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="一、WPAN最初时，最主要的三个技术标准是什么？"><a href="#一、WPAN最初时，最主要的三个技术标准是什么？" class="headerlink" title="一、WPAN最初时，最主要的三个技术标准是什么？"></a>一、WPAN最初时，最主要的三个技术标准是什么？</h3><ol><li>蓝牙：<ul><li>支持点对点、点对多点的语音和数据业务和短距离无线通信技术。</li><li>蓝牙最基本的结构是微微网，由主设备单元和从设备单元组成。</li><li>主设备提供时钟同步信号和跳频序列，在一个微微网中，所有设备均采用同一跳频序列。</li><li>在一个微微网中，处于活跃状态的从设备最多有7个，多个微微网之间互联成散布式网络。</li></ul></li><li>IrDA：<ul><li>采用红外线作为通信媒介。</li><li>支持各种速率的点对点语音和数据业务。</li><li>主要应用于嵌入式应用和系统中。</li></ul></li><li>Home RF：<ul><li>是在家庭区域内，PC和用户电子设备之间实现无线数字通信的开放式工业标准。</li><li>工作在2.4GHz频段。</li><li>支持语音和数据。</li><li>语音采用DECT标准，数字通信采用TCP/IP。</li><li>采用跳频方式，每秒跳频50次，最大功率100mW。</li><li>有效范围50m，传输速率1Mb/s或2Mb/s。</li><li>分别采用2FSK或4FSK调制。</li></ul></li></ol><h3 id="二、简述蓝牙的一些基本特点。"><a href="#二、简述蓝牙的一些基本特点。" class="headerlink" title="二、简述蓝牙的一些基本特点。"></a>二、简述蓝牙的一些基本特点。</h3><ol><li>蓝牙是IEEE802.15.1标准的基础，由蓝牙特殊集团负责。</li><li>蓝牙的基本结构是微微网，由一个主设备单元和最多7个处于活跃状态的从设备单元组成，多个微微网之间互联成散布式网络。</li><li>蓝牙标准文档分为核心规范和概要规范。</li><li>核心规范：描述了无线电接口到链路控制的不同层次的蓝牙体系结构的细节。</li><li>概要规范：考虑使用蓝牙支持不同的应用，讨论在核心规范中定义的技术，以实现特定的应用模型。</li><li>概要规范分为：电缆替代和无线音频。</li><li>蓝牙的协议体系结构：分层体系结构：由核心协议、电缆替代协议、电话控制协议和接纳协议组成。其中最重要的是核心协议。</li><li>核心协议分为五层栈：无线电、基带、链路控制协议、逻辑链路控制和自适应协议、服务发现协议。</li><li>蓝牙的应用：数据和语音接入点、电缆替代、自组网络。</li></ol><h3 id="三、简述ZigBee的一些基本特点。"><a href="#三、简述ZigBee的一些基本特点。" class="headerlink" title="三、简述ZigBee的一些基本特点。"></a>三、简述ZigBee的一些基本特点。</h3><ol><li>基于IEEE802.15.4，是一种低成本，低功耗，低距离的无线网络技术。</li><li>特点：极低的系统功耗、较低的系统成本、安全的数据传输、灵活的工作频段、灵活的网络结构、超大的网络容量。</li><li>ZigBee标准体系：基于IP技术的协议栈和应用子集。</li><li>ZigBee协议栈：没有定义网络层和MAC层，而是直接采用IEEE802.15.4的定义，ZigBee联盟只对网络层，应用层和安全部分进行定义。</li><li>ZigBee的网络结构：主从设备的星形、树形和对等拓扑。<ul><li>星形：通信方式：节点——协调器——节点</li><li>树形：通信方式：终端节点——路由节点——协调节点——终端节点</li></ul></li><li>ZigBee的应用：数字家庭、工业、医疗、智能交通等都有应用。</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="简述WIMAX的技术特点。"><a href="#简述WIMAX的技术特点。" class="headerlink" title="简述WIMAX的技术特点。"></a>简述WIMAX的技术特点。</h3><ol><li>为促进标准的完善和市场推广，世界知名通信企业联合发起了全球微波接入互操作性论坛，在全球范围内推广IEEE802.16协议。</li><li>WIMAX的主要职能是根据IEEE802.16和ETST HiperMAN标准形成一个可互操作的全球统一标准，保证设备离开开发商的系统构件之间具有认证的互操作性。</li><li>特点：传输距离远、传输速率高、容量高、灵活的信道宽度、QoS性能、保密性。</li><li>IEEE802.16称为IEEE WMAN空中接口标准。</li><li>IEEE802.16系列标准协议栈按照两层体系结构组织，主要针对网络的低层，即MAC层和物理层。</li><li>物理层负责对MAC层的协议数据单元进行汇聚、编码、调制，最后形成无线帧送入物理信道中传送。</li><li>MAC层进行信道访问、区分服务、分配带宽、鉴权加密。</li><li>IEEE802.16系统的框架：用户设备——用户站——基站——核心网</li><li>IEEE802.16定义了两种网络结构：点到多点网络和Mesh网络。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;h3 id=&quot;1-无线网络按覆盖范围分为几类？从应用角度看，无线网络分为几类？&quot;&gt;&lt;a href=&quot;#1-无线网络按覆盖范围分为几类？从</summary>
      
    
    
    
    <category term="大三上" scheme="https://www.oliverbryant.cn/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A/"/>
    
    
    <category term="网络" scheme="https://www.oliverbryant.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>

---
title: Data_Structure
categories:
  - 考研
tags:
  - 专业课
mathjax: true
abbrlink: 46627
date: 2021-04-24 09:38:39
updated: 2021-04-24 09:38:39
permalink:
---

# 第一章：绪论

## 一、数据结构的基本概念

### 一、基本概念和术语

1. 数据：
    - 数据是<font color="red">信息的载体</font>
    - 是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。
    - 数据是计算机程序加工的原料。
2. 数据元素：
    - 数据元素是<font color="red">数据的基本单位</font>，通常作为一个整体进行考虑和处理。
    - 一个数据元素可有若干数据项组成，数据项是<font color="red">构成数据元素的不可分割的最小单位</font>。
3. 数据对象：
    - 数据对象是<font color="red">具有相同性质的数据元素的集合</font>，是数据的一个子集。
4. 数据类型：
    - 数据类型是<font color="red">一个值的集合和定义在此集合上的一组操作的总称</font>。
    - 分类：
        - 原子类型：其值不可再分的数据类型
        - 结构类型：其值可以再分解为若干成分（分量）的数据类型
        - 抽象数据类型：抽象数据组织及与之相关的操作
5. 数据结构：
    - 数据结构是<font color="red">相互之间存在一种或多种特定关系的数据元素的集合</font>
    - 结构：数据元素相互之间的关系
    - 三要素：
        - 逻辑结构：算法的设计
        - 存储结构：算法的实现
        - 数据的运算

### 二、数据结构三要素

1. 数据的逻辑结构：

    - 定义：逻辑结构是指<font color="red">数据元素之间的逻辑关系，即从逻辑关系上描述数据</font>。它与数据的存储<font color="red">无关</font>，是独立于计算机的。
    - 分类：
        - 线性结构：只存在一对一的关系
        - 非线性结构：存在一对多、多对多的关系

    ![image-20210424100359950](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/image-20210424100359950.png)

2. 数据的存储结构：

    - 定义：存储结构是指<font color="red">数据结构在计算机中的表示（映像）</font>，也称物理结构。它是用计算机语言实现的逻辑结构，它依赖于计算机语言。
    - 分类：
        - 顺序存储：
            - 定义：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单位的邻接来体现。
            - 优点：实现随机存储，每个元素占用最少的存储空间。
            - 缺点：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。
        - 链式存储：
            - 定义：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
            - 优点：不会出现碎片现象，能充分利用所有存储单元。
            - 缺点：每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。
        - 索引存储：
            - 定义：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的形式一般是<font color="red">（关键字，地址）</font>
            - 优点：检索速度快
            - 缺点：附加的索引表额外占用存储空间；增加和删除数据时也需要修改索引表，因而会花费较多时间。
        - 散列存储：
            - 定义：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储。
            - 优点：检索、增加和删除结点的操作都很快
            - 缺点：若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

3. 数据的运算：

    - 运算的定义：针对逻辑结构，指出运算的功能。
    - 运算的实现：针对存储结构，指出运算的具体操作步骤。

## 二、算法和算法评价

### 一、算法的基本概念

1. 算法的定义：算法是<font color="red">对特定问题求解步骤的一种描述</font>，它是指令的有限序列，其中的每条指令表示<font color="red">一个或多个操作</font>。
2. 算法的特性：
    - 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
    - 确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得到相同的输出。
    - 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
    - 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
    - 输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。
3. 算法的目标：
    - 正确性：算法应能够正确地解决求解问题。
    - 可读性：算法应具有良好的可读性，以帮助人们理解。
    - 健壮性：输入非法数据时，算法能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果。
    - 效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。

### 二、算法效率的度量

1. 时间复杂度：

    - 频度：一个语句的频度是指该语句在算法中被重复执行的次数。

    - 定义：算法中所有语句的频度之和记作T(n)，它是算法问题规模n的函数，时间复杂度就是分析T(n)的数量级。

        - 最坏时间复杂度：在最坏情况下，算法的时间复杂度。
        - 平均时间复杂度：所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
        - 最好时间复杂度：在最好情况下，算法的时间复杂度。

    - 公式：T(n)=O(f(n))

    - 依赖：

        - 问题的规模n
        - 待输入数据的性质

    - 规则：

        - 加法规则：
            $$
            T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))
            $$

        - 乘法规则：
            $$
            T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O((f(n)\times g(n))
            $$

    - 常见的渐进时间复杂度：
        $$
        O(1)<O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
        $$

2. 空间复杂度：

    - 定义：该算法所消耗的存储空间，它是问题规模n的函数。
    - 公式：S(n)=O(g(n))
    - 原地工作：指算法所需的辅助空间为常量，即O(1)。

# 第二章：线性表

## 一、线性表的定义和基本操作

### 一、线性表的定义

1. 定义：线性表是<font color="red">具有相同数据类型的n(n>=0)个数据元素的有限序列</font>，其中n为表长，当n=0时线性表是一个空表。即L=(a1,a2,…,ai,ai+1,…,an)。a1是唯一的”第一个“数据元素，又称表头元素；an是唯一的”最后一个“数据元素，又称表尾元素。
2. 逻辑特性：除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且只有一个直接后继。
3. 特点：
    - 表中元素的个数有限。
    - 表中元素具有逻辑上的顺序性，表中元素有其先后次序。
    - 表中元素都是数据元素，每个元素都是单个元素。
    - 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
    - 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。

<u>注：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。</u>

### 二、线性表的基本操作

1. InitList(&L)：初始化表，构建一个空的线性表。
2. Length(L)：求表长。返回线性表L的长度。
3. LocateElem(L,e)：按值查找操作。
4. GetElem(L,i)：按位查找操作。
5. ListInsert(&L,i,e)：插入操作。
6. ListDelete(&L,i,&e)：删除操作。
7. PrintList(L)：输出操作。
8. Empty(L)：判空操作。
9. DestroyList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。

## 二、线性表的顺序表示

### 一、顺序表的定义

1. 定义：它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

2. 第一个元素存储在线性表中的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素ai在线性表中的位序。

3. 特点：

    - 表中元素的逻辑顺序与其物理顺序相同。
    - 随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。
    - 存储密度高，每个结点只存储数据元素。
    - 逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。

4. 代码实现：

    - 静态分配：数组的大小和空间事先固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。

    ```c
    #define MaxSize 50               //定义线性表最大长度
    typedef struct{
        ElemType data[MaxSize];      //顺序表的元素
        int length;                  //顺序表的当前长度
    }SqList;                         //顺序表的类型定义
    ```

    - 动态分配：

    ```c++
    #define InitSize 100                                           //表长度的初始定义
    typedef struct{
        ElemType *data;                                            //指示动态分配数组的指针
        int MaxSize,length;                                        //数组的最大容量和当前个数
    }SqList;                                                       //动态分配数组顺序表的类型定义
    L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);         //C的初始动态分配语句
    ```

### 二、顺序表上基本操作的实现

1. 插入操作：

    ```c
    int ListInsert(SqList* L, int i, ElemType e)
    {
        if (i < 1 || i > L->length + 1) {
            printf("插入位置错误，请检查后重试！！！");
            return 0;
        }
        if (L->length + 1 > L->Maxsize) {
            printf("空间不足，请扩容！！！");
            return 0;
        }
        for (int j = L->length; j >= i; j--) {
            L->data[j + 1] = L->data[j];
        }
        L->data[i] = e;
        L->length += 1;
        return 1;
    }
    ```

    - 时间复杂度：O(n)

2. 删除操作：

    ```c
    int ListDelete(SqList* L, int i, ElemType* e)
    {
        if (i < 1 || i > L->length) {
            return -1;
        }
        *e = L->data[i - 1];
        for (int j = 1; j < L->length; j++) {
            L->data[j - 1] = L->data[j];
        }
        L->length--;
        return 1;
    }
    ```

    - 时间复杂度：O(n)

3. 按值查找：

    ```c
    int LocateElem(SqList L, ElemType e)
    {
        for (int i = 0; i < L.length; i++) {
            if (L.data[i] == e) {
                return i + 1;
            }
        }
        return -1;
    }
    ```

    - 时间复杂度：O(n)

## 三、线性表的链式表示

### 一、单链表的定义

1. 单链表：链表的链式存储，它是指<font color="red">通过一组任意的存储单元来存储线性表中的数据元素</font>。

2. 结构：

    - data：数据域，存放自身元素
    - next：指针域，存放其后继结点的地址

3. 优点：可以解决顺序表需要大量连续存储单元的缺点。

4. 缺点：

    - 附加指针域，浪费存储空间
    - 非随机存储的存储结构，不能直接找到表中某个特定的结点，必须从表头遍历，依次查找。

5. 头指针：用来标识一个单链表。当头指针为NULL时为空表。

6. 头结点：

    - 定义：在单链表第一个结点前附加的一个结点，可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。
    - 与头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。
    - 优点：
        - 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理。
        - 无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。

7. 代码实现：

    ```c
    typedef struct LNode{          //定义单链表结点类型
    	ElemType data;             //数据域
    	struct LNode *next;        //指针域
    }LNode, *LinkList;
    ```

### 二、单链表上的基本操作的实现

1. 采用头插法建立单链表：

    - 思想：从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。

    - 时间复杂度：每次插入O(1)，若单链表长为n，则总时间复杂度为O(n)。

    - 代码实现：

        ```c
        LinkList List_HeadInsert(LinkList L){           //逆向建立单链表
            LNode *s;
            ElemType x;
            L=(LinkList)malloc(sizeof(LNode));          //创建头结点
            L->next = NULL;                             //初始为空链表
            scanf("%d",&x);                             //输入结点的值
            while (x!=9999)                             //输入9999结束
            {
                s=(LNode*)malloc(sizeof(LNode));        //创建新结点
                s->data=x;
                s->next=L->next;                        //将新结点插入表中，L为头指针
                L->next=s;
                scanf("%d",&x);
            }
            return L; 
        }
        ```

2. 采用尾插法建立单链表：

    - 思想：将新结点插入到当前链表的表尾，为此必须设置一个尾指针r，使其始终指向表尾。

    - 时间复杂度：每次插入O(1)，若单链表长为n，则总时间复杂度为O(n)。

    - 代码实现：

        ```c
        LinkList List_TailInsert(LinkList L){             //正向建立单链表
            ElemType x;
            L=(LinkList)malloc(sizeof(LNode));
            LNode *s,*r=L;                                //r为表尾指针
            scanf("%d",&x);
            while(x!=9999){
                s=(LNode*)malloc(sizeof(LNode));
                s->data=x;
                r->next=s;
                r=s;                                      //r指向新的表尾结点
                scanf("%d",&x);
            }
            r->next=NULL;                                 //表尾置空
            return L;
        }
        ```

3. 按序号查找结点值：

    - 思想：在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。

    - 时间复杂度：O(n)

    - 代码实现：

        ```c
        LNode* GetElem(LinkList L, int i)
        {
            int j = 1;                        //计数，初始为1
            LNode* p = L->next;               //头结点指针域给p
            if (i == 0) {
                return L;                     //若i等于0，则返回头结点
            }
            if (i < 1) {
                return NULL;                  //若i无效，则返回NULL
            }
            while (p && j != i) {             //从第1个结点开始找，查找第i个结点
                p = p->next;
                j++;
            }
            return p;                         //返回第i个结点的指针，若i大于表长，则返回NULL
        }
        ```

4. 按值查找结点：

    - 思想：从单链表的第一个结点出发，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点指针；若整个单链表中没有这样的结点，则返回NULL。

    - 时间复杂度：O(n)

    - 代码实现：

        ```c
        LNode* LocateElem(LinkList L, ElemType e)
        {
            LNode* p = L->next;
            while (p != NULL && p->data != e) {        //从第一个结点开始查找数据域为e的结点
                p = p->next;
            }
            return p;                                  //找到后返回该结点指针，否则返回NULL`
        }
        ```

5. 插入结点操作：

    - 思想：首先调用按序查找找到前驱结点，令新结点的指针域指向前驱结点的指针域，再令前驱结点的指针域指向新结点。

    - 时间复杂度：查找元素为O(n)，插入结点为O(1).

    - 代码实现：

        ```c
        LinkList BackInsert(LinkList L, LNode* p, int i)
        {
            LNode* q;
            q = GetElem(L, i - 1);           //查找插入位置的前驱结点
            p->next = q->next;
            q->next = p;
            return L;
        }
        ```

6. 删除结点操作：

    - 思想：先检查删除位置的合法性，后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除。

    - 时间复杂度：查找元素为O(n)，插入结点为O(1).

    - 代码实现：

        ```c
        p=GetElem(L,i-1);          //查找删除位置的前驱结点
        q=p->next;                 //令q指向被删除结点
        p->next=q->next;           //将*q结点从链中“断开”
        free(q);                   //释放结点的存储空间
        ```

### 三、双链表

1. 定义：结点中有两个指针prior和next，分别指向其前驱结点和后继结点。

2. 代码实现：

    ```c
    typedef struct DNode{                //定义双链表结点类型
    	ElemType data;                   //数据域
    	struct DNode *prior,*next;       //前驱和后继指针
    }DNode, *DLinkList;
    ```

3. 优点：插入和删除操作的时间复杂度均为O(1).

    - 插入：在p之前插入结点*s

        ```c
        s->next=p->next;
        p->next->prior=s;
        s->prior=p;
        p->next=s;
        ```

    - 删除：删除结点*p的后继结点 *q

        ```c
        p->next=q->next;
        q->next->prior=p;
        free(q);
        ```

### 四、循环链表

1. 循环单链表：
    - 定义：表中最后一个结点的指针域不是NULL，而是指向头结点，从而整个链表形成一个环。
    - 特点：
        - 在循环单链表中没有指针域为NULL的结点，因此判空条件是头结点的指针是否等于头指针。
        - 在循环链表中可以从任意结点开始遍历整个链表。
        - 循环单链表一般不设头指针而只设尾指针，从而使效率更高。
            - 对单链表的操作很多是从表头表尾进行。
            - 若设头指针，对表尾的操作需要O(n)来遍历，而设尾指针r，r->next即为头指针，因此对表头表尾操作都是O(1).
2. 循环双链表：
    - 定义：在循环单链表的基础上增加prior指针。头结点的prior指向尾结点。
    - 特点：在循环双链表L中，某结点*p为尾结点时，p->next==L；当表为空表时，其头结点的prior和next都等于L。

### 五、静态链表

1. 定义：静态链表借助数组来描述线性表的链式结构，结点中也有数据域data和指针域next，在指针域中存放的是下一个结点的相对地址（数组下标），又称游标。

2. 特点：

    - 和顺序表一样，静态链表也要预先分配一块连续的空间。
    - 静态链表以next==-1作为结束的标志。

3. 代码实现：

    ```c
    #define MaxSize 50         //静态链表的最大长度
    typedef struct{            //静态链表结构类型的定义
        ElemType data;         //存储数据元素
        int next;              //下一个元素的数组下标
    } SLinkList[MaxSize];
    ```

### 六、顺序表和链表的比较

1. 比较

|                    |                   顺序表                   |                             链表                             |
| :----------------: | :----------------------------------------: | :----------------------------------------------------------: |
|  存取（读写）方式  |             顺序存取、随机存取             |                        从表头顺序存取                        |
| 逻辑结构与物理结构 | 逻辑上相邻的元素，对应的物理存储结构也相邻 |           逻辑上相邻的元素，物理存储位置不一定相邻           |
|      按值查找      |         无序时O(n),有序时O(log2n)          |                             O(n)                             |
|     按序号查找     |                    O(1)                    |                             O(n)                             |
|     插入和删除     |                    O(n)                    |                             O(1)                             |
|      空间分配      |    开始前分配，存满不能扩充，存储密度大    | 空间在需要时申请分配，且只要内存有空间就可以分配，存储密度不大 |

2. 如何选择存储结构？
    - 基于存储的考虑：难以估计线性表长度或存储规模时，不宜采用顺序表。
    - 基于运算的考虑：
        - 若经常做的运算是按序号访问元素，则选择顺序表
        - 若操作主要是删除或者插入，则选择链表
    - 基于环境的考虑：
        - 顺序表容易实现
        - 链表的操作基于指针

# 第三章：栈和队列

## 一、栈

### 一、栈的基本概念

1. 栈的定义：

    - 栈：只允许在一端进行插入或删除操作的线性表。
    - 栈顶：线性表允许进行插入删除的那一端。
    - 栈底：固定的，不允许进行插入和删除的另一端。
    - 空栈：不含任何元素的空表。

2. 栈的特点：后进先出（LIFO）

3. 栈的数学性质：卡特兰数，n个不同元素进栈，出栈元素不同排列的个数。
    $$
    \frac1{n+1}C_{2n}^n
    $$
    
4. 栈的基本操作：可以直接使用这些基本操作函数。

    - InitStack(&S)：初始化一个空栈S
    - StackEmpty(S)：判断一个栈是否为空
    - Push(&S,x)：进栈，若栈S未满，则将x加入使之成为栈顶
    - Pop(&S,&x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回
    - GetTop(S,&x)：读栈顶元素，若栈S非空，则用x返回栈顶元素
    - DestroyStack(&S)：销毁栈，并释放栈S占用的存储空间

### 二、栈的顺序存储结构

1. 定义：采用顺序存储结构的栈。它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针(top)指示当前栈顶元素的位置。

2. 代码实现：

    ```c
    #define MaxSize 50                     //定义栈中元素的最大个数
    typedef struct {
        ElemType data[MaxSize];            //存放栈中元素
        int top;                           //栈顶指针
    } SqStack;
    ```

    - 栈顶指针：S.top，初始设置S.top=-1；
    - 栈顶元素：S.data[S.top]
    - 栈空条件：S.top==-1
    - 栈满条件：S.top==MaxSize-1
    - 栈长：S.top+1

3. 顺序栈的基本运算：

    - 初始化：

        ```c
        void InitStack(SqStack* S)
        {
        S->top = -1;                  //初始化栈顶指针
        }
        ```
        
    - 判栈空：
    
        ```c
        int StackEmpty(SqStack S)
        {
        if (S.top == -1) {            //栈空
                return 1;
            }
            return 0;                     //非空
        }
        ```
        
        
        
    - 进栈：
    
        ```c
        int Push(SqStack *S,ElemType e){      
            if(S->top==MaxSize-1){          //栈满，报错
            return 0;
            }
            S->data[++S->top]=e;            //指针先+1，再入栈
            return 1;
        }
        ```
        
    - 出栈：
    
        ```c
        int Pop(SqStack* S, ElemType* e)
        {
        if (S->top == -1) {             //栈空，报错
                return 0;
            }
            *e = S->data[S->top--];         //先出栈，指针再-1
            return 1;
        }
        ```
        
    - 读栈顶元素：
    
        ```c
        int GetTop(SqStack S, ElemType* e)
        {
        if (S.top == -1)               //栈空，报错
                return 0;
            *e = S.data[S.top];            //e记录栈顶元素
            return 1;
        }
        ```
    
4. 共享栈：

    - 定义：让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。
    - 原理：两个栈的栈顶指针都指向栈顶元素，top0==-1是0号栈为空，top1==MaxSize时1号栈为空；仅当(top1-top0==1)时，则为栈满。
    - 优点：更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被栈满时才发生上溢。

### 三、栈的链式存储结构

1. 定义：采用链式存储的称为链栈。通常采用单链表实现。

2. 优点：便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。

3. 代码实现：

    ```c
    typedef struct LinkNode{
        ElemType data;                 //数据域
        struct LinkNode *next;         //指针域
    } *LiStack;                        //栈类型定义
    ```

## 二、队列

### 一、队列的基本概念

1. 队列的定义：
    - 定义：一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。
    - 入队：向队列中插入元素成为入队，也叫仅队
    - 出队：删除元素，也叫离队
    - 队头（Front）：允许删除的一端，又称队首
    - 队尾（Rear）：允许插入的一端
    - 空队列：不含任何元素的空表
2. 队列的特点：先进先出（FIFO）
3. 队列常见的基本操作：
    - InitQueue(&Q)：初始化队列，构造一个空队列Q
    - QueueEmpty(Q)：判队列空
    - EnQueue(&Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾
    - DeQueue(&Q,&x)：出队，若队列非空，删除队头元素，并用x返回
    - GetHead(Q,&x)：读队头元素，若队列Q非空，则将队头元素赋值给x

### 二、队列的顺序存储结构

1. 队列的顺序存储：

    - 定义：分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置。
    - 代码实现：

    ```c
    #define MaxSize 50                   //定义队列中元素的最大个数
    typedef struct{           
        ElemType data[MaxSize];          //存放队列元素
        int front,rear;                  //队头指针和队尾指针
    } SqQueue;
    ```

    - 队空条件：Q.front==Q.rear==0
    - 缺点：栈满难以判断，容易出现假溢出。

2. 循环队列：

    - 定义：把存储队列元素的表从逻辑上视为一个环。当队首指针Q.front==MaxSize-1时，再进一个位置就自动到0.
    - 队空条件：Q.front==Q.rear==0
    - 队首指针进1：Q.front=(Q.front+1)%MaxSize
    - 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize
    - 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize
    - 判断队满：
        - 牺牲一个单元来区分队满和队空，入队时少用一个队列单元。此时队头指针在队尾指针的下一位置为队满的标志。
        - 类型中增设表示元素个数的数据成员。
        - 类型中增设tag数据成员，以区分队满还是队空，此时条件都是Q.front==Q.rear。通过tag判断。

3. 循环队列的操作：

    - 初始化：

        ```c
        void InitQueue(SqQueue *Q){
            Q->rear=Q->front=0;                 //初始化队首，队尾指针
        }
        ```

    - 判队空：

        ```c
        int isEmpty(SqQueue Q){
            if(Q.rear==Q.front)                 //队空条件
                return 1;
            return 0;
        }
        ```

    - 入队：

        ```c
        int EnQueue(SqQueue *Q,ElemType x){
            if((Q->rear+1)%MaxSize==Q->front)          //队满，报错
                return 0;
            Q->data[Q->rear]=x;
            Q->rear=(Q->rear+1)%MaxSize;               //队尾指针+1取模
            return 1;
        }
        ```

    - 出队：

        ```c
        int DeQueue(SqQueue *Q,ElemType *x){
            if(Q->rear==Q->front)                      //队空，报错
                return 0;
            *x=Q->data[Q->front];
            Q->front=(Q->front+1)%MaxSize;             //队头指针+1取模
            return 1;
        }
        ```

### 三、队列的链式存储结构

1. 队列的链式存储：

    - 定义：一个同时带有队头指针和队尾指针的单链表，也称链队列。

    - 代码实现：

        ```c
        typedef struct{                         //链式队列结点
            ElemType data;
            struct LinkNode *next;
        }LinkNode;
        typedef struct{                         //链式队列
            LinkNode *front,*rear;              //队列的队头和队尾指针
        }LinkQueue;
        ```

    - 队空条件：Q.front==NULL且Q.rear==NULL

    - 一般采用<font color="red">带有头结点</font>的单链表。

2. 链式队列的基本操作：

    - 初始化：

        ```c
        void InitQueue(LinkQueue *Q){
            Q->front=Q->rear=(LinkNode*)malloc(sizeof(LinkNode));     //建立头结点
            Q->front->next=NULL;                                      //初始为空
        }
        ```

    - 判队空：

        ```c
        int isEmpty(LinkQueue Q){
            if(Q.front==Q.rear){
                return 1;
            }
            return 0;
        }
        ```

    - 入队：

        ```c
        void EnQueue(LinkQueue *Q,ElemType x){
            LinkNode *s=(LinkNode*)malloc(sizeof(LinkNode));
            s->data=x;s->next=NULL;                                //创建新结点，插入到链尾
            Q->rear->next=s;
            Q->rear=s;
        }
        ```

    - 出队：

        ```c
        int DeQueue(LinkQueue *Q,ElemType *x){
            if(Q->front==Q->rear){
                return 0;
            }
            LinkNode *p=Q->front->next;
            *x=p->data;
            Q->front->next=p->next;
            if(Q->rear==p){
                Q->rear=Q->front;                 //若原队列中只有一个结点，删除后变空
            }
            free(p);
            return 1;
        }
        ```

### 四、双端队列

1. 定义：允许两端都可以进行入队和出队操作的队列。
2. 逻辑结构：线性结构
3. 进队：前端进的元素排列在队列中后端进的元素前面，后端进的元素排列在队列中前端进的元素的后面。
4. 出队：无论是前端还是后端出队，先出的元素排列在后出的元素的前面。
5. 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。
6. 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。

## 三、栈和队列的应用

### 一、栈在括号匹配中的应用

1. 算法思想：
    - 初始设置一个空栈，顺序读入括号
    - 若是右括号，则或者使置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序列不匹配，退出程序）
    - 若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性降了一级。
    - 算法结束时，栈为空，否则括号序列不匹配。

### 二、栈在表达式求值中的应用

1. 中缀表达式转化为后缀表达式的过程：

    - 运算符优先级表：

        | 操作符 |  #   |  (   | *,/  | +,-  |  )   |
        | :----: | :--: | :--: | :--: | :--: | :--: |
        |  isp   |  0   |  1   |  5   |  3   |  6   |
        |  icp   |  0   |  6   |  4   |  2   |  1   |

    - 操作方法：a+b-a*((c+d)/e-f)+g——>ab+acd+e/f- *-g+

    | 步骤 | 扫描项 | 项类型 |              动作              | 栈内内容 | 输出 |
    | :--: | :----: | :----: | :----------------------------: | :------: | :--: |
    |  0   |        |        |      ‘#’进栈，读下一符号       |    #     |      |
    |  1   |   a    | 操作数 |            直接输出            |    #     |  a   |
    |  2   |   +    | 操作符 |    isp('#')<icp('+')，进栈     |    #+    |      |
    |  3   |   b    | 操作数 |            直接输出            |    #+    |  b   |
    |  4   |   -    | 操作符 | isp('+')>icp('-')，退栈并输出  |    #     |  +   |
    |  5   |        |        |    isp('#')<icp('-')，进栈     |    #-    |      |
    |  6   |   a    | 操作数 |            直接输出            |    #-    |  a   |
    |  7   |   *    | 操作符 |    isp('-')<icp('*')，进栈     |   #-*    |      |
    |  8   |   (    | 操作符 |    isp('*')<icp('(')，进栈     |   #-*(   |      |
    |  9   |   (    | 操作符 |    isp('(')<icp('(')，进栈     |  #-*((   |      |
    |  10  |   c    | 操作数 |            直接输出            |  #-*((   |  c   |
    |  11  |   +    | 操作符 |    isp('(')<icp('+')，进栈     |  #-*((+  |      |
    |  12  |   d    | 操作数 |            直接输出            |  #-*((+  |  d   |
    |  13  |   )    | 操作符 | isp('+')>icp(')')，退栈并输出  |  #-*((   |  +   |
    |  14  |        |        |  isp('(')==icp(')')，直接退栈  |   #-*(   |      |
    |  15  |   /    | 操作符 |    isp('(')<icp('/')，进栈     |  #-*(/   |      |
    |  16  |   e    | 操作数 |            直接输出            |  #-*(/   |  e   |
    |  17  |   -    | 操作符 | isp('/')>icp('-')，退栈并输出  |   #-*(   |  /   |
    |  18  |        |        |    isp('(')<icp('-')，进栈     |  #-*(-   |      |
    |  19  |   f    | 操作数 |            直接输出            |  #-*(-   |  f   |
    |  20  |   )    | 操作符 | isp('-')>icp(')')，退栈并输出  |   #-*(   |  -   |
    |  21  |        |        |  isp('(')==icp(')')，直接退栈  |   #-*    |      |
    |  22  |   +    | 操作符 | isp('*')>icp('+')，退栈并输出  |    #-    |  *   |
    |  23  |        |        | isp('-')>icp('+')，退栈并输出  |    #     |  -   |
    |  24  |        |        |    isp('#')<icp('+')，进栈     |    #+    |      |
    |  25  |   g    | 操作数 |            直接输出            |    #+    |  g   |
    |  26  |   #    | 操作符 | isp('+')>icp('#')，退栈并输出  |    #     |  +   |
    |  27  |        |        | isp('#')==icp('#')，退栈，结束 |          |      |

    - 后缀表达式求值过程：abcd-*+ef/-

        |  步  | 扫描项 | 项类型 |               动作               | 栈中内容 |
        | :--: | :----: | :----: | :------------------------------: | :------: |
        |  1   |        |        |              置空栈              |    空    |
        |  2   |   a    | 操作数 |               进栈               |    a     |
        |  3   |   b    | 操作数 |               进栈               |   a,b    |
        |  4   |   c    | 操作数 |               进栈               |  a,b,c   |
        |  5   |   d    | 操作数 |               进栈               | a,b,c,d  |
        |  6   |   -    | 操作符 |   d,c退栈，计算c-d，结果R1进栈   |  a,b,R1  |
        |  7   |   *    | 操作符 |  R1,b退栈，计算b*R1，结果R2进栈  |   a,R2   |
        |  8   |   +    | 操作符 |  R2.a退栈，计算a+R2，结果R3进栈  |    R3    |
        |  9   |   e    | 操作数 |               进栈               |   R3,e   |
        |  10  |   f    | 操作数 |               进栈               |  R3,e,f  |
        |  11  |   /    | 操作符 |   f,e退栈，计算e/f，结果R4进栈   |  R3,R4   |
        |  12  |   -    | 操作符 | R4,R3退栈，计算R3-R4，结果R5进栈 |    R5    |

### 三、栈在递归中的应用

- 思想：通过栈来实现将递归算法转换为非递归算法，避免递归次数过多造成栈溢出。

### 四、队列在层次遍历中的应用

- 算法思想：

    1. 根结点入队

    2. 若队空，则所有结点遍历完成，结束遍历。否则重复3号操作。
    3. 队列中的第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回2号操作。

### 五、队列在计算机系统中的应用

1. 解决主机与外部设备之间速度不匹配的问题：
    - 设置一个缓冲区，该缓冲区就是一个队列
2. 解决由多用户引起的资源竞争问题：
    - 采用先来先服务（FCFS）策略，将它们按照时间先后排成一个队列。

## 四、特殊矩阵的压缩存储

### 一、数组的定义

1. 定义：数组是由n个<font color="red">相同类型</font>的<font color="red">数据元素</font>构成的<font color="red">有限序列</font>。每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。
2. 数组和线性表的关系：数组是线性表的推广。一维数组可以视为一个线性表；二位数组可视为其元素也是定长线性表的线性表。

### 二、数组的存储结构

1. 一维数组：A[0...n-1]
    $$
    LOC(a_i)=LOC(a_0)+i\times L\;(0\leq i<n)
    $$

2. 二维数组：

    - 按行优先方式：
        $$
        LOC(a_{i,j})=LOC(a_{0,0})+\lbrack i\times(h_2+1)+j\rbrack\times L
        $$

    - 按列优先方式：
        $$
        LOC(a_{i,j})=LOC(a_{0,0})+\lbrack j\times(h_1+1)+i\rbrack\times L
        $$

### 三、矩阵的压缩存储

1. 对称矩阵的压缩存储：

    - 策略：只存储主对角线和下三角区，因为aij==aji，所以可以很方便的将上三角区转化为下三角区。 

2. 三角矩阵：

    - 定义：下三角矩阵中，上三角区均为同一常量；上三角矩阵中，下三角区均为同一常量。
    - 策略：存储主对角线和元素不同的区域，在最后增加一个存储空间存储常量。访问同一常量区时，直接访问数组最后一个元素。

3. 三对角矩阵：

    - 将三对角矩阵A中三条对角线上的元素按行优先方式存放在一维数组中。

    - 已知aij，B中下标k=2i+j-3.

    - 已知下标k，
        $$
        \begin{array}{l}3(i-1)-1<k+1\leq3i-1\\i\geq(k+2)/3\\i=\left\lceil(k+2)/3\right\rceil\\j=k-2i+3\end{array}
        $$

4. 稀疏矩阵：

    - 定义：非零元素的个数远小于0元素的个数。
    - 存储方法：
        - 顺序存储（数组）：定义一个结构体，存放三元组<i,j,v>（i：行号；j：列号；v：值）
        - 十字链表法：每行指针指向当前行第一个元素，若还有继续往下指；每列同样。

# 第四章：串

## 一、串的定义和实现

### 一、串的定义

1. 定义：字符串简称串，是由<font color="red">零个或多个字符组成的有限序列</font>。

2. 表示：
    $$
    S='a_1a_2a_3...a_n'\;\left(n\geq0\right)
    $$
    其中S是串名，单引号内是串的值，可以是字母、数字或其他字符。n为串的长度，n=0时为空串。

3. 子串：串中任意多个连续的字符组成的子序列称为该串的字串。

4. 主串：包含子串的串称为主串。

5. 位置：某个字符在串中的序号称为该字符在串中的位置。

6. 空格串：由一个或多个空格组成的串，长度为空格的个数，不是空串。

### 二、串的存储结构

1. 定长顺序存储表示：

    - 思想：类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。（定长数组）

    - 代码实现：

        ```c
        #define MAXLEN 255               //预定义最大串长为255
        typedef struct{
            char ch[MAXLEN];             //每个分量存储一个字符
            int length;                  //串的实际长度
        }SString;
        ```

    - 注：

        - 截断：超过预定义长度的串值会被舍去。

    - 串长的两种表达方式：

        - 定义一个length变量来存放串的长度。
        - 在最后加上一个不计入串长的结束标记字符"\0"，此时串长为隐含值。

2. 堆分配存储表示：

    - 思想：仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储结构在程序执行过程中动态分配。

    - 代码实现：

        ```c
        typedef struct{
            char *ch;              //按串长分配存储区，ch指向串的基地址
            int length;            //串的长度
        }HString;
        ```

    - 实现方式：利用malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来表示；若分配失败则返回NULL。已分配的空间可用free()释放掉。

3. 块链存储表示：

    - 思想：类似线性表的链式存储结构，也可采用链表方式存储串值。
    - 实现方式：每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。

### 三、串的基本操作

- StrAssign(&T,chars)：赋值操作。把串T赋值为chars。
- StrCopy(&T,S)：复制操作。由串S得到串T。
- StrEmpty(S)：判空操作。若S为空串，返回1，否则返回0。
- StrCompare(S,T)：比较操作。若S>T，则返回值>0；若S=T，则返回值=0；若S<T，则返回值<0。
- StrLength(S)：求串长。返回串的元素个数。
- SubString(&Sub,S,pos,len)：求字串。用Sub返回串S中第pos个字符起长度为len的字串。
- Concat(&T,S1,S2)：串联接。用T返回由S1，S2联接而成的新串。
- Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.
- ClearString(&S)：清空操作。将S变为空串。
- DestroyString(&S)：销毁串。将串S销毁。

## 二、串的模式匹配

### 一、简单的模式匹配算法

1. 模式匹配的定义：字串的定位操作通常称为串的模式匹配，它求的是字串在主串中的位置。

2. 简单的模式匹配算法（暴力匹配）：

    ```c
    int Index(SString S, SString T)
    {
        int i = 1, j = 1;
        while (i <= S.length && j <= T.length) {
            if (S.ch[i] == T.ch[j]) {
                i++; j++;                               //继续比较后续字符
            } else {                                    //指针后退继续比较
                i = i - j + 2;
                j = 1;
            }
        }
        if (j > T.length) {
            return i - T.length;
        } else {
            return 0;
        }
    }
    ```

3. 思想：从主串S的第一个字符开始，与模式串T的第一个字符比较，若相等，则继续比较；否则从主串的下一个字符开始重新和模式串进行比较。直到T中的每个字符依次与主串S中的一个连续字符串相匹配，则匹配成功，返回T中第一个字符在S中的位置；否则匹配失败，返回0.

4. 时间复杂度：O(nm)

### 二、改进的模式匹配算法——KMP算法

1. 前缀：除最后一个字符外，字符串的所有头部子串。

2. 后缀：除第一个字符外，字符串的所有尾部子串。

3. next数组的含义：在子串的第j个字符与主串发生失配时，则调到字串的next[j]位置重新与主串当前位置进行比较。

4. next数组的公式：
    $$
    next\left[j\right]=\left\{\begin{array}{c}0\;\;\;\;\;\;\;\;\;\;j=1\\max\left\{k\vert1<k<j\;\&\&\;'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'\right\}\;\;\;\;\;\;\;\mathrm{当集合不为空时}\\1\;\;\;\;\;\;\;\;\;\mathrm{其他情况}\end{array}\right.
    $$
    简单来说，第一个字符的next=0，其余的next值为它前面字符串的前缀和后缀的最大匹配长度+1.

5. 求next数组的代码实现：

    ```c
    void get_next(SString T, int next[])
    {
        int i = 1, j = 0;
        next[1] = 0;
        while (i < T.length) {
            if (j == 0 || T.ch[i] == T.ch[j]) {
                ++i, ++j;
                next[i] = j;
            } else {
                j = next[j];
            }
        }
    }
    ```

6. KMP算法的代码实现：

    ```c
    int Index_KMP(SString S, SString T)
    {
        int i = 1, j = 1;
        int next[T.length + 1];
        get_next(T, next);                                     //求next数组
        while (i <= S.length && j <= T.length) {
            if (j == 0 || S.ch[i] == T.ch[j]) {                //继续比较后继字符
                i++, j++;
            } else {
                j = next[j];                                   //模式串向右移动
            }
        }
        if (j > T.length) {
            return i - T.length;                               //匹配成功
        } else
            return 0;
    }
    ```

    ![next](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/next.gif)

7. KMP的时间复杂度：O(m+n)

    - O(m)是求KMP的时间复杂度。
    - O(n)是进行模式匹配的时间复杂度。

### 三、KMP算法的进一步优化——nextval

1. 求nextval数组的代码实现：

    ```c
    void get_nextval(SString T, int nextval[])
    {
        int i = 1, j = 0;
        nextval[1] = 0;
        while (i < T.length) {
            if (j == 0 || T.ch[i] == T.ch[j]) {
                j++, i++;
                if (T.ch[i] != T.ch[j]) {
                    nextval[i] = j;
                } else
                    nextval[i] = nextval[j];
            } else
                j = nextval[j];
        }
    }
    ```

    简单来说，就是从第二个字符开始，如果该字符与next[j]代表的字符相等，则他的nextval等于next[j]代表的字符的nextval，否则它的nextval等于它的next值。

# 第五章：树与二叉树

## 一、树的基本概念

### 一、树的定义

1. 定义：树是n(n>=0)个结点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：
    - 有且仅有一个特定的称为根的结点。
    - 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,...,Tm，其中每个集合本身又是一棵树，并且称为根的子树。
2. 特点：
    - 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
    - 树中所有结点可以有零个或多个后继。
3. 结构：树是一种递归的数据结构。既是一种逻辑结构，同时也是一种分层结构。

### 二、基本术语

![](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/image-20210430090338702.png)

1. 对于K结点：根A到结点K的唯一路径上的任意结点，称为结点K的<font color="red">祖先</font>。如B是K的祖先，K是B的<font color="red">子孙</font>。E是K的<font color="red">双亲</font>，K是E的<font color="red">孩子</font>。K和L互为兄弟。
2. 度：
    - 结点的度：树中一个结点的孩子个数称为该结点的度。
    - 树的度：树中结点的最大度数。
3. 结点：
    - 分支结点：度大于0的结点。
    - 叶子结点：度为0的结点。
    - 结点的层次：从树根开始定义，根结点为第一层，它的子结点为第二层，以此类推。双亲在同一层的结点互为堂兄弟。
    - 结点的深度：从根结点开始自顶向下逐层累加的。
    - 结点的高度：从叶结点开始自底向上逐层累加的。
4. 树的高度：树中结点的最大层数。
5. 有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。
6. 路径和路径长度：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。
7. 森林：森林是m(m>=0)棵互不相交的树的集合。

### 三、树的性质

1. 树中的结点数等于所有结点的度数之和+1。

2. 度为m的树中第i层上至多有m^(i-1)个结点(i>=1)。

3. 高度为h的m叉树最多有(m^h-1)/(m-1)个结点。

4. 具有n个结点的m叉树的最小高度为
    $$
    \left\lceil\log_m(n(m-1)+1)\right\rceil
    $$

## 二、二叉树的概念

### 一、二叉树的定义及其主要特性

1. 特点：

    - 每个结点至多只有两棵子树
    - 二叉树的子树有左右之分，次序不能任意颠倒。

2. 定义：二叉树是n(n>=0)个结点的有限集合。

    - 或者为空二叉树，n==0
    - 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树分别又是一棵二叉树。

3. 二叉树与度为2的有序树的区别：

    - 度为2的树至少有三个结点，而二叉树可以为空
    - 度为2的有序树的孩子的左右次序是相对另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无序区分左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。

4. 几个特殊的二叉树：

    - 满二叉树：高度为h，含有(2^h-1)个结点的二叉树。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2.对于满二叉树的编号：
        $$
        \begin{array}{l}\mathrm{双亲}：\left\lfloor i/2\right\rfloor\\\mathrm{左孩子}：2i\\\mathrm{右孩子}：2i+1\end{array}
        $$

    - 完全二叉树：高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中的编号为1~n的结点一一对应时，称为完全二叉树。其特点为：

        - 若i<=n/2向上取整，则结点i为分支结点，否则为叶子结点。
        - 叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。
        - 若有度为1的结点，则只可能有一个，且该结点只有左孩子没有右孩子。
        - 按层次编号后，一旦出现某个结点（编号i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。
        - 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左右孩子都有。

    - 二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。

    - 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1.

5. 二叉树的性质：

    - 非空二叉树上的叶子结点数等于度为2的结点数+1，即
        $$
        n_0=n_2+1
        $$

    - 非空二叉树上第k层上至多有2^(k-1)个结点（k>=1）

    - 高度为h的二叉树至多有2^h-1个结点（h>=1）

    - 对完全二叉树按从上到下、从左到右的顺序依次编号1，2，...，n，则有下列关系：

        - 当i>1时，结点i的双亲的编号为（i/2）向下取整，即当i为偶数时，其双亲的编号为i/2，它是双亲的左孩子；当i为奇数时，其双亲的编号为（i-1）/2，它是双亲的右孩子。

        - 当2i<=n时，结点i的左孩子编号为2i，否则无左孩子。

        - 当2i+1<=n时，结点i的右孩子编号为2i+1，否则无右孩子。

        - 结点i所在层次（深度）为
            $$
            \left\lfloor\log_2i\right\rfloor+1
            $$

    - 具有n个（n>0）结点的完全二叉树的高度为
        $$
        \left\lfloor\log_2n\right\rfloor+1或\left\lceil\log_2(n+1)\right\rceil
        $$

### 二、二叉树的存储结构

1. 顺序存储结构：

    - 定义：用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。
    - 比较适合完全二叉树和满二叉树，既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。

2. 链式存储结构：

    - 定义：用链表结点来存储二叉树中的每个结点。

    - 属性：

        - data：数据域
        - lchild：左孩子
        - rchild：右孩子

    - 代码实现：

        ```c
        typedef struct BiTNode{
        	ElemType data;                            //数据域
        	struct BiTNode *lchild,*rchild;           //左、右指针域
        }BiTNode,*BiTree;                              
        ```


## 三、二叉树的遍历和线索二叉树

### 一、二叉树的遍历

1. 定义：按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。

2. 先序遍历：

    - 操作过程：

        - 访问根结点
        - 先序遍历左子树
        - 先序遍历右子树

    - 代码实现：

        ```c
        void PreOrder(Bitree T){
            if(T!=NULL){
                visit(T);                     //访问根结点
                PreOrder(T->lchild);          //递归遍历左子树
                PreOrder(T->rchild);          //递归遍历右子树
            }
        }
        ```

    - 非递归思路：

        1. 沿着根一边遍历一边将左孩子入栈，直到左孩子为空。
        2. 栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不空，将右孩子转执行1.

    - 代码实现：

        ```c
        void PreOrder2(Bitree T)
        {
            InitStack(S);                      //初始化栈S
            Bitree p = T;                      //p是遍历指针
            while (p || IsEmpty(S)) {          //栈不空或者p不空时循环
                if (p) {                       //一路向左
                    visit(p);                  //访问根结点
                    Push(S, p);                //当前结点入栈
                    p = p->lchild;             //左孩子不空，指向左孩子
                } else {
                    Pop(S, p);                 //出栈
                    p = p->rchild;             //向右子树走
                }
            }
        }
        ```

3. 中序遍历：

    - 操作过程：

        - 中序遍历左子树
        - 访问根结点
        - 中序遍历右子树

    - 代码实现：

        ```c
        void InOrder(Bitree T){
            if(T!=NULL){
                InOrder(T->lchild);           //递归遍历左子树
                visit(T);                     //访问根结点
                InOrder(T->rchild);           //递归遍历右子树
            }
        }
        ```

    - 非递归思路：

        1. 沿着根的左孩子，依次入栈，直到左孩子为空

        2. 栈顶元素出栈并访问：若其右孩子为空，继续执行2；若其右孩子不空，将右子树转执行1.

    - 代码实现：

        ```c
        void InOrder2(Bitree T)
        {
            InitStack(S);                      //初始化栈S
            Bitree p = T;                      //p是遍历指针
            while (p || !IsEmpty(S)) {         //栈不空或者p不空时循环
                if (p) {                       //一路向左
                    Push(S, p);                //当前结点入栈
                    p = p->lchild;             //左孩子不空，指向左孩子
                } else {
                    Pop(S,p);                  //出栈
                    visit(p);                  //访问出栈结点
                    p=p->rchild;               //向右子树走
                }
            }
        }
        ```

4. 后序遍历：

    - 操作过程：

        - 后序遍历左子树
        - 后序遍历右子树
        - 访问根结点

    - 代码实现：

        ```c
        void PostOrder(Bitree T){
            if(T!=NULL){
                PostOrder(T->lchild);          //递归遍历左子树
                PostOrder(T->rchild);          //递归遍历右子树
                visit(T);                      //访问根结点
            }
        }
        ```

    - 非递归思路：

        - 沿着根的左孩子，依次入栈，直到左孩子为空
        - 读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1；否则，栈顶元素出栈并访问

    - 代码实现：

        ```c
        void PostOrder2(Bitree T){
            InitStack(S);
            Bitree p=T,r=NULL;                            //r为标记域，记录是否已被访问
            while (p||IsEmpty(S))
            {
                if(p){
                    Push(S,p);
                    p=p->lchild;
                }
                else{
                    GetTop(S,p);                          //访问栈顶元素
                    if(p->rchild&&p->rchild!=r){          //若右子树存在且未被访问过
                        p=p->rchild;                      //转向右
                    }
                    else{
                        Pop(S,p);                         //否则，弹出结点
                        visit(p);                         //访问当前结点
                        r=p;                              //记录最近访问过的结点
                        p=NULL;                           //结点访问完后，重置p指针
                    }
                }
            } 
        }
        ```

    - 注：p=NULL的作用：每次出栈访问完一个结点相当于遍历完以该结点为根的子树，需将p置NULL。

5. 层次遍历：

    - 操作过程：队列

        1. 先将二叉树根结点入队
        2. 出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队，重复2.

    - 代码实现：

        ```c
        void LevelOrder(Bitree T){
            InitQueue(Q);                            //初始化辅助队列
            Bitree p;
            EnQueue(Q,T);                            //将根结点入队
            while(!IsEmpty(Q)){                      //如果队列非空
                DeQueue(Q,p);                        //队头结点出队
                visit(p);                            //访问出队结点
                if(p->lchild!=NULL){                 //左子树非空
                    EnQueue(Q,p->lchild);            //左子树根结点入队
                }
                if(p->rchild!=NULL){                 //右子树非空
                    EnQueue(Q,p->rchild);            //右子树根结点入队
                }
            }
        }
        ```

6. 由遍历序列构造二叉树：

    - 先序+中序：先序第一个确定根结点，根据中序判断哪些结点在根结点左边，哪些在右边，然后写出二叉树。
    - 后序+中序：后序最后一个确定根结点，根据中序判断哪些结点在根结点左边，哪些在右边，然后写出二叉树。
    - 层次+中序：层次第一个是根结点，根据中序判断哪些结点在根结点左边，哪些在右边，然后写出二叉树。

### 二、线索二叉树

1. 线索二叉树的基本概念：

    1. 引入：在含有n个结点的二叉树中，有n+1个空指针——>可不可以用这些空指针存放指向前驱或后继的指针？

    2. 概念：在二叉树的基础上增加两个标记域ltag和rtag，当ltag为0时代表指向左孩子，为1时代表指向前驱；当rtag为0时代表指向右孩子，为1时代表指向后继。

    3. 线索链表代码实现：

        ```c
        typedef struct ThreadNode {
            ElemType data;                            //数据元素
            struct ThreadNode *lchild, *rchild;       //左、右孩子指针
            int ltag, rtag;                           //左、右线索标记
        } ThreadNode, *ThreadTree;
        ```

2. 中序线索二叉树：

    - 构造：
        - 思想：附设指针pre指向刚刚访问过的结点，中序遍历二叉树，检查p的左指针是否为空，若为空则将它指向pre；检查pre的右指针是否为空，若为空则将它指向p。
        - 代码实现：

        ```c
        void InThread(ThreadTree p,ThreadTree *pre){
            if(p!=NULL){
                InThread(p->lchild,pre);                       //递归，线索化左子树
                if(p->lchild==NULL){                           //左子树为空，建立前驱线索
                    p->lchild=pre;
                    p->ltag=1;
                }
                if(pre!=NULL&&pre->rchild==NULL){
                    pre->rchild=p;                             //建立前驱结点的后继线索
                    p->rtag=1;
                }
                pre=p;                                         //标记当前结点为刚刚访问过的结点
                InThread(p->rchild,pre);                       //递归，线索化右子树
            }
        }
        ```

    - 遍历：

        - 求中序线索二叉树中中序序列下的第一个结点：

            ```c
            ThreadNode* Firstnode(ThreadNode* p)
            {
                while (p->ltag == 0)                      //指向最左下结点（不一定是叶子结点）
                    p = p->lchild;
                return p;
            }
            ```

        - 求中序线索二叉树中结点p在中序序列下的后继：

            ```c
            ThreadNode* Nextnode(ThreadNode* p)
            {
                if (p->rtag == 0)                         //还有右孩子，就指向右孩子
                    return Firstnode(p->rchild);
                else
                    return p->rchild;                     //rtag==1代表rchild为后继
            }
            ```

        - 不含头结点的中序线索二叉树的中序遍历：

            ```c
            void Inorder(ThreadTree T){
                for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)){
                    visit(p);
                }
            }
            ```

        - 求中序线索二叉树中中序遍历下的最后一个结点：

            ```c
            ThreadNode* Lastnode(ThreadNode* p)
            {
                if (p->rtag == 0)
                    p = p->rchild;
                return p;
            }
            ```

        - 求中序线索二叉树中结点p在中序遍历下的前驱：

            ```c
            ThreadNode* Prenode(ThreadNode* p)
            {
                if (p->ltag == 0)
                    return Lastnode(p->lchild);
                else
                    return p->lchild;
            }
            ```

        - 不含头结点的中序线索二叉树的逆遍历：

            ```c
            void RevInorder(ThreadTree T)
            {
                for (ThreadNode* p = Lastnode(T); p != NULL; p = Prenode(p)) {
                    visit(p);
                }
            }
            ```

3. 先序线索二叉树：

    - 构造：
        - 代码实现：

        ```c
        void PreThread(ThreadTree p,ThreadTree *pre){
            if(p!=NULL){
            	if(p->lchild==NULL){                           //左子树为空，建立前驱线索
                    p->lchild=pre;
                    p->ltag=1;
                }
                if(pre!=NULL&&pre->rchild==NULL){
                    pre->rchild=p;                             //建立前驱结点的后继线索
                    p->rtag=1;
                }
                pre=p;                                         //标记当前结点为刚刚访问过的结点
                if(p->ltag==0)
                	PreThread(p->lchild,pre);                   //递归，线索化左子树                                 
                PreThread(p->rchild,pre);                       //递归，线索化右子树
            }
        }
        ```

4. 后序线索二叉树：

    - 构造：
        - 代码实现：

        ```c
        void PostThread(ThreadTree p,ThreadTree *pre){
            if(p!=NULL){
                PostThread(p->lchild,pre);                       //递归，线索化左子树
                PostThread(p->rchild,pre);                       //递归，线索化右子树
                if(p->lchild==NULL){                           //左子树为空，建立前驱线索
                    p->lchild=pre;
                    p->ltag=1;
                }
                if(pre!=NULL&&pre->rchild==NULL){
                    pre->rchild=p;                             //建立前驱结点的后继线索
                    p->rtag=1;
                }
                pre=p;                                         //标记当前结点为刚刚访问过的结点
            }
        }
        ```

## 四、树和森林

### 一、树的存储结构

1. 双亲表示法：

    - 概念：采用一组连续空间来存储每个结点（顺序存储），同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置。

    - 注：根结点下标为0，伪指针域为-1.

    - 代码实现：

        ```c
        #define MAX_TREE_SIZE 50             //树中最多结点数量
        typedef struct {                     //树的结点定义
            ElemType data;                   //数据元素
            int parent;                      //双亲位置域
        } PTNode;
        typedef struct {                     //树的类型定义
            PTNode nodes[MAX_TREE_SIZE];     //双亲表示
            int n;                           //结点数
        }PTree;
        ```

    - 添加操作：直接在最后添加新的结点信息即可

    - 删除操作：

        - 将删除结点的双亲域改为-1并删除数据域，结点数-1
        - 用最后一个结点的信息覆盖删除结点，结点数-1

    - 优点：查指定结点的双亲非常方便

    - 缺点：查指定结点的孩子结点只能从头遍历

2. 孩子表示法：

    - 定义：将每个结点的孩子结点都用单链表连接起来形成一个线性结构。（顺序存储+链式存储）

    - 实质：顺序存储每个结点，孩子结点链式存放。

    - 代码实现：

        ```c
        struct CTNode{                      //孩子链表
            int child;                      //孩子结点在数组中的位置
            struct CTNode *next;            //下一个孩子
        };
        typedef struct{                     //树中结点的定义
            ElemType data;                  //数据元素
            struct CTNode *firstChild;      //第一个孩子
        }CTBox;
        typedef struct{                     //树的类型定义
            CTBox nodes[MAX_TREE_SIZE];     //孩子表示
            int n,r;                        //结点数和根的位置
        }CTree;
        ```

    - 优点：查指定结点的孩子非常方便

    - 缺点：查指定结点的双亲复杂

3. 孩子兄弟表示法：

    - 定义：以二叉链表作为树的存储结构。（链式存储）

    - 三部分：

        - 结点值
        - 指向结点第一个孩子结点的指针
        - 指向结点下一个兄弟结点的指针

    - 代码实现：

        ```c
        typedef struct CSNode{
            ElemType data;                                //数据域
            struct CSNode *firstChild,*nextsibling;       //第一个孩子和右兄弟指针
        }CSNode,*CSTree;
        ```

### 二、树、森林与二叉树的转换

1. 树转换为二叉树：
    - 规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟。
    - 注：根结点没有兄弟，所以对应的二叉树没有右子树。
    - 画法：
        - 在兄弟结点之间加一连线
        - 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉。
        - 以树根为轴心，顺时针旋转45度
2. 森林转换为二叉树：
    - 规则：先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必为空，则把森林中第二课树根视为第一棵树根的右兄弟，以此类推。
    - 画法：
        - 将森林中的每棵树转换成相应的二叉树
        - 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线
        - 以第一棵树的根为轴心顺时针旋转45度
3. 二叉树转换为森林：
    - 规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样地方法，直到最后一棵没有右子树的二叉树为止，再将每棵二叉树依次转换成树，就得到了原森林。

### 三、树和森林的遍历

1. 树的遍历：
    - 先根遍历：
        - 规则：若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。
        - 遍历序列与相应二叉树的先序序列相同
    - 后根遍历：
        - 规则：若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。
        - 遍历序列与相应二叉树的<font color="red">中序序列</font>相同
    - 层次遍历（队列实现）：
        1. 若树非空，则根结点入队
        2. 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
        3. 重复2直到队列为空
    - 注：
        - 层次遍历也称为树的广度优先遍历
        - 先根遍历和后根遍历也称为树的深度优先遍历
2. 森林的遍历：
    - 先序遍历：
        - 规则：
            - 访问森林中第一棵树的根结点
            - 先序遍历第一棵树中根结点的子树森林
            - 先序遍历除去第一棵树之后剩余树构成的森林
        - 实质：
            - 等同于依次对各个树进行先根遍历
            - 等同于对应二叉树的先序遍历
    - 中序遍历：
        - 规则：
            - 中序遍历森林中的一棵树的根结点的子树森林
            - 访问第一棵树的根结点
            - 中序遍历除去第一棵树之后剩余的树构成的森林
        - 实质：
            - 等同于依次对各个树进行后根遍历
            - 等同于对应二叉树的中序遍历

## 五、树和二叉树的应用

### 一、二叉排序树

1. 特性：

    - 若左子树非空，则左子树上所有结点的值均小于根结点的值
    - 若右子树非空，则右子树上所有结点的值均大于根结点的值
    - 左、右子树也分别是一棵二叉排序树

2. 优点：通过中序遍历可以得到一个递增的有序序列

3. 二叉排序树的查找：

    - 思路：若树非空，目标值与根结点比较：若相等，则查找成功；若小于根结点，则在左子树上查找，否则在右子树上查找。

    - 代码实现：空间复杂度：O(1)

        ```c
        BSTNode* BST_Search(BStree T, ElemType key)
        {
            while (T != NULL && key != T->key) {           //若树非空并且查找值不等于根结点的值
                if (key < T->key) {                        //小于，则向左子树查找
                    T = T->lchild;
                } else {                                   //大于，则向右子树查找
                    T = T->rchild;
                }
            }
            return T;
        }
        ```

    - 查找成功返回结点指针，查找失败返回NULL。

    - 递归实现：空间复杂度：O(h)

        ```c
        BSTNode* BSTSearch(BStree T,ElemType key){
            if(T==NULL)
                return NULL;                              //查找失败
            if(key==T->key)
                return T;                                 //查找成功
            else if(key<T->key)
                return BSTSearch(T->lchild,key);          //递归左子树
            else
                return BSTSearch(T->rchild,key);          //递归右子树
        }
        ```

4. 二叉排序树的插入：

    - 思想：若原二叉树为空，则直接插入结点；否则，若关键字小于根结点值，则插入到左子树；若关键字大于根结点值，则插入到右子树。

    - 递归实现：空间复杂度O(h)

        ```c++
        int BST_Insert(BStree &T,ElemType key){
            if(T==NULL){                                   //原树为空
                T=(BStree)malloc(sizeof(BSTNode));
                T->key=key;
                T->lchild=T->rchild=NULL;
                return 1;
            }
            else if(key==T->key){                          //树中存在相同关键字的结点，插入失败
                return 0;
            }
            else if(key<T->key){                           //插入到T的左子树
                return BST_Insert(T->lchild,key);
            }
            else                                           //插入到T的右子树
                return BST_Insert(T->rchild,key);
        }
        ```

5. 二叉排序树的构造：

    - 思想：不断插入

    - 代码实现：

        ```c++
        void Creat_BST(BStree &T,ElemType str[],int n){
            T=NULL;                                             //初始T为空
            int i=0;
            while(i<n){
                BST_Insert(T,str[i]);                           //依次将每个关键字插入到二叉排序树中
                i++;
            }
        }
        ```

6. 二叉排序树的删除：

    1. 若被删除结点x是叶子结点，则直接删除
    2. 若结点x只有一棵左子树或右子树，则让x的子树称为x父结点的子树，代替x的位置
    3. 若x有左右两棵子树，则令x的直接后继（或直接前驱）替代x，然后从二叉排序树中删除这个直接后继（直接前驱），就会转变成1或2.

7. 二叉排序树的查找效率：

    - 查找长度：在查找运算中，需要对比关键字的次数——反映了查找操作时间复杂度

    - 查找成功的平均查找长度ASL：
        $$
        ASL=\sum_{i=1}^{树的高度}\left(每一排结点个数\times该层层数\right)\div结点总数
        $$

    - 时间复杂度：

        - 最好情况：
            $$
            O(log_2n)
            $$

        - 最坏情况：O(n)

    - 查找失败的平均查找长度ASL：

        - 补齐每个叶子结点的左右孩子

        $$
        ASL=\sum_{最低深度}^{最高深度}\left(每一排补充结点个数\times该层层数\right)\div结点总数
        $$


### 二、平衡二叉树

1. 定义：树上任一结点的左子树和右子树的高度之差不超过1.

2. 结点的平衡因子：左子树高-右子树高

3. <font color="red">平衡二叉树结点的平衡因子的值只可能是-1，0，1</font>

4. 代码实现：

    ```c++
    typedef struct AVLNode{
        ElemType key;                           //数据域
        int balance;                            //平衡因子
        struct AVLNode *lchild,*rchild;
    }AVLNode, *AVLTree;
    ```

5. 平衡二叉树的插入：

    1. 最小不平衡子树：插入路径上里插入结点最近的平衡因子中大于1的结点为根的子树。
    2. 调整最小不平衡子树：
        - LL平衡旋转：
            - 条件：在结点A的左孩子(L)的左子树(L)上插入了新结点，导致以A为根的子树失去平衡
            - 解决方法：进行一次向右旋转，将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。
            - 图解：![LL](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/LL.png)
        - RR平衡旋转：
            - 条件：在结点A的右孩子(R)的右子树(R)上插入了新结点，导致以A为根的子树失去平衡
            - 解决方法：进行一次向左旋转，将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。
            - 图解：![RR](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/RR.png)
        - LR平衡旋转：
            - 条件：在A的左孩子(L)的右子树(R)上插入新结点，导致以A为根的子树失去平衡。
            - 解决方法：进行两次旋转操作，先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后把该C结点向右上旋转提升到A结点的位置。
            - 图解：![LR](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/LR.png)
        - RL平衡旋转：
            - 条件：在A的右孩子(R)的左子树(L)上插入新结点，导致以A为根的子树失去平衡。
            - 解决方法：进行两次旋转操作，先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后把该C结点向左上旋转提升到A结点的位置。
            - 图解：![RL](https://oliver-picture.oss-cn-beijing.aliyuncs.com/img/RL.png)

6. 平衡二叉树的查找效率：

    - 时间复杂度：O(h)

    - 深度为h的平衡树中最少结点数的公式：(n0=0,n1=1,n2=2)
        $$
        n_h=n_{h-1}+n_{h-2}+1
        $$

### 三、哈夫曼树

1. 哈夫曼树的定义：

    - 结点的权：有某种现实含义的数值。

    - 结点的带权路径长度：从树的根结点到该结点的路径长度（经过的边数）与该结点上权值的乘积。

    - 树的带权路径长度WPL：树中所有叶子结点的带权路径之和。
        $$
        WPL=\sum_{i=1}^{n}{w_il_i}
        $$

    - 哈夫曼树：

        - 定义：在含有n个带权叶子结点的二叉树中，其中WPL最小的二叉树。
        - 性质：
            - 每个初始结点最终都成为叶子结点，且权值越小的结点到根结点的路径长度越大。
            - 构造过程中共新建了n-1个结点，总结点数为2n-1.
            - 哈夫曼树中不存在度为1的结点。
            - 哈夫曼树不唯一，但WPL必然相同且为最优。

2. 哈夫曼树的构造：

    1. 将n个结点分别作为n棵仅含一个几点的二叉树，形成森林F。

    2. 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。

    3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
    4. 重复2、3步骤，直至F中只剩下一棵树。

3. 哈夫曼编码：
    - 定义：字符集中的每个祖父字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前的方法构造哈夫曼树。
    - 左0右1
    - 哈夫曼编码不唯一，但是WPL一定相同且最优